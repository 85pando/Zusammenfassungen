\documentclass[a4paper, 10pt]{article}

%\usepackage{scalefnt}
%\usepackage{parcolumns}

\usepackage{newclude}
\include{../zusammenfassung}

\begin{document}

\Gruppe{Stephan Heidinger}{MCSS - Zusammenfassung v0.1}
\Header{Modell Checking in Software Systems}{WS 12/13}{Stephan Heidinger}

\begin{shaded}
Dieses Dokument wurde unter der Creative Commons - Namensnennung-NichtKommerziell-Weitergabe unter gleichen Bedingungen (\textbf{CC by-nc-sa}) veröffentlicht. Die Bedingungen finden sich unter \href{http://creativecommons.org/licenses/by-nc-sa/3.0/de}{diesem Link}. \\
\centerline{./../cc-by-nc-sa.png}
\end{shaded}

\textit{\hm \; Find any errors? Please send them back, I want to keep them!}

\section*{Basic Principle}
\begin{multicols}{2}
given:
\begin{itemize}
    \item Software Model $M$
    \item Property Specification $S$
\end{itemize}
does $M\models S$
\columnbreak
\begin{center}
\scalebox{0.75}{\input{images/basic_principle.tikz}}
\end{center}
\end{multicols}

\section*{Classification of Software Systems}
\begin{description}
    \item[Transformational Systems] transforms set of (empty) input data into output data, function from state $S_i$ to $S_k$ \\ correctness:
    \begin{itemize}
        \item termination
        \item correctness of function $S_i\to S_k$
        \item correctness of input - output transformation
    \end{itemize}
    \item[Reactive Systems] ongoing interaction with environment, driven by environment \\ correctness:
    \begin{itemize}
        \item non-termination (normally)
        \item correctness of stimuli-response pairs
    \end{itemize}
    \item[Embedded Systems] usually reactive, directly connected to hardware
    \item[Cyber-Physical Systems] integration of computation and physical processes
    \item[Real-Time Systems] systems, where correctness depends on time a result is delivered
    \begin{description}
        \item[Soft Real-Time Systems] missed deadlines will decrease result, not lead to failure, propabilities
        \item[Hard Real-Time Systems] missed deadlines will lead to failure
    \end{description}
    \item[Hybrid Systems] state is characterized by discrete and continuous variables
    \item[Safety-Critical Systems] systems failure may entail, death, serious injury, environmental harm, damage to property/assets
\end{description}

\section*{Requirement Specification}
\begin{description}
    \item[Natural Language] \ \\
    \begin{itemize}
        \good very expressive
        \good understood by all parties
        \bad ambiguous
    \end{itemize}
    \item[Formal Language] \ \\
    \begin{itemize}
        \good unambigous
        \good machine-analyzeable
        \bad limited expressiveness
        \bad hard to understand
    \end{itemize}
\end{description}

\section*{Software Verification Method}
\subsection*{Requirements}
\begin{itemize}
    \item formal foundation (automatic procedures)
    \item should be capable of relating artifacts from different stages in design cycle (formal vs informal req, design vs req, \dots)
    \item should be easy to integrate in design cycle (high degree of automation, low degree of interaction)
    \item scalable
\end{itemize}

\subsection*{Model Checking Process}
\begin{enumerate}
    \item provide model (e.g. Promela), involves abstraction
    \item simulate (check if model does, what you want)
    \item elicit and formalize requirements $\Rightarrow$ property specification
    \item model execution: run model checker with model and specification\\ outcome:
    \begin{itemize}
        \item property is valid (check next property)
        \item property is invalid (counterexample, check model for errors, check properties for errors, rethink design)
        \item exhaust of memory (use more abstraction, state space reduction, incomplete methods)
        \item exhaust of time (smaller model, faster computer)
    \end{itemize}
\end{enumerate}

\section*{\textsc{Spin}}
\begin{itemize}
    \item designed for communication protocols
    \item Open Source
    \item still in development
    \item Promela (\textsc{PROtocol/PROcess MEta LAnguage})
    \begin{itemize}
        \item concurrent modeling language
        \item guarded commands
        \item modeling of reactive systems
    \end{itemize}
\end{itemize}

\subsection*{State-Based Modeling}
\subsubsection*{State}
\begin{itemize}
    \item salient features of a system at given point of observation
    \item states can be observed, as long as features of interest unchanged
    \item features of interest
    \begin{description}
        \item[point of control] ``program counter'' (of all processes)
        \item[values] of local and global variables
        \item[communication channels] (messages sent but not received)
    \end{description}
    \item state vector (byte-wise representation of features of interest) \\
    % \begin{center}
    \scalebox{1}{\input{images/state-vector.tikz}}
    % \end{center}
\end{itemize}

\subsubsection*{State Transition}
\begin{itemize}
    \item instantaneous change of observed features of the system (``something happens'')
    \item represents computation step
    \item sequence of state transitions characterize system computation \\
    % \begin{center}
    \scalebox{1}{\input{images/transition.tikz}}
    % \end{center}
    \item in real-time systems, time passes in states
    \item in stochastic systems, transitions are labeled with probability distributions
    \item in hybrid systems, continuous and discrete state variables change during state transition
    \item transitions show the possible events
    \item transition sequences are valid computations sequences
    \item transitions encode history ($S_0$ has been visited before $S_1$)
\end{itemize}

\subsubsection*{Devising State-Machines}
\begin{itemize}
    \item ``programm a model''
    \item abstraction: focus on relevant, can lead to non-determinism
    \item simplicity: find most simple abstraction that still reveals phenomena
\end{itemize}

\subsubsection*{Deadlock}
\begin{itemize}
    \item concurrent processes wait for each other in a circular wait with no pre-emption
    \item highly undesired
\end{itemize}

\subsubsection*{Closed System Modeling}
\begin{itemize}
    \item model checker can only validate all possible system executions under assumed environment
    \item model includes also environment
\end{itemize}

\subsection*{Transition Systems}
\begin{shaded}
Transition System $TS$ is a tuple $(S,Act,\to,I,AP,L$ where \\
\begin{minipage}{0.48\textwidth}
\begin{tabular}{ll}
$S$ & is a set of states \\
$Act$ & is a set of actions \\
$\to\subseteq S\times Act\times S$ & is a transition relation \\
$I\subseteq S$ & is a set of initial states \\
$AP$ & is a set of atomic propositions \\
$L:S\to2^AP$ & is a labeling function \\
\end{tabular}
\end{minipage}
\hfill \vrule \hfill
\begin{minipage}{0.48\textwidth}
\begin{itemize}
    \item where $S$ and $Act$ are finite or countably infinte
    \item we write $s\to^\alpha s'$ for $\left(s,\alpha,s'\right)\in\to$
    \item Atomic Propositions: Facts that we want to observer/that are observable in the system in any given state.
    \item Labeling Function: shows, which atomic propositions hold in given state.
\end{itemize}
\end{minipage}
\end{shaded}

\begin{shaded}
    \begin{align*}
        Post(s,\alpha) &= \left\{ s'\in S | s\overset{\alpha}{\longrightarrow} s' \right\}
        & Post(s)&=\bigcup_{\alpha\in Act} Post(s,\alpha)
        \\
        Pre(s,\alpha) &= \left\{ s'\in S | s'\overset{\alpha}{\longrightarrow} s \right\}
        & Pre(s)&=\bigcup_{\alpha\in Act} Pre(s,\alpha)
        \\
        Post(C,\alpha) &= \bigcup_{s\in C} Post(s,\alpha),
        & Post(C) &= \bigcup_{s\in C} Post(s)\textrm{ for } C\subseteq S
        \\
        Pre(C,\alpha) &= \bigcup_{s\in C} Pre(s,\alpha),
        & Pre(C) &= \bigcup_{s\in C} Pre(s)\textrm{ for } C\subseteq S
        \\
    \end{align*}
    \begin{center}
    a state is \emph{terminal} or \emph{final} iff $Post(s)=\varnothing$
    \end{center}
\end{shaded}

\subsubsection{(Non)Determinism}
\begin{shaded}
    A transition system $TS=\left(S,Act,\to,I,AP,L\right)$ is \emph{action-deterministic}, iff for all $s,\alpha$
    \begin{itemize}
        \item $|I|\leq1$ and
        \item $|Post(s),\alpha)|\leq1$
    \end{itemize}
    else it is \emph{action-nondeterministic} \\
    {\tiny there is at most one outgoing transition from each state labeled $\alpha$}
\end{shaded}

\begin{shaded}
    A transition system $TS=\left(S,Act,\to,I,AP,L\right)$ is \emph{AP-deterministic}, iff for all $s,A\in2^{AP}$
    \begin{itemize}
        \item $|I|\leq1$ and
        \item $|Post(s)\cap \left\{s'\in S | L(s')=A\right\}|\leq1$
    \end{itemize}
    else it is \emph{AP-nondeterministic} \\
    {\tiny every successor of a state $s$ has a unique $AP$ labeling}
\end{shaded}

\begin{itemize}
    \item Nondeterminism can lead to potentially smaller representation.
    \item in Software Engineering/Modeling: Abstraction
    \begin{itemize}
        \item avoid overspecification
        \item what does the system do, not how is it done
    \end{itemize}
    \begin{itemize}
        \item concurrency
        \begin{itemize}
            \item simulate concurrency by nondeterminsm
            \item either nondeterministic action can be executed first
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection*{System Execution}
Given a transition system $TS=\left(S,Act,\to,I,AP,L\right)$
\begin{description}
    \item[finite execution fragment] $\varrho$ of $TS$ is an alternating sequence of states and actions ending with a state:
    \[ \varrho = s_0\alpha_1 s_1\alpha_2\dots\alpha_n s_n \textrm{ s.t. } s_i\to^{\alpha_{i+1}} s_{i+1} \textrm{ for all } 0\leq i<n \]
    \item[infinite execution fragment] $\varrho$ of $TS$ is an infinite, alternating sequence of states and actions:
    \[ \varrho = s_0\alpha_1 s_1\alpha_2\dots\alpha_n s_n \textrm{ s.t. } s_i\to^{\alpha_{i+1}} s_{i+1} \textrm{ for all } 0\leq i \]
    \item[execution] of TS is an inital, maximal execution fragment
    \begin{itemize}
        \item an execution fragment is maximal, iff it is either
        \begin{itemize}
            \item finite and ending in a terminal state
            \item[or]
            \item infinite
        \end{itemize}
        \item an execution fragment is initial, iff $s_0\in I$
    \end{itemize}
    \item[reachable state] is a state $s\in S$ if there exists an initial, finite execution fragment $s_0\alpha_1s_1\dots\alpha_ns_n$ so that $s_n=s$
    \item[$Reach(TS)$] denotes the set of all reachable states in $TS$ \\
    % \begin{center}
    \scalebox{1}{\input{images/reach.tikz}}
    % \end{center}
\end{description}

\section*{Program Graphs \textsc{Pg}}
\begin{itemize}
    \item want to include things like variables, assignements, etc $\Rightarrow$ Program Graphs
    \item introduce conditional transitions (transition can only be exectured, if condition is true) \[ s \overset{\red g:\blue\alpha}{\longrightarrow}s' \]
    \begin{itemize}
        \item $\red g$: a boolean condition on data variables (``guard'')
        \item $\blue\alpha$: an action, that is possible, if g is satisfied
    \end{itemize}
    \item assume domain of variables as infinite
    \begin{itemize}
        \item practical implementations use variables over finite domains
    \end{itemize}
    \item Stepwise unfolding of $PG$s lead to $TS$
\end{itemize}

\begin{description}
    \item[valuation:] assign values to variables (e.g. $\eta(x)=17$)
    \item[propositional logic formulae]
    \item[effect] of actions: \[ Effect: Act\times Eval(Var)\to Eval(Var) \]
    Effects define \emph{operational semantics}
\end{description}

\begin{shaded}
    A \emph{program graph} $PG$ over set $Var$ of typed variables is a tuple $\left( Loc, Act, Effect, \to, Loc_0, g_0 \right)$ where
    \begin{itemize}
        \item $Loc$ is a set of locations with initial locations $Loc_0\subseteq Loc$
        \item $Act$ is a set of actions
        \item $Effect: Act\times Eval(Var)\to Eval(Var)$ is the effect function
        \item $\to \subseteq Loc\times \left(Cond(Var) \times Act\right) \times Loc $, transition relation {\tiny cond = boolean condition}
        \item $g_0\in Cond(Var)$ is the inital condition
    \end{itemize}
    Notation $\ell\overset{\red g:\blue\alpha}{\longrightarrow} \ell'$ denotes $\left(\ell,\red g, \blue\alpha,\ell'\right)\in \longrightarrow$
\end{shaded}
\subsection*{Semantics for Program Graphs}
\begin{itemize}
    \item Unfolding: Transformation of $PG$ to equivalent $TS$
    \begin{itemize}
        \item states:
        \begin{itemize}
            \item state $<l,\eta\rangle$: current control location $l$ + data valuation $\eta$
            \item initial state: initial location satisfying condition $g_0$
        \end{itemize}
        \item propositions:
        \begin{itemize}
            \item $at\_l$: control is at location $l$
            \item $x\in D$ iff $D\subseteq dom(x)$
        \end{itemize}
        \item labeling
        \begin{itemize}
            \item $<l,\eta\rangle$ is labeled with $at\_l$ and all conditions that hold in $\eta$
        \end{itemize}
    \end{itemize}
    \item from transitions in $PG$ to transitions in $TS$
    \begin{itemize}
        \item if $\ell\overset{\red g:\blue\alpha}{\longrightarrow} \ell'$ and $g$ holds in $\eta$, then $<l,\eta\rangle\to^\alpha<l',Effect(\alpha,\eta)\rangle$
    \end{itemize}
\end{itemize}

\subsection*{Structured Operational Semantics \textsc{Sos}}
\begin{itemize}
    \item definition of \emph{operational semantics} of a program in terms f computations steps defined by a transition system
    \item whether a step happens is determined by inference rules: \[ \frac{premise}{conclusion} \]
    \begin{itemize}
        \item if the premise holds, the conclusion holds (and can trigger further inference rules)
        \item if the premise is a \emph{tautology}, it may be omited\\
        the rule is then called an \emph{axiom}
    \end{itemize}
    \item semantics is structural, because it applies inference rules recursively to syntactic structure
\end{itemize}

\subsection*{Transition Systems for Program Graphs}
\begin{shaded}
    The transition system $TS(PG)$ of program graph \[PG=(Loc, \blue{Act}, Effect,\longrightarrow, Loc_0,g_0)\] over set $Var$ of variables is the tuple \[ (S,\blue{Act},\longrightarrow,I,AP,L) \] where
    \begin{itemize}
        \item $S=Loc\times Eval(Var)$
        \item $\longrightarrow\subseteq S\times Act\times S$ is defined by $\displaystyle\frac{\ell\overset{\red g:\blue\alpha}{\longrightarrow} \ell'\; \wedge \; \eta\models \red g}{<\ell,\eta\rangle\overset{\blue\alpha}{\longrightarrow}<\ell',Effect(\blue\alpha,\eta)\rangle}$
        \item $I=\left\{<\ell,\eta\rangle | \ell \in Loc_0,\eta \models g_0\right\}$
        \item $AP=Loc \cup Cond(Var)$ and $L\left(<\ell,\eta\rangle\right)=\{\ell\} \cup \left\{ g\in Cond(Var) | \eta \models g \right\} $
    \end{itemize}
\end{shaded}

\subsubsection*{Data in Transition Systems}
\begin{itemize}
    \item $TS$ do not possess data variables, data values and their changes need to be encoded in states
    \item assume $i=1,\dots,n$ variables of domain $s_i$ \follows $\Pi^n_{i=1}s_i$ \\
    \emph{combinatorial, exponential state space explosion}
    \item variables over infinite domains \follows infinite number of states
\end{itemize}

\section*{Modelling Concurrency}
\subsection*{Concurrent Event}
\begin{itemize}
    \item logically independent events in separate autonomous system
\end{itemize}

\subsection*{Lamport's \emph{happened-Before} Relation $\to$}
\begin{shaded}
    \begin{description}
        \item[HB1:] for any pair of events $e$ and $e'$, if there is a process $p_i$ such that $e \to_i e'$, then $e \to e'$
        \item[HB2:] for any pair of events $e$ and $e'$ and for any message $m$, if $e = send(m)$ and $e' = receive(m)$, then $e \to e'$
        \item[HB3:] if $e$, $e'$ and $e''$ are events and if $e \to e'$ and $e' \to e''$, then $e \to e''$ (HB is identical to its transitive closure)
    \end{description}
\end{shaded}

\begin{center}
\scalebox{1}{\input{images/lamport.tikz}}
\end{center}

\subsection*{Concurrency}
\begin{itemize}
    \item two events are $E_1, E_2$ are concurrent, if each ordering of them is possible
\end{itemize}

\subsection*{Interleaving}
\begin{itemize}
    \item concurrent actions $\alpha,\beta$ are executed in arbitrary order
    \item $Effect(\alpha \interleave \beta,\nu) = Effect((\alpha;\beta)+(\beta;\alpha),\nu$
    \begin{itemize}
        \item $\interleave$  is binary interleaving operator
        \item $;$ is sequential execution
        \item $+$ is nondeterministic choice
        \item $\underset{=\alpha}{\underbrace{x:=x+1}} \interleave \underset{=\alpha}{\underbrace{y:=y-2}}$ \\
        \begin{center}
        \scalebox{.8}{\input{images/interleave.tikz}}
        \end{center}
    \end{itemize}
    \begin{shaded}
        Let $TS_i=(S_i,Act_i,\to_i,I_i,AP_i,L_i), i=1,2$ be two transition systems.
        \[ TS_1\interleave TS_2 = (S_1\times S_2,Act_1\uplus Act_2),\to,I_1\times I_2,AP_1\uplus AP_2, L) \]
        where $L(\langle s_1,s_2\rangle)=L_1(s_1) \cup L_2(s_2)$ and the transition relation $\to$ is defined by the rules:
        \[
        \frac{\red{s_1}\overset{\alpha}{\longrightarrow}_1 \red{s'_1}}
        {\langle\red{s_1},s_2\rangle \overset{\alpha}{\longrightarrow} \langle\red{s'_1},s_2\rangle}
        \textrm{ and }
        \frac{\red{s_2}\overset{\alpha}{\longrightarrow}_2 \red{s'_2}}
        {\langle s_1,\red{s_2}\rangle \overset{\alpha}{\longrightarrow} \langle s_1,\red{s'_2}\rangle}
        \]
    \end{shaded}
    \begin{itemize}
        \item Interleaving of Program Graphs\\
        let $PG_1$ and $PG_2$ be program graphs
        \begin{description}
            \item[without shared variables:] \ \\
            i.e. $Var_1\cap Var_2=\varnothing$\\
            concurrent behaviour: $TS(PG_1)\interleave TS(PG_2)$
            \item[with shared variables:] \ \\
            concurrent behaviour: $TS(PG_1 \interleave PG_2)$
            \item[in general:] \ \\
            $TS(PG_1) \interleave TS(PG_2) \not= TS(PG_1\interleave PG_2)$
        \end{description}
        \begin{shaded}
            For program graph $PG_i=(Loc_i,Act_i,Effect_i,\longrightarrow_i,Loc_{0,i},g_{0,i})$ over variables $Var_i$, the Program graph $PG_1\interleave PG_2$ over $Var_1\cup Var_2$ is defined by:
            \[ (Loc_1\times Loc_2,Act_1\uplus Act_2,Effect,\longrightarrow,Loc_{0,1}\times Loc_{0,2},g_{0,1}\wedge g_{0,2}) \]
            where $\longrightarrow$ is defined by the inference rules:
            \[
            \frac{\red{l_1} \overset{g:\alpha}{\longrightarrow} \red{l'_1}}
            {\langle \red{l_1},l_2 \rangle \overset{g:\alpha}{\longrightarrow} \langle \red{l'_1},l_2 \rangle}
            \textrm{ and }
            \frac{\red{l_2} \overset{g:\alpha}{\longrightarrow} \red{l'_2}}
            {\langle l_1,\red{l_2} \rangle \overset{g:\alpha}{\longrightarrow} \langle l_1,\red{l'_2} \rangle}
            \]
            and $Effect(\alpha,\eta)=Effect_i(\alpha,\eta)$ if $\alpha\in Act_i$.
        \end{shaded}
        \begin{center}
        \scalebox{.7}{\input{images/interleavePgTs.tikz}}
        \end{center}
        \item \textbf{atomicity} a sequence of statements is called \emph{atomic}, if it cannot be interleaved with program statements from a concurrently executing program. \\
        \[\underset{atomic}{\underbrace{\langle x:=x+1;y:=2x+1\rangle}} ; x:=0\]
    \end{itemize}
\end{itemize}

\subsection*{Inter Process Synchronisation}
\begin{itemize}
    \item concurrent processes need to synchronize their computations
    \begin{itemize}
        \item adjust relative speed
        \item exchange data, that may be needed by other processes
    \end{itemize}
    \item common synchronization methods:
    \begin{itemize}
        \item shared variables
        \item message passing
        \begin{itemize}
            \item synchronous (rendez-vous, handshaking) \\
            wait till other party is ready
            \begin{shaded}
                Let $TS_i=(S_i,Act_i,\longrightarrow_i,I_i,AP_i,L_i), i=1,2$ and $H\subseteq Act_1\cap Act_2$. \\
                Introducing: The \emph{handshake-operator} $\Vert_H$ for an action set $H$ in the following way:
                \[ TS_1 \Vert_H TS_2 = (S_1\times S_2,Act_1\cup Act_2,\longrightarrow,I_1\times I_2, AP_1 \uplus AP_2,L) \]
                where $(\langle s_1,s_2\rangle) = L_1(s_1)\cup L_2(s_2)$ and $\longrightarrow$ is defined as follows
                \begin{itemize}
                    \item for $\alpha\not\in H$ (interleaving)
                    \[
                    \frac{
                    s_1 \overset{\alpha}{\longrightarrow} s'_1
                    }{
                    \langle s_1,s_2 \rangle \overset{\alpha}{\longrightarrow} \langle s'_1,s_2 \rangle
                    }
                    \phantom{\textrm{ and ·}}
                    \frac{
                    s_2 \overset{\alpha}{\longrightarrow} s'_2
                    }{
                    \langle s_1,s_2 \rangle \overset{\alpha}{\longrightarrow} \langle s_1,s'_2 \rangle
                    }
                    \]
                    \item for $\alpha\in H$ (handshaking)
                    \[
                    \frac{
                    s_1 \overset{\alpha}{\longrightarrow}_1 s'_1 \wedge s_2 \overset{\alpha}{\longrightarrow}_2 s'_2
                    }{
                    \langle s_1,s_2 \rangle \overset{\alpha}{\longrightarrow} \langle s'_1,s'_2 \rangle
                    }
                    \]
                    \item $\Vert$ is shorthand for $\Vert_H$ when $H=Act_1\cap Act_2$
                \end{itemize}
            \end{shaded}
            \item asynchronous (typically fifo, queue)
            \begin{itemize}
                \item $c!e$: send the value of expression $e$ along the channel $c$
                \item $c?x$: receive a message from channel $c$ and assign it to variable $x$
                \item channels have storage capacity $cap(c)$
                    \\ if $cap(c)\in\mathbb{N}$, then $c$ is a channel with finite capacity
                    \\ if $cap(c)=\infty$, then $c$ has infinite capacity
                    \\ $cap(c)=0$ sometimes means, that the channel uses synchronous handshake communication
                \item types of communication:
                \begin{description}
                    \item[non-blocking:] execution never delays invoker
                    \item[blocking:] otherwise
                \end{description}
                \item when is blocking taking place?
                    \\ asynchronous message passing with unbounded buffers \follows sender never blocks
                    \\ synchronous message passing: no buffering
                    \\ buffered message passing with bounded, finite capacity
                    \begin{description}
                        \item[sender blocks] on full buffer
                        \item[sender does not block] on full buffer (entails message loss)
                    \end{description}
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection*{Channel System}
\begin{shaded}
    A \emph{channel system} $CS$ over $(Var,Chan)$ consists of $i$ program graphs $PG_i$ over $(Var_i,Chan_i)$, for $1\leq i\leq n$, with $Var=\bigcup_{1\leq i\leq n}Var_i$ and is denoted by $CS=[PG_1 | \dots | PG_n ]$ \\
    Global states are tuples of the form $\langle l_1,\dots,l_n,\eta, \xi \rangle$ where
    \begin{description}
        \item[$l_i$] current control location of process $i$
        \item[$\eta$] current valuation of variables
        \item[$\xi$] current valuation of channels
    \end{description}
    \begin{itemize}
        \item A \emph{channel evaluation} $\xi$ is a mapping from channel $c\in Chan$ onto sequence $\xi(c)\in dom(c)^*$ such that
        \begin{itemize}
            \item current length cannot exceed the capacity of $c:len(\xi(c))\leq cap(c)$
            \item $\xi(x)=v_1v_2\dots v_k, cap(c)\geq k$ denotes, $v_1$ is at front of buffer, etc.
            \item $\xi [c:=v_1\dots v_k]$ denotes channel evaluation
            \[ \xi [c:=v_1\dots v_k] (c') =
            \begin{cases}
            \xi(c') & if c \not= c' \\
            v_1\dots v_k & c=c
            \end{cases}
            \]
            \item initial channel evaluation $\xi_0$ equals $\xi_0(c)=\varepsilon$ for any $c$.
        \end{itemize}
        Let $CS=[PG_1 | \dots | PG_n ]$ be a \emph{channel system} over $(Chan,Var)$ with
        \[ PG_i = (Loc_i, Act_i, Effect_i,) \rightsquigarrow_i, Loc_{0,i}, g_{0,i}, \textrm{ for } 0<i\leq n \]
        $TS(CS)$ is the \emph{transition system} $(S,Act,\to,I,AP,L)$ where
        \begin{itemize}
            \item $S=(Loc_1\times\dots\times Loc_n)\times Eval(Var) \times Eval(Chan)$
            \item $Act = (\biguplus_{0<i\leq n} Act_i) \uplus \{ \tau \}$
            \item $I=\left\lbrace \langle \ell_1,\dots \ell_n,\eta,\xi_0 \rangle | \forall i. (l_i\in Loc_{0,i} \wedge \eta \models g_{0,i}) \wedge \forall c.\xi_0(c)=\varepsilon \right\rbrace$
            \item $AP=\biguplus_{0<i\leq n} Loc_i \uplus Cond(Var)>$
            \item $L(\langle \ell_1,\dots,\ell_n,\eta,\xi\rangle) = \{\ell_1,\dots,\ell\} \cup \{g\in Cond(Var) | \eta \models g \}$
            \item $\to$ is defined by the inference rules:
            \begin{description}
                \item[Interleaving for $\alpha\in Act_i$:]
                \[
                \frac{
                \red{\ell_i} \overset{g:\alpha}{\longrightarrow} \red{\ell'_i} \wedge \eta \models g
                }{
                \langle \ell_1,\dots,\red{\ell_i},\dots,\ell_n,\blue\eta,\xi \rangle
                \overset{\alpha}{\longrightarrow}
                \langle \ell_1,\dots,\red{\ell'_i},\dots,\ell_n,\blue{\eta'},\xi \rangle
                },
                where \;\blue{\eta'} = Effect(\alpha,\blue\eta)
                \]
                \item[Synchronous message passing over $c\in Chan, \; cap(c)=0$:]
                \[
                \frac{
                \red{\ell_i} \overset{g:c?x}{\longrightarrow} \red{\ell'_i}
                \wedge
                \red{\ell_j} \overset{g:c!e}{\longrightarrow} \red{\ell'_j}
                \wedge \eta \models g\wedge g' \wedge i\not=j
                }{
                \langle \ell_1,\dots,\red{\ell_i},\dots, \red{\ell_j}\dots,\ell_n,\blue\eta,\xi \rangle
                \overset{\tau}{\longrightarrow}
                \langle \ell_1,\dots,\red{\ell'_i},\dots,\red{\ell'_j}\dots,\ell_n,\blue{\eta'},\xi \rangle
                },
                where \; \blue{\eta'} = \blue{\eta} [x:=\eta(e)]
                \]
                \item[Asynchronous message passing over $c\in Chan, cap(c)<0$:]
                \[\frac{
                \red{\ell_i} \overset{g:c?x}{\longrightarrow} \red{\ell'_i}
                \wedge
                \eta\models g
                \wedge
                len(\xi(c)) = k>0
                \wedge
                \eta(c) = v_1\dots v_k
                }{
                \langle \ell_1,\dots,\red{\ell_i},\dots,\ell_n,\blue\eta,\dGreen\xi \rangle
                \overset{\alpha}{\longrightarrow}
                \langle \ell_1,\dots,\red{\ell'_i},\dots,\ell_n,\blue{\eta'},\dGreen{\xi'} \rangle
                },
                where \; \blue{\eta'} = \blue{\eta} [x:=v_1] \textrm{ and } \dGreen{\xi'}=\dGreen\xi [c:=v_2\dots v_k]
                \]
                \item[transmit value $\eta(e)\in dom(c)$ over channel $c$:]
                \[\frac{
                \red{\ell_i} \overset{g:c!\blue e}{\longrightarrow} \red{\ell'_i}
                \wedge
                \eta \models g
                \wedge
                len(\eta(c))=k<cap(c)
                \wedge
                \eta(c) = v_1\dots v_k
                }{
                \langle \ell_1,\dots,\red{\ell_i},\dots,\ell_n,\eta,\dGreen\xi \rangle
                \overset{\alpha}{\longrightarrow}
                \langle \ell_1,\dots,\red{\ell'_i},\dots,\ell_n,\eta',\dGreen{\xi'} \rangle
                },
                where \; \dGreen{\xi'}=\dGreen\xi [c:=v_1v_2\dots v_k\eta(\blue e)]
                \]
            \end{description}
        \end{itemize}
    \end{itemize}
\end{shaded}

\subsection*{nanoPromela}
\follows 5-38 to 5-50

\subsection*{State Machine Based Modeling}
\begin{itemize}
    \item Practical use: no TS or PG \follows state machine models \\
    can all be modelled as Program Graphs, Channel Systems or Transition Systems \\
    $\textsc{Uml-Rt} \subset \textsc{Uml}:$ state charts
    \item Mealy and Moore Machines \\
    \begin{itemize}
        \item  expressively equivalent
        \item non-deterministic
    \end{itemize}
    \begin{shaded} let
    \begin{tabular}{ll}
        $Q:$ & finite set of states \\
        $q_0\in Q$: & initial state \\
        $I$: & an alphabet (input symbols) \\
        $O \textrm{ with }I\cap O=\varnothing:$ & an alphabet (output symbols) \\
        $A=I\cup O$ & event alphabet \\
        $\delta: Q\times A\to Q:$ & a relation \\
        $\rho: Q\times I\to O\times Q:$ & a relation \\
        \end{tabular}
    \begin{description}
        \item[Moore machine:] we call $(Q, q_0, A, \delta)$ a \textbf{finite Moore machine}
        \begin{center}
        \scalebox{1}{\input{images/moore.tikz}}
        \end{center}
        \item[Mealey machine:] we call $(Q,q_0,I,O,\rho)$ a \textbf{finite Mealey machine}
        \begin{center}
        \scalebox{1}{\input{images/mealey.tikz}}
        \end{center}
    \end{description}
\end{shaded}
    \item Desiderata for Reactive System Models:
    \begin{enumerate}
        \item representation of \emph{data}
        \item representation of \emph{concurrency}
        \item representation of \emph{communication}\\
        especially: asynchronous communication / message passing
    \end{enumerate}
    \item Communicating Finite State Machines \textsc{Cfsm}s
    \begin{itemize}
        \item groups of independent, concurrently executing state machines
        \item communication and synchronization by message passing over unbounded buffers
    \end{itemize}
    \item Extended Finite State Machines \textsc{Efsm}
    \begin{itemize}
        \item data variables
        \item predicates
        \item operations
    \end{itemize}
    \item \textsc{Cfsm}s after Brand and Zafiropulo
    \begin{shaded}
    \begin{itemize}
        \item concurrenct \textsc{Fsm} ($\geq2$) + communication channels
        \item every \textsc{Fsm} represents a concurrent communicating process with a finite number of control states
        \item every communication channel is:
        \begin{enumerate}
            \item full duplex
            \item error-free
            \item has a first-in-first-out strategy
            \item has unbounded capacity
        \end{enumerate}
        {\tiny 1.-3. characterize a \emph{perfect full-duplex} channel}
        \item one pair of channels ($c_{ij}$ and $c_{ji}$) for each pair $(i,j)$ of machines
    \end{itemize}
    \begin{center}
    \scalebox{1}{\input{images/cfsm.tikz}}
    \end{center}
    \item formalisation:
    \begin{tabular}{ll}
    $N$ : & a positive integer \\
    $i,j=1,\dots N$: & index over processes \\
    $\langle Q_i\rangle^N_{i=1}$: & $N$ disjoint, finite sets, $Q_i$ denots the state set of process $I$ \\
    $\langle A_{ij}^N\rangle_{i,j=1}$: &
        \begin{minipage}[t]{10cm}
        $N^2$ disjoint sets, with $(\forall i)(A_{ii}=\varnothing)$ $A_{ij}$ denotes the message alphabet for the channel $i\to j$ \end{minipage}\\
    $\delta$: &
    \begin{minipage}[t]{10cm}
        relation, determining, for each pair $i,j$ the following function:
        \begin{itemize}
            \item $Q_i\times A_{ij}\to Q_i$
            \item $Q_i\times A_{ji}\to Q_i$
        \end{itemize}\end{minipage} \\
        $\langle q_i^0\rangle$: & tupel of initial states, $(\forall i)(q_i^0\in Q_i)$
    \end{tabular}
    \item we call $\left( \langle Q_i\rangle, \langle q_i^0 \rangle, \langle A_{ij} \rangle, \delta \right)$ a \emph{protocol}
    \item Notation:
    \begin{tabular}{ll}
    $s_i\in Q_i:$ & state of process $i$ \\
    $x_{ij}\in A_{ij}:$ &
        \begin{minipage}[t]{10cm}
        a message
        \begin{itemize}
            \item $?x_{ij}$ reception of a message
            \item $!y_{ji}$ sending of a message
        \end{itemize}
        \end{minipage} \\
        & $f((s_i,\dots,s_n))=(f(s_i),\dots,f(s_n))$ \\
        $x,y$: & message \\
        $X,Y$: & sequence of messages \\
        $x, xy, xY, xXY$: & concatenated sequences of messages
    \end{tabular}
    \end{shaded}
\end{itemize}

\subsubsection*{Formal Semantics for a Promela-like}
\begin{description}
    \item[Semantics] of a protocol: set of admissable state sequences
    \item[State] of a protocol?
    \begin{itemize}
        \item sum of
        \begin{itemize}
            \item local state of each of the $1\dots N$ processes
            \item state of all channels $c_{ij}\in A_{ij}^*$ \\
            each $c_{ij}$ corresponds to a sequence of messages that have been sent, but not yet received
        \end{itemize}
        \item we call this the \emph{global system state}
    \end{itemize}
\end{description}
\begin{itemize}
    \item obtain set of all computations of a protocol:
    \begin{itemize}
        \item initially: all processes in $q_i^0$ and all $c_ij=\varnothing$
        \item system is in current state $s$
        \item state transition triggered by \emph{send} and \emph{receive} events
        \begin{description}
            \item[send event:]
            \begin{itemize}
                \item add a message to the tail of the corresponding message queue
                \item change local system state of sending process
            \end{itemize}
            \item[receive event:]
            \begin{itemize}
                \item take the message to be received from the head of the message queue
                \item change local system state of receiving process
            \end{itemize}
        \end{description}
        \item leads into new global system state $s'$
    \end{itemize}
    \item Global System State
    \begin{itemize}
        \item $P=\left(\langle Q_i\rangle,\langle q_o^0 \rangle, \langle A_ij \rangle,\delta \right)$ a protocol
        \item $S=(S_1,\dots,S_N)$ an $N$-tuple of local process states
        \item $C$ an $N^2$ tuple \\
        \[C= \left(
        \begin{array}{cccc}
         & c_1 & \cdots & c_N \\
         c_1 & \epsilon & & \\
         \vdots & & \ddots & \\
         c_N & & & \epsilon
        \end{array}
        \right)
        \] so that for all $i,j:c_{ij}\in A_{ij}^*$
        \item we call $(S,C)$ a \emph{global system state}
        \item \textbf{State Transition Relation} let $P$ a protocol and $G=\{(S,C) | (S,C) \textrm{ is a global system state}\}$
    \\
    $\vdash: \; G \to G$ is defined as follows \\
    $(S,C) \vdash (S',C') \; iff \; \exists\; i,k,x_{ik}$ such that either
    \begin{enumerate}
        \item $(S,C)$ and $(S',C')$ are identical except for the following exceptions
        \[ s_i'=\delta(s_i.!x_{ik}) \textrm{ (\blue{sending by i})} \]
        \[ \blue{c'_{ik} =c_{ik}x_{ik} } \]
        \item $(S,C)$ and $(S',C')$ are identical except for the following exceptions
        \[ s'_k = \delta(s_k,?x_{ik}) \textrm{ (\dGreen{receiving by k}) } \]
        \[\dGreen{c_{ik} = x_{ik}c'_{ik}} \]
    \end{enumerate}
    \item Reachable Global System State, Paths and Acceptance
    \begin{itemize}
        \item $G^0$ the initial global system state of a protocol
        \item $G$ a global system state of the same protocol
        \item $\vdash$ the state transition relation of this same protocol
        \item $\vdash^*$ denotes the transitive closure of $\vdash$
    \end{itemize}
    \item we say that $G$ is rechable if \[ G^0 \vdash^* G \]
    \end{itemize}
    \item When is a Problem $P$ decidable? \\
    There exists an algorithm which terminates after a finite number of steps whether $P=\varnothing$ or not.
    \item What is a Turing machine? {\tiny you should know \dots}
    \item Example of an undecidable problem?
    \\ There is no TM that will decide whether an arbitrary given TM will halt or not.
    \item When is a formalism Turing-complete?
    \\ When you can simulate a TM in this formalism.
    \item \textsc{Cfsm} are Turing-complete
    \begin{itemize}
        \item three processes: $P_1,P_2,P_3$
        \item simulate the control of the TM in the state machine of $P_2$
        \item use $P_1$ and the channels $c_{21}$ and $c_{c12}$ to simulate the left half tape, use $P_3$ and $c_{23}$ and $c_{32}$ to simulate the right half tape
        \item note: all $c_{ik}$ have unbounded length
        \\ \follows infinite state space (globally)
        \\ \follows undecidable problems:
        \begin{itemize}
            \item termination
            \item will some communication event ever be executed?
            \item is some system state reachable
            \item is the protocol deadlock-free?
        \end{itemize}
        \item a channel $c_{ij}$ is \emph{bounded} if, for every reachable global system state $(C,S)$, the length of $c_ik$ is bounded by a constant $h$
        \\ with bounded channels above problems are decidable, however deadlocks may be introduced due to bounded chans.
    \end{itemize}
\end{itemize}

\subsubsection*{Extended Finite State Machines (EFSM)}
An \textsc{Efsm} is a \textsc{Fsm} extended by
\begin{itemize}
    \item data abstraction
    \item operations on variables
    \item symbolic (explicit states)
    \item boolean transition conditions
\end{itemize}
A (symbolic) state of an \textsc{Efsm} represents an \emph{equivalence class} of system states.

\begin{shaded}
    we call $E=(S,D,V,O,I,T,C)$ an extended finite state machine \textsc{Efsm}, where
    \begin{tabular}{ll}
    $S$: & set of symbolic states \\
    $D$: & $n$-dimensional linear space, each $D_i$ is an (infinite) data domain \\
    $V$ &
    \begin{minipage}[t]{10cm}
    $=\{\Pi,v_1,\dots,v_n\}:$ finite set of programme variables
    \begin{itemize}
        \item $\Pi$: control variable over domain $S$
        \item $\{v_1,\dots,v_2\}\in D$: data variables
    \end{itemize}
    \end{minipage} \\
    $O$: & finite set of output signal types \\
    $I$: & finite set of input signal types \\
    $T$: & $S\times 2^D\times I \to S\times 2^D\times O$ \\
    $C$: & an initial condition over $S\times 2^D$
    \end{tabular}
\end{shaded}

\subsubsection*{Communicating Extended Finite State Machines}
\begin{itemize}
    \item foundation for many practical specifications and modeling languages
    \begin{itemize}
        \item Specification and Description Language \textsc{Sdl} (now part of \textsc{Uml})
        \item Estelle (\textsc{Iso})
        \item \textsc{Room/Uml-Rt}
        \item \textsc{Uml-Rt}
        \item \textsc{SysMl}
    \end{itemize}
\end{itemize}

\subsection*{State Explosion Problem}
\begin{itemize}
    \item Size of Transition System
    \begin{itemize}
        \item size of $TS = |S|+|\to|$
        \begin{itemize}
            \item dependend on
            \begin{itemize}
                \item use of data (variables) (exponentially larger)
                \item use of concurrent composition
                \item use of communication channels
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \begin{itemize}
        \item Program Graphs
        \begin{itemize}
            \item number of states of $ TS(PG)=|\# programm\;locations|\cdot \prod\limits_{variable\; x} |dom(x)|$
            \item growth of $TS(PG)$
            \begin{itemize}
                \item assume $N$ variables, each with $k=|dom(x)|$ possible values
                \\ \follows $k^N$ states {\tiny exponential growth}
                \item Programm with 10 locations, 3 boolean variables, 5 integer variables ranging $1-10$
                \\ $10\times 2^3\times 10^5=8\,000\,000=8\times 10^6$ states
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \item Concurrent Composition of Transition Systems
    \begin{itemize}
        \item derived form concurrent programs
        \item size:
        \begin{itemize}
            \item Cartesian product of state spaces of componens $TS$s, i.e. $\#states\ of \ P_1\times \dots \times \#states\ of \ P_2$
            \item assume $N$ components of size $k$ each \follows size of $TS=k^N$
        \end{itemize}
    \end{itemize}
    \item Channel Systems:
    \begin{itemize}
        \item assynchronous communication channels $c$ with capacity $cap(c)$
        \item assume $K$ components and $N$ channels
        \\ \follows worst case size: $\displaystyle \prod^N_{i=1} \left(|\#programm\ locations| \prod_{variable\ x} |dom(x)|\right)\cdot\prod^K_{j=1}|dom(c_j)^{cap(c_j)}$
    \end{itemize}
\end{itemize}

\section*{Linear-Time Properties and Invariants}
\begin{description}
    \item[Property:] A system execution (computation) will be modeled as a \emph{sequence of states or events}.
    \begin{itemize}
        \item $\sigma_0 = <g,a,z,g,\dots>$
        \item $\sigma_1 = <g,a,d,g,\dots>$
    \end{itemize}
    \begin{shaded}
        A (model of the system/system/program) P has the property $\Pi$ if all its computations are in $\Pi$.
    \end{shaded}
    \item[Property Representation:] too cumbersome to enumerate all infinite computations \follows use mathematical formalisms:
    \begin{itemize}
        \item $\omega$-automata (property corresponds to accepted language)
        \item $\omega$-regular expressions
        \item temporal logic
    \end{itemize}
\end{description}

\subsection*{State Graph}
\begin{shaded}
\begin{itemize}
    \item The \emph{state graph} of $TS$ ($G(TS)$, is the digraph $(V,E)$ with vertices $V=S$ and edges $E=\{(s,s')\in S\times S | s'\in Post(s)\}$ \follows omit all state and transition labels in $TS$ and ignore being inital
    \item $Post^*(s)$ is the set of reachable states $G(TS)$ from $s$:
    \[ Post^*(C)=\bigcup_{s\in C}Post^*(s) \textrm{ for } C \subseteq S \]
    \item $Pre^*(C)$ has analogous meaning
    \item set of reachable states: $Reach(TS)=Post^*(I)$
\end{itemize}
\end{shaded}

\subsection*{Path Fragment}
\begin{shaded}
    \begin{itemize}
        \item A \emph{path fragment} is an execution fragment without actions
        \item A \emph{finite path fragment} $\hat{\pi}$ of $TS$ is a state sequence:
        \[ \hat{\pi} = s_0s_1\dots s_n \textrm{ such that } s_{i+1}\in Post(s_i) \textrm{ for all } 0 \leq i<n \textrm{ where } n\geq0 \]
        \item An \emph{infinite path fragment} $\pi$ of $TS$ is an infinite state sequence:
        \[ \pi=s_0s_1\dots \textrm{ such that } s_{i+1}\in Post(s_i) \textrm{ for all } i\geq0 \]
        \item A \emph{path} of $TS$ is an initial, maximal path fragment
        \begin{itemize}
            \item a \emph{maximal} path fragment is either finite ending in a terminal state or infinite
            \item a path fragment ist \emph{initial} if $s_0\in I$
            \item $Paths(s)$ is the set of maximal path fragments $\pi$ with $first(\pi)=s$
        \end{itemize}
    \end{itemize}
\end{shaded}
\begin{center}
\scalebox{1}{\input{images/semaphore.tikz}}
\end{center}


\subsection*{Traces}
\begin{shaded}
    \begin{itemize}
        \item Let $TS=(S,Act,\to,I,AP,L)$ without terminal states {\tiny all maximal paths (and executions) are infinite}
        \item The \emph{trace} of the infinite path fragment $\pi=s_0s_1\dots$ is $trace(\pi)=L(s_0)L(s_1)\dots$
        \item The \emph{trace} of the finite path fragment $\pi=s_0s_1\dots s_n$ is $(s_n)$
        \item The set of traces of a set $\Pi$ of pahts: $trace(\Pi)=\{ trace(\pi) | \pi\in\Pi \}$
        \item %\hspace*{-2em}
        \begin{align*}
        Traces(s)&=trace(Paths(s)) & Traces(TS)&=\bigcup_{s\in I} Traces(s) \\
        Traces_{fin}(s)&=trace(Paths_{fin}(s)) & Traces_{fin}(TS)&=\bigcup_{s\in I} Traces_{fin}(s)
        \end{align*}
    \end{itemize}
\end{shaded}
\paragraph*{Example}
$AP=\{ crit_1,crit_2 \}$
\begin{align*}
\textrm{path:} & & %\qquad
\pi = &
    \langle n_1,n_2,y=1 \rangle \to
    \langle w_1,n_2,y=1 \rangle \to
    \langle c_1,n_2,y=0 \rangle \to \\
    & & &
    \langle n_1,n_2,y=1 \rangle \to
    \langle n_1,2_2,y=1 \rangle \to
    \langle n_1,c_2,y=0 \rangle \to \dots \\
\textrm{trace:} & & % \qquad
trace(\pi) = &
    \varnothing\varnothing \{crit_1\}\varnothing\varnothing\{crit_2\}\varnothing\varnothing \{crit_1\}\varnothing\varnothing\{crit_2\}\dots
\end{align*}

\subsubsection*{Linear Time Properties for Transition Systems}
\begin{shaded}
    \begin{itemize}
        \item for a given $TS$ a linear time property $\Pi$ over $AP$ is a subset of the set of all infinite strings formed over subset of $AP$: $\Pi\subseteq(2^{AP})^\omega$
        \item $\Pi$ specifies the set of all admissible observable behaviour of the system
        \item satisfaction: $TS\models S \textrm{ iff } Traces(TS) \subseteq \Pi$
        \item notation: state $s\in S$ satisfies $\Pi$, written as $s\models \Pi$, iff $Traces(s)\subseteq\Pi$
    \end{itemize}
\end{shaded}

\subsubsection*{Trace Equivalence}
\begin{itemize}
    \item Let $TS$ and $TS'$ be two transition systems over $AP$ without terminal state
    \begin{description}
        \item[trace inclusion] $Traces(TS\red\subseteq Traces(TS')$ iff for \red{any} $LT$ property $P:\;TS\models P \textrm{ \red{implies} } TS'\models P$
        \item[trace equivalence] $Traces(TS\red= Traces(TS')$ iff $TS$ and $TS'$ satisfy the \red{same} $LT$ properties
    \end{description}
    \item i.e. there is \emph{no LT property} that can distinguish between $TS$ and $TS'$ \follows $TS$ and $TS'$ are trace equivalent
\end{itemize}

\subsubsection*{Invariant $LT$ properties}
\begin{itemize}
    \item Properties over $AP$ that hold for all rechable states, including the initial state (e.g. mutual exclusion, deadlock freedom)
    \item
    \begin{shaded}
        An $LT$ property $P_{inv}$ over $AP$ is called an \emph{invariant} if there is a propositional formula $\psi$ over $AP$ such that
        \[ P_{inv} = \{ A_0,A_1,\dots\in (2^{AP})^\omega | (\forall j\geq0)(A_j\models\psi) \} \]
        $\psi$ is then referred to as the \emph{invariant condition} for invariant $P_{inv}$
    \end{shaded}
    \begin{tabular}[t]{ll}
    $TS\models P_{inv}$ & \\
    & iff $trace(\pi)\in P_{inv}\forall \; \pi \; in \; TS$ \\
    & iff $L(s)\models\psi\forall$ states $s$ that belong to a path of $TS$ \\
    & iff $L(s)\models\psi\forall$ states $s\in Reach(TS)$
    \end{tabular}
    \item Model Checking Invariants
    \begin{itemize}
        \item perform systematic forward search
        \begin{description}
            \item[depth first search] \textsc{Dfs}
            \item[breadth first search] \textsc{Bfs}
        \end{description}
        \item alternative: backwards search
        \begin{itemize}
            \item compute all states violating invariant condition $\psi$
            \item starting here, compute $Pre=\bigcup_{S\in\mathcal{S},S\not\models\psi}Pre^*(s)$
            \item Check if $Pre$ contains an initial state
        \end{itemize}
        \item Time complexity of \textsc{Dfs}: $\mathcal{O}(N\times(|\Phi|+1)+M)$
        \begin{itemize}
            \item $N$: number of reachable states
            \item $(|\Phi|+1)$ length of formula
            \item $M=\sum_{s\in\mathcal{S}}|Post(s):$ number of transitions in the reachable part of $TS$
        \end{itemize}
        \follows time complexity of \textsc{Dfs} is linear
    \end{itemize}
    \item Computation and representation of successor states:
    \begin{description}
        \item[explicit state model checking]
        \begin{itemize}
            \item successor states are implicitly given (program graph, Promela code, \dots)
            \item $Post(s)$ is typically stored as adjacency list
            \item successor states are explicitly computet (state vectors)
        \end{itemize}
        \item[symbolic model checking]
        \begin{itemize}
            \item $Post(s)$ is represented symbolically (binary decision diagrams (BDD))
            \item reachability computation is fixed point computation
        \end{itemize}
    \end{description}
\end{itemize}

\section*{Safety and Liveness}
According to Leslie Lamport
\begin{description}
    \item[safety:] something bad will never happen
    \item[liveness:] something good will eventually happen
\end{description}
\begin{itemize}
    \item Property $P$ corresponds to a language
    \begin{itemize}
        \item $P\subseteq (2^{AP})^*:$ the property is finitary
        \item $P\subseteq (2^{AP})^\omega:$ the property is infinitary
    \end{itemize}
    \item often convenient to express property by $\omega$-regular expressions
\end{itemize}

\subsection*{Safety Properties}
\begin{shaded}
    \begin{itemize}
        \item An LT property $P_{safe}$ is a \emph{safety property}, iff $\forall\sigma\in(2^{AP})^\omega\setminus P_{safe}$ there exists a finite prefix $\hat\sigma$ of $\sigma$ such that $P_{safe}\cap\{ \sigma'\in(2^{AP})^\omega | \hat\sigma \textrm{ is a prefix of } \sigma' \}=\varnothing$ \\{\tiny If we violate the safety property, there is no way to fix it. OR: Violation can be confirmed by a finite prefix.}
        \item $\hat\sigma$ is called a \emph{bad prefix} of $P_{safe}$, and we let $BadPref(P_{safe})$ denote the set of all bad prefixes of $P_{safe}$.
        \item $\hat\sigma$ is a \emph{minimal bad prefix} for $P_{safe}$ iff $\hat\sigma\in BadPref(P_{safe})$ and no proper prefix of $\hat\sigma$ is in $BadPref(P_{safe})$.
        \item Any invariant is a safety property. There are safety properties, that are not invariants.
        \item For a transition system $TS$ without final states and safety property $P_{safe}$ the following holds: \[ TS\models P_{safe} \textrm{ iff } Traces_{fin}(TS)\cap BadPref(P_{safe})=\varnothing \]
        \item The \emph{closure} of an $LT$ property $P$ is defined as: \[ closure(P)=\{ \sigma\in(2^{AP})^\omega | pref(\sigma) \subseteq pref(P) \} \]
        {\tiny This denotes the set of all infinite traces whose finite prefixes are also prefixes of $P$ Example: $closure(a^+b^\omega)=a^\omega+a^+b^\omega$}
        \item $P$ is a safety property iff $closure(P)=P$
    \end{itemize}
\end{shaded}
\begin{itemize}
    \item Finite traces and safety properties:
    \begin{itemize}
        \item $Traces_{fin}(TS)\subseteq Traces_{fin}(TS') \textrm{ iff for any safety property } P_{safe}:\ TS'\models P_{safe} \Rightarrow TS \models P_{safe}$
        \item $Traces_{fin}(TS)\subseteq Traces_{fin}(TS')$ iff $TS$ and $TS'$ satisfy the same set of safety properties
        \item for $TS$ without terminals states and finite $TS'$ the following holds: \[ Traces(TS) \subseteq Traces(TS') \iff Traces_{fin}(TS) \subseteq Traces_{fin}(TS') \]
        \item trace inclusion $\not=$ finite trace inclusion
    \end{itemize}
\end{itemize}

\subsection*{Liveness Properties}
Safety properties can be satisfied by never doing anything. \follows We want some property that ensures something will happen eventually.
\begin{shaded}
    An $LT$ property $P_{live}$ over $AP$ is a \emph{liveness} property whenever $pref(P_{live})=(2^{AP})^*$ \\
    {\tiny \follows Any finite computation can be extended to an execution satisfying the property.}
\end{shaded}

\subsection*{Safety and Liveness component}
Many properties are not pure, but a combination of safety and liveness properties.
\begin{itemize}
    \item let $S$ denote an atomic predicate that holds in a ``sent'' state, and let $R$ denote an atomic predicate that holds in a ``received'' state.
    \item let $S,R\in \Sigma$\qquad {\tiny $\Sigma$ is the alphabet}
    \item Property: when a message has been ``sent'' eventually it will be ``received'': \[ \Pi=S^*R\Sigma^\omega \]
    \item \begin{align*}
    \Pi & \not= closure(\Pi) \\
    &= S^\omega\cup S^*R\sigma^\omega \\
    &= \Pi_s
    \end{align*}
    We call $\Pi_s$ the \emph{safety closure} of $\Pi$
    \item decomposition into safety and liveness property:
    \begin{description}
        \item[liveness:] $\Pi_l$ eventually $R$ will hold: $\Pi_l=\Sigma^* R\Sigma^\omega$
        \item[safety:] $\Pi_s = closure(\Pi)$
        \item[will hold:] $\Pi=\Pi_s\cap\Pi_l=(S^\omega\cup S^*R\Sigma^\omega)\cap(\Sigma^* R \Sigma^\omega)$
    \end{description}
    \item Safety and Liveness properties are \emph{disjoint} except for the trivial property $\Sigma^\omega$
    \item Every property $\Pi$ can be represented as the \emph{intersection}: $\Pi=\Pi_s\cap\Pi_l$
    \item let $\Pi$ be a infinitary and $\Phi$ be an finitary property
    \begin{itemize}
        \item $PREF(\Pi)$ denotes the set of all finite prefixes of $\Pi$
        \item $A(\Phi)$ corresponds to all infinite $\sigma\in\Sigma^\omega$ so that all finite prefixes of $\sigma$ are in $\Phi$ \[ \textrm{Example: } \Phi=a^+b^*\Rightarrow \underset{(closure)}{A(\Phi)}=a^\omega+a^+b^\omega \]
        \item $E(\Phi)$ consists of all infinite $\sigma\in\Sigma^\omega$ so that there exists a prefix of $\sigma$ that belongs to $\Phi$ \[ \textrm{Example: } \Phi=a^+b^*\Rightarrow E(\Phi)=a^+b^*\cdot \Sigma^\omega \] \\
        \vspace*{-4em} {\tiny Note: for every finite property $\Phi: E(\Phi)=\Phi\cdot\Sigma^\omega$}
    \end{itemize}
    \item Other Classifications:
    \begin{itemize}
        \item topological \follows safety (closed sets), liveness (dense sets)
        \item temporal logic
        \item automata theoretic
    \end{itemize}
    \item Safety/Liveness is intuitive:
    \begin{itemize}
        \item checking safety properties: simple exploration of all states
        \item checking liveness property: exploration of all states, checking in every state whether any continuation of prefix will satisfy property
    \end{itemize}
\end{itemize}

\section*{Fairness}
Fairness ensures, that each process wanting to do something at one point will eventually be able to do so.
\paragraph*{Types of Fairness}
\begin{description}
    \item[unconditional fairness:] an activity is executed \emph{infinitely often}
    \item[strong fairness:] if an activity is \emph{infinitely often enabled}, it will \emph{infinitely often be executed}
    \item[weak fairness] if an activity is \emph{continuously enabled}, it will \emph{infinitely often be executed}
\end{description}
\begin{itemize}
    \item Fairness violations often occur due to an unjustifiedly high level of abstraction (e.g. one process indefinitely faster than other)
    \item or due to unjustified assumptions about environment behaviour
\end{itemize}
\begin{shaded}
    For $TS=(S,Act,\to,I,AP,L)$ without terminal states, $A\subseteq Act$, and infinite execution fragment $\rho=s_0\overset{\alpha_0}{\longrightarrow}s_1\overset{\alpha_1}{\longrightarrow}\dots$ of $TS$ {\tiny where $Act(s) = \left\{ \alpha\in Act | \exists s' \in S. s\overset{\alpha}{\longrightarrow}s'\right\}$}
    \begin{enumerate}
        \item $\rho$ is \emph{unconditionally $A$-fair} whenever: $true\Rightarrow \underset{\textrm{infinitely often } A\textrm{ is taken}}{\underbrace{\forall k\geq0.\exists j\geq k.\alpha_j\in A}}$
        \item $\rho$ is \emph{strongly $A$-fair} whenever: $\underset{\textrm{infinitely often } A\textrm{ is enabled}}{\underbrace{(\forall k\geq0.\exists j\geq k.Act(s_j)\cap A\not=\varnothing)}}\Rightarrow \underset{\textrm{infinitely often } A\textrm{ is taken}}{\underbrace{\forall k\geq0.\exists j\geq k.\alpha_j\in A}}$
        \item $\rho$ is \emph{weakly $A$-fair} whenever: $\underset{\textrm{infinitely often } A\textrm{ is enabled}}{\underbrace{(\exists k\geq0.\forall j\geq k.Act(s_j)\cap A\not=\varnothing)}}\Rightarrow \underset{\textrm{infinitely often } A\textrm{ is taken}}{\underbrace{\forall k\geq0.\exists j\geq k.\alpha_j\in A}}$
    \end{enumerate}
\end{shaded}

\subsection*{Which Fairness Notion to Use?}
Fairness filters out ``unreasonable'' runs (may be too strong, unfair)
\begin{itemize}
    \item Too Strong? \follows relevant computations may be ruled out, verification yields:
    \begin{description}
        \item[\red{false}:] error found
        \item[\dGreen{true}:] may still be false, if relevant executions may be considered ``unfair''
    \end{description}
    \item Too Weak? \follows too many computations considered, verification yields:
    \begin{description}
        \item[\dGreen{true}:] property holds
        \item[\red{false}:] may still be true, if violating run was unfair
    \end{description}
    \item Relationship: unconditional \follows strong \follows weak
\end{itemize}

\subsection*{Fairness Assumptions}
\begin{shaded}
    A \emph{fairness assumption} for $Act$ is a triple \[ \mathcal{F}=(\mathcal{F}_{uncond},\mathcal{F}_{strong},\mathcal{F}_{weak}) \] with $\mathcal{F}_{ucond},\mathcal{F}_{strong},\mathcal{F}_{weak}\subseteq 2^{Act}$
    \begin{itemize}
        \item unconditionally $A$-fair \emph{for all} $A\in\mathcal{F}_{ucond}$
        \item stongly $A$-fair \emph{for all} $A\in\mathcal{F}_{strong}$
        \item weakyl $A$-fair \emph{for all} $A\in\mathcal{F}_{weak}$
    \end{itemize}
    e.g. $(\varnothing,\mathcal{F}',\varnothing)$ denotes strong fairness
\end{shaded}
\begin{itemize}
    \item A Path $s_o\to s_1\to s_2\to\dots$ is $\mathcal{F}$-fair, if
    \begin{itemize}
        \item there exists an $\mathcal{F}$-fair execution $s_0\overset{\alpha_0}{\longrightarrow}s_1\overset{\alpha_1}{\longrightarrow}\dots$
        \item $FairPaths_\mathcal{F}(s)$ denotes the set of $\mathcal{F}$-fair paths that start in $s$
        \item $FairPaths\mathcal{F}(TS)=\bigcup_{s\in I} FairPaths\mathcal{F}(s)$
    \end{itemize}
    \item Trace $\sigma$ is $\mathcal{F}$-fair if there exists an $\mathcal{F}$-fair execution $\rho$ with $trace(\rho)=\sigma$
    \begin{itemize}
        \item $FairTraces_\mathcal{F}(s)=trace(FairPaths_\mathcal{F}(s))$
        \item $FairTraces_\mathcal{F}(TS)=trace(FairPaths_\mathcal{F}(TS))$
    \end{itemize}
    \item $TS$ \emph{satisfies} $LT$-property $P$: \[ TS\models P \textrm{ iff } Traces(TS)\subseteq P \]
    \item $TS$ \emph{fairly satisfies} $LT$-property $P$ wrt. fairness assumption $\mathcal{F}$: \[ TS\models_\mathcal{F} P \textrm{ iff } FairTraces_\mathcal{F}(TS)\subseteq P \]
\end{itemize}

\subsection*{Fairness and Safety}
\begin{itemize}
    \item for $TS$ with set of Actions $Act$ and fairness assumption $\mathcal{F}$ for $Act$, $\mathcal{F}$ is defined as \emph{realizable} for $TS$ if for any $s\in Reach(TS):$ \[ FairPaths_\mathcal{F}(s)\not=\varnothing \]
    \item for $TS$ and safety property $P_{safe}$ over $AP$ and $\mathcal{F}$ a realizable fairness assumption for $TS$ the following holds true: \[ TS\models P_{safe} \textrm{ iff } TS\models_\mathcal{F}P_{safe} \] {\tiny i.e. safety properties are preserved by realizable fairness assumption, non-realizable fairness assumptions may harm safety properties}
\end{itemize}

\section*{Model Checking Regular Safety Properties}
\begin{shaded}
A safety property $P_{safe}$ is \emph{regular} if
\begin{itemize}
    \item $BadPref(P_{safe})$ is a regular language.
    \item there exists a finite automaton over $2^{AP}$ recognizing $BadPref(P_{safe})$
\end{itemize}
\end{shaded}
\begin{itemize}
    \item $bp(P_{safe} \equiv BadPref(P_{safe})$
    \item $mbp(P_{safe})$ \follows set of minimal bad prefixes for $P_{safe}$
    \item not regular safety properties: something to do with counting
\end{itemize}

\subsection*{Regular Languages}
\begin{shaded}
    A \emph{nondeterministic finite automaton} \textsc{Nfa} $\mathcal{A}$ is a tuple $(Q,\Sigma,\delta,Q_0,F)$ where
    \begin{itemize}
        \item $Q$ is a finite set of states
        \item $\Sigma$ is an alphabet
        \item $\delta:\ Q\times\Sigma\to2^Q$ is a transition function (nondeterministic)
        \item $Q_0\subseteq Q$ a set of initial states
        \item $F\subseteq Q$ is a set of accept (or: final) states
    \end{itemize}
    assume word $w=A_1\dots A_n\in\Sigma^*$
    \begin{itemize}
        \item A \emph{run} for $w$ in $\mathcal{A}$ is a finite sequence $q_0q_1\dots q_n$ such that:
        \[ q_0\in Q_0 \textrm{ and } q_1\overset{A_{i+1}}{\longrightarrow} q_{i+q} \textrm{ for all } 0\leq i < n \]
        \item Run $q_0q_1\dots q_n$ is \emph{accepting} if $q_n\in F$
        \item $w\in\Sigma^*$ is \emph{accepted} by $\mathcal{A}$ if there exists an accepting run for $w$.
        \item The \emph{accepted language} of $\mathcal{A}$: \[ \mathcal{L}(\mathcal{A})=\{ w\in\Sigma^* | \textrm{ there exists an accepting run for } w \textrm{ in } \mathcal{A} \} \]
        \item \textsc{Nfa} $\mathcal{A}$ and $\mathcal{A}'$ are \emph{equivalent} if $\mathcal{L}(\mathcal{A})=\mathcal{L}(\mathcal{A}')$
    \end{itemize}
\end{shaded}

\subsection*{Synchronous Product}
\begin{shaded}
\begin{multicols}{2}
For transition system $TS=(S,Act,\to,I,AP,L)$ without terminal states and $\mathcal{A}=(Q,\Sigma,\delta,Q_0,F)$ and \textsc{Nfa} with $\Sigma=2^{AP}$ and $Q_0\cap F=\varnothing$, let:
    \[ TS \otimes\mathcal{A}=(S',Act,\to',I',AP',L') \]
    where
    \begin{itemize}
        \item $S'=S\times Q$, $AP'=Q$ and $L'(\langle s,q \rangle) = \{ q \}$
        \item $\to'$ is the smallest relation defined by
        $\displaystyle \frac{
            s\overset{\alpha}{\longrightarrow}\red{t} \wedge q \overset{L(\red{t})}{\longrightarrow} p
        }{
        \langle s,q \rangle \overset{\alpha}{\longrightarrow}' \langle \red{t},p \rangle
        }$
        \item $I'=\{ \langle s_0,q \rangle | s_0\in I\wedge \exists q_0\in Q_0. q_0 \overset{L(s_0)}{\longrightarrow} q\}$
    \end{itemize}
    without loss of generality it may be assumed that $TS\otimes\mathcal{A} has no terminal states$
\columnbreak
\begin{center}
\scalebox{0.5}{\input{images/syncProd.tikz}}
\end{center}
\end{multicols}
\end{shaded}

\subsection*{Properties of \textsc{Nfa}}
\begin{itemize}
    \item They are as expressive as regular languages
    \item They are closed unter $\cap$ and \emph{complementation}
    \begin{itemize}
        \item \textsc{Nfa} $\mathcal{A}\otimes B$ (=cross product) accepts $\mathcal{L}(\mathcal{A})\cap\mathcal{L}(\mathcal{B})$
        \item Total \textsc{Dfa} $\overline{\mathcal{A}}$ (=swap all accept and normal states) accepts $\overline{\mathcal{L}(\mathcal{A})}=\Sigma^*\setminus\mathcal{L}(\mathcal{A})$
    \end{itemize}
    \item They are closed under \emph{determinization} (=removal of choice) {\tiny (although exponentially more runtime)}
    \item $\mathcal{L}(\mathcal{A}=\varnothing$ \follows check for a reachable accept state in $\mathcal{A}$ \follows simple \textsc{Dfs}
    \item For regular language $\mathcal{L}$ there is a unique minimal \textsc{Dfa} accepting $\mathcal{L}$
\end{itemize}

\subsection*{Model Checking regular safety properties}
\note{Check this with exercise sheet}

\begin{itemize}
    \item let $P_{safe}$ be a regular safety property over $AP$
    \item let $\mathcal{A}$ be an \textsc{Nfa} recognizing the bad prefixes of $P_{safe}$
    \begin{itemize}
        \item assume that $\varepsilon\not\in\mathcal{L}(\mathcal{A})$ (otherwise all finite words over $2^{AP}$ are bad prefixes and $P_{safe}=\varnothing$)
    \end{itemize}
    \item let $TS$ be a finite transition system over $AP$ without terminal states
    \item $TS\models P_{safe}$
    \begin{itemize}
        \item iff $Traces_{fin}(TS)\cap bp(P_{safe})=\varnothing$
        \item iff $Traces_{fin}(TS)\cap \mathcal{L}(\mathcal{A})=\varnothing$
        \item iff $TS\otimes\mathcal{A}\models $ ``always $\Phi$''
        \begin{itemize}
            \item invariant checking \follows  \textsc{Dfs}
        \end{itemize}
        \begin{shaded}
            The following statements are equivalent
            \begin{itemize}
                \item $TS\models P$
                \item $Traces_{fin}(TS)\cap\mathcal{L}(\mathcal{A})=\varnothing$
                \item $TS\otimes\mathcal{A} \models P_{inv(\mathcal{A})}=\bigwedge_{q\in F} \neg q$
            \end{itemize}
            \follows checking safety properties is like checking an invariant
        \end{shaded}
    \end{itemize}
\end{itemize}

\subsection*{Counterexample}
\begin{shaded}
    For each initial path fragment $\langle s_0,q_1\rangle\dots\langle s_n,q_{n+q}$ of $TS\otimes\mathcal{A}:$
    \[
    q_1,\dots q_n\not\in F \textrm{ and } q_{n+1}\in F \Rightarrow \underset{\textrm{bad prefix for } P_{safe}}{\underbrace{trace(s_0s_1\dots s_n)\in\mathcal{L(\mathcal{A})}}}
    \]
\end{shaded}

\begin{algorithm}[H]
 \SetAlgoLined
 \KwData{finite transition system $TS$ and regular safety property $P_{safe}$}
 \KwResult{true if $TS\models P_{safe}$. Otherwise false plus a counterexample for $P_{safe}$ }
 \eIf{$TS\otimes\mathcal{A}\models P_{inv(\mathcal{A})}$}{
 \Return{true}
 }{
 Determine initial path fragment $\langle s_0,q_1\rangle\dots\langle s_n,q_{n+1}\rangle$ of $TS\otimes\mathcal{A}$ with $q_{n+q}\in F$ \\
 \Return{(false, $s_0s_1\dots s_n$)}
 }
 \caption{Basic Model Checking algorithm}
\end{algorithm}

\subsection*{Time Complexity}
\begin{shaded}
    The time and space complexity of checking $TS\models P_{safe}$ is in:
    \[ \mathcal{O} (|TS|\cdot|\mathcal{A}|) \]
    where $\mathcal{A}$ is an \textsc{Nfa} with $\mathcal{L}(\mathcal{A}=mbp(P_{safe})$
\\ The \emph{size} of \textsc{Nfa} $\mathcal{A}$, denoted $|\mathcal{A}|$ is the number of states and transitions in $\mathcal{A}:$
\[ \underset{\textrm{rel. small}}{|\mathcal{A}|} = |Q| + \sum_{q\in Q} \sum_{A}\in\Sigma |\delta(q,A)| \]
\end{shaded}

\section*{Büchi Automata \& $\omega$-Regular Languages}
\begin{itemize}
    \item Properties of reacive systems contain liveness elements, need to be described with infinite sequences
    \item Need acceptance of languages of infinite words
\end{itemize}
\subsection*{Regular Expression}
\begin{shaded}
\begin{itemize}
    \item Let $\Sigma$ be an alphabet with $A\in\Sigma$
    \item Regular Expressions over $\Sigma$ have the \emph{syntax}:
    \[ E:=\varnothing \ | \ \varepsilon \ | \ A \ | \ E+E'\ | \ E.E'\ | \ E^* \]
    \item The \emph{semantics} of regular expression $E$ is a language $\mathcal{L}(E)\subseteq \Sigma^*$:
    \begin{align*}
    \mathcal{L}(\varnothing) = \varnothing, \; \mathcal{L}(\varepsilon)=\{\varepsilon\},\; \mathcal{L}(A)=\{A\} \\
    \mathcal{L}(E+E') = \mathcal{L}(E)\cup\mathcal{L}(E') \; \mathcal{L}(E.E')=\mathcal{L}(E).\mathcal{L}(E') \; \mathcal{L}(E^*)=\mathcal{L}(E)^*
    \end{align*}
\end{itemize}
\end{shaded}

\subsection*{$\omega$-Regular Expressions}
\begin{shaded}
\begin{itemize}
    \item denote languages of infinite words
    \item An $\omega$-regular expression $G$ over $\Sigma$ has the form
    \[ G=E_1.F_1^\omega + \dots + E_n.F_n^\omega \quad \textrm{for } n>0 \]
    where $E_i,F_1$ are regular expressions over $\Sigma$ with $\varepsilon \not\in\mathcal{L}(F_i)$
    \item The \emph{semantics} of $G$ is a language $\mathcal{L}(G)\subseteq\Sigma^\omega$:
    \[\mathcal{L}_\omega(G)=\mathcal{L}(E_1).\mathcal{L}(F_1)^\omega \cup\dots\cup \mathcal{L}(E_n).\mathcal{L}(F_n)^\omega \]
    \item $G_1$ and $G_2$ are \emph{equivalent}, denotet $G_1\equiv G_2$, if $\mathcal{L}_\omega(G_1)=\mathcal{L}_\omega(G_2)$
    \item $\mathcal{L}$ is $\omega$-regular if $\mathcal{L}=\mathcal{L}\omega(G)$ for some $\omega$-regular expression $G$.
    \item $\omega$-Regular languages are closed under $\cup,\cap$ and \emph{complementation}
\end{itemize}
\end{shaded}

\subsection*{$\omega$-Regular Properties}
\begin{shaded}
        An $LT$ property $P$ over $AP$ is \emph{$\omega$-regular} if $P$ is an $\omega$-regular language over the alphabet $2^{AP}$
\end{shaded}

\subsection*{Acceptance conditions for words inf $(2^{AP})^\omega$}
\begin{enumerate}
    \item finite acceptance {\tiny (the automaton accepts a prefix of $a\in(2^{AP})^\omega$), \red{does not ensure liveness, note even infiniteness}}
    \item looping acceptance {\tiny (the automaton has an infinite execution when reading the word) \red{does not ensure liveness, as the automaton may do anything}}
    \item repeating acceptance {\tiny (looping acceptance $+$ the set of states that the automaton reaches infinitely often an additional acceptance condition) \dGreen{also called ``Büchi acceptance condition''}}
\end{enumerate}

\subsection*{$\omega$-Automata}
\begin{itemize}
    \item Definition as for \textsc{Nfa}
    \item[+] Büchi acceptance condition: \emph{An infinite word $a\in(2^{AP})^\omega$ will be accepted by a Büchi Automaton iff the automaton reaches at least one of the states in the acceptance set $F$ infinitely often when reading $a$.}
\end{itemize}
\begin{shaded}
    A \emph{nondeterministic Büchi automaton} \textsc{Nba} $\mathcal{A}$ is a tuple $(Q,\Sigma,\delta,Q_0,F)$ where:
    \begin{itemize}
        \item $Q$ is a finite set of states with $Q_0\subseteq !$ a set of initial states
        \item $\Sigma$ is an alphabet
        \item $\delta:\ Q\times\Sigma\to2^Q$ is a transition function {\tiny (nondeterministic)}
        \item $F\subseteq Q$ is a set of accept (or final) states
    \end{itemize}
\end{shaded}
\subsubsection*{Language accepted by \textsc{Nba}}
\begin{itemize}
    \item \textsc{Nba} $\mathcal{A}=(Q,\Sigma,\delta,Q_0,F)$ and word $\sigma=A_0A_1A_2\dots\in\Sigma^\omega$
    \item A \emph{run} for $\sigma$ in $\mathcal{A}$ is an \emph{in}finite sequence $q_0q_1q_2\dots$ such that:
    \[ q_0\in Q_0 \textrm{ and }  \underset{\delta \textrm{ of the \textsc{Nba}}}{\underbrace{q_i \overset{A_{i+1}}{\longrightarrow} q_{i+1}}} \textrm{ for all } 0\leq i \]
    \item Run $q_0q_1q_2\dots$ is \emph{accepting} if $q_i\in F$ for \emph{infinitely} many $i$
    \item $\sigma\in\Sigma^\omega$ is \emph{accepted} by $\mathcal{A}$ if there exists an accepting run for $\sigma$
    \item The \emph{accepted language} of $\mathcal{A}$:
    \[ \mathcal{L}_\omega(\mathcal{A})=\{ \sigma\in\Sigma^\omega | \textrm{ there exists an accepting run for } \sigma \textrm{ in } \mathcal{A}\} \]
    \item \textsc{Nba} $\mathcal{A}$ and $\mathcal{A}'$ are \emph{equivalent} if $\mathcal{L}_\omega(\mathcal{A})=\mathcal{L}_\omega(\mathcal{A}') $
\end{itemize}
\subsubsection*{More facts about Büchi Automata}
\begin{itemize}
    \item assume: the final state will be repeatet infinitely often
    \item finite equivalence $\not\Rightarrow\;\omega$-quivalence
    \item $\omega$-equivalence $\not\Rightarrow$ finite equivalence
    \item The class of languages accepted by \textsc{Nba} is \emph{identical} to the class of $\omega$-regular languages
    \item A Büchi automaton is \emph{deterministic}, if $|Q_0|\leq 1$ and $|\delta(q,A)|\leq1$ for all $q\in Q$ and $A\in\Sigma$ \\
    \textsc{Nba} and \textsc{Dba} are note equally expressive \follows \textsc{Nba} are more expressive \follows need for nondeterminism
    \item There is no canonic representation for \textsc{Nba} \follows there is no minimal \textsc{Nba} for a given $\omega$-regular language
    \item alternative: ``Muller, Rabin and Streett automata'' with deterministic/nondeterministic variants \follows same expressivenes as \textsc{N/Dba}
    \item Generalized Nondeterministic Büchi Automaton \textsc{GNba}:
    \begin{itemize}
        \item acceptance condition expressed in terms of a set $\mathcal{F}$ consisting of sets $F_1,\dots,F_k$ with $F_i\subseteq Q$
        \item \textsc{GNba} accepts a word, if it visits all sets $F_i$ infinitely often
    \end{itemize}
\end{itemize}

\section*{Linear Temporal Logic \textsc{Ltl}}
\begin{itemize}
    \item Büchi automata use operational approach, want to have Logic for the description of temporal requirements
    \item first order logic quite complicated for this
    \item[\follows] need explicit quantification over state sequences
    \item modalities:
    \begin{tabular}[t]{rll}
    $Lp:$ & it is necessary, that $p$ & {\tiny for all visible worlds $p$}\\
    $Mp:$ & it is possible, that $p$ & {\tiny there exists a visible world with $p$}\\
    $\neg Lp:$ & it is not necessary, that $p$ & %{\tiny there does not need to be a visible world with $p$}
    \\
    $\neg Mp:$ & it is not possible, that $p$ & %{\tiny there may be a world, with $p$}
    \end{tabular}
    \item Formulae of Modal Logic:
    \begin{itemize}
        \item $p$ is a formula
        \item if $\Phi$ is a formula, then $\neg\Phi$ is a formula
        \item if $\Phi$ and $\rho$ are formulae, then $\Phi\wedge\rho, \Phi\supset\rho \textrm{ (\tiny implication)}, \Phi\equiv\rho, L\Phi, M\Phi$ are formulae
    \end{itemize}
    \item \begin{shaded}
        Let $\Pi$ a set of atomic propositions. Further let
        \begin{itemize}
            \item $W$ a set of worlds
            \item $R\subseteq W\times W$ a visibility relation on worlds
            \item $A: W\times\Pi\to \{true,false\}$ a truth value assignement
        \end{itemize}
        then we call $(W,R,A)$ a \emph{model} or \emph{Kripke-Structure}
    \end{shaded}
\end{itemize}
\subsection*{Model-theoretic Semantics of Modal Logic}
\begin{shaded}
    Let
    \begin{itemize}
        \item $M=(W,R,A)$ a Kripke-structure
        \item $\Pi$ a set of atomic propositions and $p\in\Pi$
        \item $w$ and $v\in w$
        \item $\Phi$ and $\rho$ formulae
    \end{itemize}
    then we define the relation $\models$ for $M$:
    \begin{align*}
    (M,w) & \models p               & iff \; A(w,p) & = true  \\
    (M,w) & \models \neg p          & iff \; A(w,p) & = false \\
    (M,w) & \models \Phi\wedge\rho  & iff \; (M,w)  & \models \Phi \textrm{ and } (M,w) \models \rho \\
    (M,w) & \models L\Phi           & iff \; (\forall v: (w,v) & \in R)((M,v)\models\Phi) \\
    (M,w) & \models M\Phi           & iff \; (\exists v:(w,v) & \in R)((M,v)\models\Phi)
    \end{align*}
    Further we define:
    \begin{align*}
    \Phi \vee \rho  & \cong \neg(\neg\Phi\wedge\neg\rho) \\
    \Phi\supset\rho & \cong \neg\Phi\vee\rho \\
    \Phi\equiv\rho  & \cong (\Phi\supset\rho)\wedge(\Phi\subset\rho) \\
    M\Phi           & \cong \neg L\neg\Phi
    \end{align*}
    Axiomatisation:
    \begin{multicols}{2}
    \begin{enumerate}
        \item $(\Phi\vee\Phi)\supset\Phi$
        \item $\rho\supset(\Phi\vee\rho)$
        \item $(\Phi\vee\rho)\supset(\rho\supset\Phi)$
        \item $(\Phi\supset\rho)\supset((\rho\vee\Phi)\supset(\sigma\vee\rho))$
        \item $L\Phi\supset\Phi$
        \item $L(\Phi\supset\rho)\supset(L\Phi\supset L\rho)$
        \item $L\Phi\supset LL\Phi$
        \item $M\Phi\supset LM\Phi$
    \end{enumerate}
    \end{multicols}
    We call a formula $\Phi$ a \emph{theorem} if it can be derived from the axioms, notation: $\vdash \Phi$
    \begin{enumerate}
        \item $\vdash\Phi$ and $\vdash(\Phi\supset\rho)$ imply $\vdash\rho$ (modus ponens)
        \item $\vdash\Phi$ implies $\vdash L\Phi$
    \end{enumerate}
\end{shaded}
\subsection*{Temporal Interpretation of Modal Logic}
\begin{itemize}
    \item worlds correspond to system states
    \item visibility relation corresponds to sequences of system states
    \begin{itemize}
        \item system sees its current state \follows reflexivity
        \item state $s_3$ follows $s_2$ and $s_2$ follows $s_1$, then $s_3$ follows $s_1$ \follows transitivity
    \end{itemize}
    \item linear time temporal logic \textsc{Ltl}:
    \begin{multicols}{2}
    \begin{itemize}
        \item reflexivity
        \item transitivity
        \item connectivity
        \item discreteness
    \end{itemize}
    \end{multicols}
\end{itemize}
\subsection*{satisfiability and Validity}
\begin{itemize}
    \item $p$ is \emph{state-satisfiable} if there is a state so that $s\models p$
    \item $p$ is \emph{state-valid} if $s\models p$ for all states $s$
\end{itemize}
\subsection*{Linear Temporal Logic \textsc{Ltl}}
$p,q$ are formulae, the folowing are fomulae:
\begin{itemize}
    \item $\circ p$ (next)
    \item $\diamond$ (eventually)
    \item $\square$ (always)
    \item $p \mathcal{U}q$ (until)
    \item $p \mathcal{W}q$ (unless/weak until) {\tiny either once $q$ or always $p$}
\end{itemize}
\subsubsection*{Satisfaction}
given a state sequence (model) $\sigma$ and formula $p$
\begin{itemize}
    \item $p$ \emph{holds at position $i$} of sequence $\sigma$ iff \[ (\sigma,i) \models p \] we write $\sigma\models p$
\end{itemize}
\subsubsection*{Validity}
a formula $p$ is \emph{valid}, iff \[ (\forall\sigma)(\sigma\models p) \] we write $\models p$
\subsubsection*{Finite Model Property}
\textsc{Ltl} has the finite model property, there are only $4$ distinct temporal modalities \\
$\square p, \diamond p, \square\diamond p, \diamond\square p$ \\
$\square\square\diamond p\equiv\square\diamond p, \square\diamond\square\diamond p\equiv\square\diamond p$
\subsection*{\textsc{Ltl}-example}
\begin{itemize}
    \item $\square(p\to\diamond q)\cong p\leadsto q$ ``response-property'', ``p leads-to q''
    \item ``between process A updating a value and process B reading the cache, the value must be flushed from A's cache''
    \[ \square((UpdateA\wedge\diamond ReadB)\to(\neg ReadB \mathcal{U}FlushA)) \]
\end{itemize}
\begin{multicols}{2}
\subsection*{Property Expansion}
\begin{itemize}
    \item $\square p \Leftrightarrow (p\wedge\circ\neg p)$
    \item $\diamond p\Leftrightarrow(p\vee\circ\diamond p)$
    \item $p \mathcal{U}q\Leftrightarrow(q\vee[p\wedge\circ(p \mathcal{U}q)])$
    \item $p \mathcal{W}q\Leftrightarrow(q\vee[p\vee\circ(p \mathcal{W})])$
\end{itemize}
\subsection*{Dualitites}
\begin{itemize}
    \item $\neg\square p \Leftrightarrow\diamond\neg p$
    \item $\neg\diamond p \Leftrightarrow\square\neg p$
    \item $\neg(p \mathcal{U}q)\Leftrightarrow(\neg q)\mathcal{W}(\neg p\wedge\neg q) $
    \item $\neg(p \mathcal{W} q)\Leftrightarrow(\neg q)\mathcal{U}(\neg p\wedge\neg q) $
    \item $\neg\circ p\Leftrightarrow \circ\neg p$
\end{itemize}
\subsubsection*{Strong and Weak Operators}
\begin{itemize}
    \item $p \mathcal{U}q\Leftrightarrow(p \mathcal{W} q \wedge\diamond q) $
    \item $p \mathcal{W}q\Leftrightarrow(p \mathcal{U} q \wedge\square q) $
    \item $p \mathcal{U}q\Rightarrow p \mathcal{W}q $
\end{itemize}
\subsubsection*{Indempotence}
Two-fold application yields result identical to single application:
\begin{itemize}
    \item $\square\square p \Leftrightarrow\square p$
    \item $\diamond\diamond p\Leftrightarrow\diamond p$
    \item $p \mathcal{U}(p \mathcal{U}q) \Leftrightarrow p \mathcal{U}q$
    \item $p \mathcal{W}(p \mathcal{W}q) \Leftrightarrow p \mathcal{W}q$
    \item $(p \mathcal{U}q)\mathcal{U}q \Leftrightarrow p \mathcal{U}q$
    \item $(p \mathcal{W}q)\mathcal{W}q \Leftrightarrow p \mathcal{W}q$
\end{itemize}
\subsubsection*{Absorption}
\begin{itemize}
    \item $\diamond\square\diamond p\Leftrightarrow \square\diamond p$
    \item $\square\diamond\square p\Leftrightarrow \diamond\square p$
\end{itemize}
Absorption and Indempotence also lead to only $4$ different unary modalities (compare finite-model property):
\[ \square p,\diamond p,\square\diamond p,\diamond\square p \]
\subsubsection{Commutativity of the next-operator}%$\circ$}
\begin{itemize}
    \item $\circ(\neg p)\Leftrightarrow\neg\circ p$
    \item $\circ(p\vee q)\Leftrightarrow\circ p\vee\circ q$
    \item $\circ(p \mathcal{W}q)\Leftrightarrow\circ p \mathcal{W}\circ q$
\end{itemize}
\subsection*{Distribution of Temporal Operators}
\begin{itemize}
    \item $\square(p\wedge q)\Leftrightarrow\square p\wedge\square q$
    \item $\diamond(p\vee q)\Leftrightarrow\diamond p\vee \diamond q$
    \item $\square\diamond(p\vee q)\Leftrightarrow\square\diamond p\vee\square\diamond q$
    \item $\diamond\square(p\wedge q)\Leftrightarrow\diamond\square p\wedge\diamond\square q$
\end{itemize}
\subsection*{Possible Base set of Operators}
$\circ, \mathcal{W}\neg$, derived operators:
\begin{itemize}
    \item $\square p = p \mathcal{W} false$
    \item $\diamond p=\neg\square\neg p=\neg(\neg p \mathcal{W}false)$
    \item $p \mathcal{U}q=p \mathcal{W}q \wedge \diamond q = p \mathcal{W}q \wedge\neg(\neg \mathcal{W}false)$
\end{itemize}
\subsubsection*{Possible Axiomatisation}
\begin{itemize}
    \item $\square p\to p$
    \item $\circ\neg p\Leftrightarrow\neg\circ p$
    \item $\circ(p\to q)\Leftrightarrow(\circ p\to\circ q)$
    \item $\square(p\to q)\Leftrightarrow(\square p \to \square q)$
    \item $\square p\to\square\circ p$
    \item $(p\Rightarrow\circ p)\to(p\Rightarrow\square p)$
    \item $p \mathcal{W}q\Leftrightarrow[q\vee(p\wedge\circ(p \mathcal{W}q))]$
    \item $\square p\Rightarrow p \mathcal{W}false$
\end{itemize}
\end{multicols}
\subsection*{Safety-Progess Classification}
\begin{itemize}
    \item Temporal Logic Property Classes
    \begin{itemize}
        \item classification based on syntactic form of formulae
        \item A property $\Pi\subseteq\Sigma^\omega$ will be specified by temporal logic formula $\Phi$ if $\Phi$ is defined over the state vocabulary $\Sigma$ and the following condition holds:
        \[ \sigma\in\Pi \quad \textrm{iff} \quad \sigma\models\Phi \]
        \item hence, $\Phi$ describes a decision mechanism determining whether a state sequence belongs to the set of valid executions of a system
    \end{itemize}
    \item alternative (Manna and Pnueli)
    \begin{itemize}
        \item orthigonal to safety-liveness classification
        \item classes:
        \begin{multicols}{2}
        \begin{itemize}
            \item safety $\square p$
            \item guarantee $\diamond p$
            \item obligation $\diamond p\to\diamond q$ oder $\square\vee\diamond q$
            \item response $\square\diamond p$
            \item persistence $\diamond\square p$
            \item reactivity $\square\diamond p\vee\diamond\square q$
        \end{itemize}
        \end{multicols}
        \item Temporal Logic Specification Patterns:
        \url{http://www.cis.ksu.edu/santos/spec-patterns/index.html}
        \item Scopes used in Specification Patterns
        \begin{center}
        \scalebox{.7}{\input{images/scopes.tikz}}
        \end{center}
    \end{itemize}
\end{itemize}

\section*{Büchi Automata and \textsc{Ltl}}
Relationship of Büchi-Automata and \textsc{Ltl}
\begin{itemize}
    \item Büchi-Automata more expressive.
    \begin{itemize}
        \item \textsc{Ltl} can not count
    \end{itemize}
    \item \begin{tabular}{llcl}
    \textsc{Etl} & Not counter-free Büchi-Automata & $\approx$ & $\omega$-regular languages \\
    \textsc{Ltl} & Counter-free Büchi-Automata & $\approx$ & $^*-free \omega$-regular languages
    \end{tabular}
\end{itemize}
\subsection*{\textsc{Ltl} to Büchi-Automaton Translation}
\begin{itemize}
    \item \textsc{Ltl} often more abstract / easier than to directly specify as Büchi-Automata
    \item next-operator free \textsc{Ltl} specified properties are guaranteed to be stutter invariant \follows Partial Order Reduction
\end{itemize}
\subsubsection*{Overview}
\begin{itemize}
    \item synthesize an automaton that uses Büchi acceptance criteria to represent the same set of models that satisfy the \textsc{Ltl} formula
    \item let every node $s$ of this automaton be labeled with an \textsc{Ltl} formula $\eta(s)$
    \begin{itemize}
        \item for some accepting run $\sigma$, if the automaton reaches state $s$, then the suffice $\ sigma[s\dots]$ must satisfy $\eta(s)$, i.e., $\sigma[s\dots]\models\eta(s)$
        \item the $\eta(s)$ are of the form $(\wedge_{i=1\dots m}\nu_i\wedge\circ(\wedge_{j=1\dots n} \kappa_j)$, i.e. the successor nodes of $s$ have to satisfy $(\wedge_{j=1\dots n}\kappa_j)$
        \item refine $\eta(s)$ into shorter subformulas $\nu_i$ until all $\nu_i$ are propositional variables in positive or negative form
    \end{itemize}
    \begin{center}
    \scalebox{.8}{\input{images/ltlToBuechi.tikz}}
    \end{center}
    \begin{itemize}
        \item for $\Phi \mathcal{U} \Psi$
        \begin{itemize}
            \item either satisfy $\Psi$ now or $\Phi$ now and $\Phi \mathcal{U} \Psi$ later
            \item split current node
            \begin{itemize}
                \item first resulting node, add $\Psi$ to $\nu_i$
                \item second resulting node, add $\Phi$ to $\nu_i$ and $\Phi \mathcal{U} \Psi$ to $\kappa_i$
            \end{itemize}
            \item keep all $\nu_i$ and $\kappa_i$ formulas that are not affected by current splitting
            \item when all formulas have been split, generate successor node $s'$ to $s$
            \item $\nu_i$ of $s'$ are the $\kappa_i$ of $s$
            \item $\kappa_i$ of $s'$ are initially empty
            \item no more splitting? define acceptance condition
        \end{itemize}
        \item Not necessarily the most effective algorithm, but no proof for more effective exists
        \item steps of translation
        \begin{enumerate}
            \item preprocessing: bring formulae into negation normal form
            \item construction of node data structure for Büchi Automaton: recursively decompose
            \item define acceptance criteria to turn node data structure into Büchi Automaton: Use acceptance criterion for \textsc{GNba}
            \item translate the \textsc{GNba} into a ``simple'' \textsc{Nba}
        \end{enumerate}
        \item convert into \emph{negation normal form}, where negation only applies to propositional variables
        \begin{align*}
        \neg\square\Phi             &\Rightarrow \diamond\neg\Phi \\
        \neg\diamond\Phi            &\Rightarrow \square\neg\Phi \\
        \neg(\Phi \mathcal{U}\Psi)  &\Rightarrow (\neg\Phi)\mathcal{V}(\neg\Psi) \\
        \neg(\Phi \mathcal{V}\Psi)  &\Rightarrow (\neg\Phi)\mathcal{U}(\neg\Psi) \\
        \neg(\Phi\vee\Psi)          &\Rightarrow (\neg\Phi)\wedge(\neg\Psi) \\
        \neg(\Phi\wedge\Psi)        &\Rightarrow (\neg\Phi)\vee(\neg\Psi) \\
        \Phi\to\Psi                 &\Rightarrow (\neg\Phi)\vee\Psi \\
        \diamond\Phi                &\Rightarrow  true \mathcal{U}\Phi \\
        \square                     &\Rightarrow  false \mathcal{V}\Phi
        \end{align*}
        \item Semantics of $\mathcal{V}$ (unless): $\Phi$ is false when $\Psi$ is true \note{Is this true?}
        \item node data structure
        \begin{multicols}{2}
        \begin{description}
            \item[Name] unique identifier for the node
            \item[Incoming] list of node names that lead into this node
            \item[New,Old,Next] each is a set of subformulas for $\Phi$
            \begin{itemize}
                \item each node represents suffixes of executions
                \item $New(s)\sup Old(s):\;\nu_i$ formulas
                \item $New(s):$ unprocessed formulas
                \item $Old(s):$ processed formulas
                \item $Next(s):\;\kappa_i$ formulas
            \end{itemize}
            \item[Nodes\_Set] set of all existant nodes
            \begin{center}
            \scalebox{1}{\input{images/nodestructure.tikz}}
            \end{center}
            \item[Observation]
            \begin{itemize}
                \item assumption: $\sigma[\dots s]$ satisfies all subformulae in Old or New
                \item obligation: $\sigma[(s+1)\dots]$ satisfies all subformulae in Next
            \end{itemize}
        \end{description}
        \end{multicols}
        \item Nodes can be split (two nodes after) or evolved (one node after) \note{evolve $\to$ node gets changed only?}
        \item Processing of Current node $s$: is there a subformula to be processed in $New$ of node $s$?
        \begin{description}
            \item[no:] node $s$ is completely processed\\
            is there another node $r$ with the same subformulae as $s$ in both $Old$ and $Next$ field? \follows $s$ is discarded and incoming edges of $s$ are added to $r$\\
            else: add node $s$ to $Nodes\_Set$, continue with new subnode $s'$
            \begin{center}
            \scalebox{1}{\input{images/nodeprocessing.tikz}}
            \end{center}
            \item[yes:] select subformula $\eta$ from $New$
            \begin{itemize}
                \item remove $\eta$ from $New(S):=New(s)-\{\eta\}$
                \item determine main Boolean operator in $\eta$ \follows determine which rule to apply
                \item perform split into $s_1,s_2$ or evolve to $s'$
                \begin{itemize}
                    \item if $\eta$ is $\Phi\wedge\Psi,$\emph{proposition, negated proposition} or \emph{Boolean constant}:
                    \\ if $\eta$ is $false$ or if $\neg\eta$ is in old \follows contradiction, discard
                    \\ else: $s$ evolves into $s'$
                    \item if $\eta=\Phi \mathcal{U}\Psi,\; \Phi \mathcal{V}\Psi,\; \Phi\vee\Psi$, split into $s_1,s_2$
                \end{itemize}
            \end{itemize}
        \end{description}
    \end{itemize}
    \item Automaton construction form node structure
    \begin{itemize}
        \item initial node is initial state
        \item make transitions to states from all states in $Incoming$
        \item \textsc{GNba} Acceptance Conditions
        \begin{itemize}
            \item create set $F_i$ for each subformula of the form $\Phi \mathcal{U}\Psi$
            \item this ensures that if $\Phi \mathcal{U}\Psi$ holds in some run, $\Psi$ must hold later
            \item $F_i$ contains all states that either:
            \begin{itemize}
                \item contain $\Psi$ in its label
                \item does not contain $\Phi \mathcal{U}\Psi$ in its label
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \item Translation from \textsc{GNba} $\mathcal{B}=(\Sigma,S,\delta,I,L,F)$ to \textsc{Nba} $\mathcal{A}'=(\Sigma,S',\delta',I',F')$, $F=\{ F_1\dots F_n \}$
    \begin{itemize}
        \item $S'=S\times\{1\dots n\}$
        \item $I'=I\times\{1\}$
        \item $\delta'$ is defined by $(t,i)\in\delta'((s,k),a)$ if $t\in\delta(s,a)$ and
        \begin{align*}
        i=k             & if\;s\not\in F_k \\
        i=(k \mod n) +1  & if\;s    \in F_k
        \end{align*}
        \item $F'=F_1\times\{1\}$
    \end{itemize}
    \item the construction labels states with numbers from $1\dots n$
    \begin{itemize}
        \item if the current number is $k$, then it will keep $k$ if we do not go though an acceptance state of $F_k$
        \item if we do go though an acceptance state $F_k$, then the new value is $\underset{\textrm{the next} k}{\underbrace{(k \mod n)+1}}$
        \item As soon as we reach an acceptance set from $F_1$ we look for one from $F_2$ next and thus go through all acceptance sets
    \end{itemize}
\end{itemize}
\subsection*{Complexity of Algorithm}
\begin{itemize}
    \item some optimization possible (redundancies, bisimulation reduction, weak alternating automata, prune parts that don't lead to acceptance cycle)
    \item number of nodes and runtime is exponential in the length of the \textsc{Ltl} formula
    \item \textsc{Ltl} are typically small \follows Büchi automaton typically less than $10$ states
    \item \textsc{Ltl} model checking is polynomial in the size of the Büchi automaton
\end{itemize}


\end{document}