\documentclass[a4paper, 10pt]{article}

%\usepackage{scalefnt}
%\usepackage{parcolumns}

\usepackage{newclude}
\include{../zusammenfassung}

\begin{document}

\Gruppe{Stephan Heidinger}{MCSS - Zusammenfassung v0.1}
\Header{Modell Checking in Software Systems}{WS 12/13}{Stephan Heidinger}

\begin{shaded}
Dieses Dokument wurde unter der Creative Commons - Namensnennung-NichtKommerziell-Weitergabe unter gleichen Bedingungen (\textbf{CC by-nc-sa}) ver√∂ffentlicht. Die Bedingungen finden sich unter \href{http://creativecommons.org/licenses/by-nc-sa/3.0/de}{diesem Link}. \\
\centerline{./../cc-by-nc-sa.png}
\end{shaded}

\textit{\hm \; Find any errors? Please send them back, I want to keep them!}

\section*{Basic Principle}
\begin{multicols}{2}
given:
\begin{itemize}
    \item Software Model $M$
    \item Property Specification $S$
\end{itemize}
does $M\models S$
\columnbreak
\begin{center}
\scalebox{0.75}{\input{images/basic_principle.tikz}}
\end{center}
\end{multicols}

\section*{Classification of Software Systems}
\begin{description}
    \item[Transformational Systems] transforms set of (empty) input data into output data, function from state $S_i$ to $S_k$ \\ correctness:
    \begin{itemize}
        \item termination
        \item correctness of function $S_i\to S_k$
        \item correctness of input - output transformation
    \end{itemize}
    \item[Reactive Systems] ongoing interaction with environment, driven by environment \\ correctness:
    \begin{itemize}
        \item non-termination (normally)
        \item correctness of stimuli-response pairs
    \end{itemize}
    \item[Embedded Systems] usually reactive, directly connected to hardware
    \item[Cyber-Physical Systems] integration of computation and physical processes
    \item[Real-Time Systems] systems, where correctness depends on time a result is delivered
    \begin{description}
        \item[Soft Real-Time Systems] missed deadlines will decrease result, not lead to failure, propabilities
        \item[Hard Real-Time Systems] missed deadlines will lead to failure
    \end{description}
    \item[Hybrid Systems] state is characterized by discrete and continuous variables
    \item[Safety-Critical Systems] systems failure may entail, death, serious injury, environmental harm, damage to property/assets
\end{description}

\section*{Requirement Specification}
\begin{description}
    \item[Natural Language] \ \\
    \begin{itemize}
        \good very expressive
        \good understood by all parties
        \bad ambiguous
    \end{itemize}
    \item[Formal Language] \ \\
    \begin{itemize}
        \good unambigous
        \good machine-analyzeable
        \bad limited expressiveness
        \bad hard to understand
    \end{itemize}
\end{description}

\section*{Software Verification Method}
\subsection*{Requirements}
\begin{itemize}
    \item formal foundation (automatic procedures)
    \item should be capable of relating artifacts from different stages in design cycle (formal vs informal req, design vs req, \dots)
    \item should be easy to integrate in design cycle (high degree of automation, low degree of interaction)
    \item scalable
\end{itemize}

\subsection*{Model Checking Process}
\begin{enumerate}
    \item provide model (e.g. Promela), involves abstraction
    \item simulate (check if model does, what you want)
    \item elicit and formalize requirements $\Rightarrow$ property specification
    \item model execution: run model checker with model and specification\\ outcome:
    \begin{itemize}
        \item property is valid (check next property)
        \item property is invalid (counterexample, check model for errors, check properties for errors, rethink design)
        \item exhaust of memory (use more abstraction, state space reduction, incomplete methods)
        \item exhaust of time (smaller model, faster computer)
    \end{itemize}
\end{enumerate}

\section*{\textsc{Spin}}
\begin{itemize}
    \item designed for communication protocols
    \item Open Source
    \item still in development
    \item Promela (\textsc{PROtocol/PROcess MEta LAnguage})
    \begin{itemize}
        \item concurrent modeling language
        \item guarded commands
        \item modeling of reactive systems
    \end{itemize}
\end{itemize}

\subsection*{State-Based Modeling}
\subsubsection*{State}
\begin{itemize}
    \item salient features of a system at given point of observation
    \item states can be observed, as long as features of interest unchanged
    \item features of interest
    \begin{description}
        \item[point of control] ``program counter'' (of all processes)
        \item[values] of local and global variables
        \item[communication channels] (messages sent but not received)
    \end{description}
    \item state vector (byte-wise representation of features of interest) \\
    % \begin{center}
    \scalebox{1}{\input{images/state-vector.tikz}}
    % \end{center}
\end{itemize}

\subsubsection*{State Transition}
\begin{itemize}
    \item instantaneous change of observed features of the system (``something happens'')
    \item represents computation step
    \item sequence of state transitions characterize system computation \\
    % \begin{center}
    \scalebox{1}{\input{images/transition.tikz}}
    % \end{center}
    \item in real-time systems, time passes in states
    \item in stochastic systems, transitions are labeled with probability distributions
    \item in hybrid systems, continuous and discrete state variables change during state transition
    \item transitions show the possible events
    \item transition sequences are valid computations sequences
    \item transitions encode history ($S_0$ has been visited before $S_1$)
\end{itemize}

\subsubsection*{Devising State-Machines}
\begin{itemize}
    \item ``programm a model''
    \item abstraction: focus on relevant, can lead to non-determinism
    \item simplicity: find most simple abstraction that still reveals phenomena
\end{itemize}

\subsubsection*{Deadlock}
\begin{itemize}
    \item concurrent processes wait for each other in a circular wait with no pre-emption
    \item highly undesired
\end{itemize}

\subsubsection*{Closed System Modeling}
\begin{itemize}
    \item model checker can only validate all possible system executions under assumed environment
    \item model includes also environment
\end{itemize}

\subsection*{Transition Systems}
\begin{shaded}
Transition System $TS$ is a tuple $(S,Act,\to,I,AP,L$ where \\
\begin{minipage}{0.48\textwidth}
\begin{tabular}{ll}
$S$ & is a set of states \\
$Act$ & is a set of actions \\
$\to\subseteq S\times Act\times S$ & is a transition relation \\
$I\subseteq S$ & is a set of initial states \\
$AP$ & is a set of atomic propositions \\
$L:S\to2^AP$ & is a labeling function \\
\end{tabular}
\end{minipage}
\hfill \vrule \hfill
\begin{minipage}{0.48\textwidth}
\begin{itemize}
    \item where $S$ and $Act$ are finite or countably infinte
    \item we write $s\to^\alpha s'$ for $\left(s,\alpha,s'\right)\in\to$
    \item Atomic Propositions: Facts that we want to observer/that are observable in the system in any given state.
    \item Labeling Function: shows, which atomic propositions hold in given state.
\end{itemize}
\end{minipage}
\end{shaded}

\begin{shaded}
    \begin{align*}
        Post(s,\alpha) &= \left\{ s'\in S | s\overset{\alpha}{\longrightarrow} s' \right\}
        & Post(s)&=\bigcup_{\alpha\in Act} Post(s,\alpha)
        \\
        Pre(s,\alpha) &= \left\{ s'\in S | s'\overset{\alpha}{\longrightarrow} s \right\}
        & Pre(s)&=\bigcup_{\alpha\in Act} Pre(s,\alpha)
        \\
        Post(C,\alpha) &= \bigcup_{s\in C} Post(s,\alpha),
        & Post(C) &= \bigcup_{s\in C} Post(s)\textrm{ for } C\subseteq S
        \\
        Pre(C,\alpha) &= \bigcup_{s\in C} Pre(s,\alpha),
        & Pre(C) &= \bigcup_{s\in C} Pre(s)\textrm{ for } C\subseteq S
        \\
    \end{align*}
    \begin{center}
    a state is \emph{terminal} or \emph{final} iff $Post(s)=\varnothing$
    \end{center}
\end{shaded}

\subsubsection{(Non)Determinism}
\begin{shaded}
    A transition system $TS=\left(S,Act,\to,I,AP,L\right)$ is \emph{action-deterministic}, iff for all $s,\alpha$
    \begin{itemize}
        \item $|I|\leq1$ and
        \item $|Post(s),\alpha)|\leq1$
    \end{itemize}
    else it is \emph{action-nondeterministic} \\
    {\tiny there is at most one outgoing transition from each state labeled $\alpha$}
\end{shaded}

\begin{shaded}
    A transition system $TS=\left(S,Act,\to,I,AP,L\right)$ is \emph{AP-deterministic}, iff for all $s,A\in2^{AP}$
    \begin{itemize}
        \item $|I|\leq1$ and
        \item $|Post(s)\cap \left\{s'\in S | L(s')=A\right\}|\leq1$
    \end{itemize}
    else it is \emph{AP-nondeterministic} \\
    {\tiny every successor of a state $s$ has a unique $AP$ labeling}
\end{shaded}

\begin{itemize}
    \item Nondeterminism can lead to potentially smaller representation.
    \item in Software Engineering/Modeling: Abstraction
    \begin{itemize}
        \item avoid overspecification
        \item what does the system do, not how is it done
    \end{itemize}
    \begin{itemize}
        \item concurrency
        \begin{itemize}
            \item simulate concurrency by nondeterminsm
            \item either nondeterministic action can be executed first
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection*{System Execution}
Given a transition system $TS=\left(S,Act,\to,I,AP,L\right)$
\begin{description}
    \item[finite execution fragment] $\varrho$ of $TS$ is an alternating sequence of states and actions ending with a state:
    \[ \varrho = s_0\alpha_1 s_1\alpha_2\dots\alpha_n s_n \textrm{ s.t. } s_i\to^{\alpha_{i+1}} s_{i+1} \textrm{ for all } 0\leq i<n \]
    \item[infinite execution fragment] $\varrho$ of $TS$ is an infinite, alternating sequence of states and actions:
    \[ \varrho = s_0\alpha_1 s_1\alpha_2\dots\alpha_n s_n \textrm{ s.t. } s_i\to^{\alpha_{i+1}} s_{i+1} \textrm{ for all } 0\leq i \]
    \item[execution] of TS is an inital, maximal execution fragment
    \begin{itemize}
        \item an execution fragment is maximal, iff it is either
        \begin{itemize}
            \item finite and ending in a terminal state
            \item[or]
            \item infinite
        \end{itemize}
        \item an execution fragment is initial, iff $s_0\in I$
    \end{itemize}
    \item[reachable state] is a state $s\in S$ if there exists an initial, finite execution fragment $s_0\alpha_1s_1\dots\alpha_ns_n$ so that $s_n=s$
    \item[$Reach(TS)$] denotes the set of all reachable states in $TS$ \\
    % \begin{center}
    \scalebox{1}{\input{images/reach.tikz}}
    % \end{center}
\end{description}

\section*{Program Graphs \textsc{Pg}}
\begin{itemize}
    \item want to include things like variables, assignements, etc $\Rightarrow$ Program Graphs
    \item introduce conditional transitions (transition can only be exectured, if condition is true) \[ s \overset{\red g:\blue\alpha}{\longrightarrow}s' \]
    \begin{itemize}
        \item $\red g$: a boolean condition on data variables (``guard'')
        \item $\blue\alpha$: an action, that is possible, if g is satisfied
    \end{itemize}
    \item assume domain of variables as infinite
    \begin{itemize}
        \item practical implementations use variables over finite domains
    \end{itemize}
    \item Stepwise unfolding of $PG$s lead to $TS$
\end{itemize}

\begin{description}
    \item[valuation:] assign values to variables (e.g. $\eta(x)=17$)
    \item[propositional logic formulae]
    \item[effect] of actions: \[ Effect: Act\times Eval(Var)\to Eval(Var) \]
    Effects define \emph{operational semantics}
\end{description}

\begin{shaded}
    A \emph{program graph} $PG$ over set $Var$ of typed variables is a tuple $\left( Loc, Act, Effect, \to, Loc_0, g_0 \right)$ where
    \begin{itemize}
        \item $Loc$ is a set of locations with initial locations $Loc_0\subseteq Loc$
        \item $Act$ is a set of actions
        \item $Effect: Act\times Eval(Var)\to Eval(Var)$ is the effect function
        \item $\to \subseteq Loc\times \left(Cond(Var) \times Act\right) \times Loc $, transition relation {\tiny cond = boolean condition}
        \item $g_0\in Cond(Var)$ is the inital condition
    \end{itemize}
    Notation $\ell\overset{\red g:\blue\alpha}{\longrightarrow} \ell'$ denotes $\left(\ell,\red g, \blue\alpha,\ell'\right)\in \longrightarrow$
\end{shaded}
\subsection*{Semantics for Program Graphs}
\begin{itemize}
    \item Unfolding: Transformation of $PG$ to equivalent $TS$
    \begin{itemize}
        \item states:
        \begin{itemize}
            \item state $<l,\eta\rangle$: current control location $l$ + data valuation $\eta$
            \item initial state: initial location satisfying condition $g_0$
        \end{itemize}
        \item propositions:
        \begin{itemize}
            \item $at\_l$: control is at location $l$
            \item $x\in D$ iff $D\subseteq dom(x)$
        \end{itemize}
        \item labeling
        \begin{itemize}
            \item $<l,\eta\rangle$ is labeled with $at\_l$ and all conditions that hold in $\eta$
        \end{itemize}
    \end{itemize}
    \item from transitions in $PG$ to transitions in $TS$
    \begin{itemize}
        \item if $\ell\overset{\red g:\blue\alpha}{\longrightarrow} \ell'$ and $g$ holds in $\eta$, then $<l,\eta\rangle\to^\alpha<l',Effect(\alpha,\eta)\rangle$
    \end{itemize}
\end{itemize}

\subsection*{Structured Operational Semantics \textsc{Sos}}
\begin{itemize}
    \item definition of \emph{operational semantics} of a program in terms f computations steps defined by a transition system
    \item whether a step happens is determined by inference rules: \[ \frac{premise}{conclusion} \]
    \begin{itemize}
        \item if the premise holds, the conclusion holds (and can trigger further inference rules)
        \item if the premise is a \emph{tautology}, it may be omited\\
        the rule is then called an \emph{axiom}
    \end{itemize}
    \item semantics is structural, because it applies inference rules recursively to syntactic structure
\end{itemize}

\subsection*{Transition Systems for Program Graphs}
\begin{shaded}
    The transition system $TS(PG)$ of program graph \[PG=(Loc, \blue{Act}, Effect,\longrightarrow, Loc_0,g_0)\] over set $Var$ of variables is the tuple \[ (S,\blue{Act},\longrightarrow,I,AP,L) \] where
    \begin{itemize}
        \item $S=Loc\times Eval(Var)$
        \item $\longrightarrow\subseteq S\times Act\times S$ is defined by $\displaystyle\frac{\ell\overset{\red g:\blue\alpha}{\longrightarrow} \ell'\; \wedge \; \eta\models \red g}{<\ell,\eta\rangle\overset{\blue\alpha}{\longrightarrow}<\ell',Effect(\blue\alpha,\eta)\rangle}$
        \item $I=\left\{<\ell,\eta\rangle | \ell \in Loc_0,\eta \models g_0\right\}$
        \item $AP=Loc \cup Cond(Var)$ and $L\left(<\ell,\eta\rangle\right)=\{\ell\} \cup \left\{ g\in Cond(Var) | \eta \models g \right\} $
    \end{itemize}
\end{shaded}

\subsubsection*{Data in Transition Systems}
\begin{itemize}
    \item $TS$ do not possess data variables, data values and their changes need to be encoded in states
    \item assume $i=1,\dots,n$ variables of domain $s_i$ \follows $\Pi^n_{i=1}s_i$ \\
    \emph{combinatorial, exponential state space explosion}
    \item variables over infinite domains \follows infinite number of states
\end{itemize}

\section*{Modelling Concurrency}
\subsection*{Concurrent Event}
\begin{itemize}
    \item logically independent events in separate autonomous system
\end{itemize}

\subsection*{Lamport's \emph{happened-Before} Relation $\to$}
\begin{shaded}
    \begin{description}
        \item[HB1:] for any pair of events $e$ and $e'$, if there is a process $p_i$ such that $e \to_i e'$, then $e \to e'$
        \item[HB2:] for any pair of events $e$ and $e'$ and for any message $m$, if $e = send(m)$ and $e' = receive(m)$, then $e \to e'$
        \item[HB3:] if $e$, $e'$ and $e''$ are events and if $e \to e'$ and $e' \to e''$, then $e \to e''$ (HB is identical to its transitive closure)
    \end{description}
\end{shaded}

\begin{center}
\scalebox{1}{\input{images/lamport.tikz}}
\end{center}

\subsection*{Concurrency}
\begin{itemize}
    \item two events are $E_1, E_2$ are concurrent, if each ordering of them is possible
\end{itemize}

\subsection*{Interleaving}
\begin{itemize}
    \item concurrent actions $\alpha,\beta$ are executed in arbitrary order
    \item $Effect(\alpha \interleave \beta,\nu) = Effect((\alpha;\beta)+(\beta;\alpha),\nu$
    \begin{itemize}
        \item $\interleave$  is binary interleaving operator
        \item $;$ is sequential execution
        \item $+$ is nondeterministic choice
        \item $\underset{=\alpha}{\underbrace{x:=x+1}} \interleave \underset{=\alpha}{\underbrace{y:=y-2}}$ \\
        \begin{center}
        \scalebox{.8}{\input{images/interleave.tikz}}
        \end{center}
    \end{itemize}
    \begin{shaded}
        Let $TS_i=(S_i,Act_i,\to_i,I_i,AP_i,L_i), i=1,2$ be two transition systems.
        \[ TS_1\interleave TS_2 = (S_1\times S_2,Act_1\uplus Act_2),\to,I_1\times I_2,AP_1\uplus AP_2, L) \]
        where $L(\langle s_1,s_2\rangle)=L_1(s_1) \cup L_2(s_2)$ and the transition relation $\to$ is defined by the rules:
        \[
        \frac{\red{s_1}\overset{\alpha}{\longrightarrow}_1 \red{s'_1}}
        {\langle\red{s_1},s_2\rangle \overset{\alpha}{\longrightarrow} \langle\red{s'_1},s_2\rangle}
        \textrm{ and }
        \frac{\red{s_2}\overset{\alpha}{\longrightarrow}_2 \red{s'_2}}
        {\langle s_1,\red{s_2}\rangle \overset{\alpha}{\longrightarrow} \langle s_1,\red{s'_2}\rangle}
        \]
    \end{shaded}
    \begin{itemize}
        \item Interleaving of Program Graphs\\
        let $PG_1$ and $PG_2$ be program graphs
        \begin{description}
            \item[without shared variables:] \ \\
            i.e. $Var_1\cap Var_2=\varnothing$\\
            concurrent behaviour: $TS(PG_1)\interleave TS(PG_2)$
            \item[with shared variables:] \ \\
            concurrent behaviour: $TS(PG_1 \interleave PG_2)$
            \item[in general:] \ \\
            $TS(PG_1) \interleave TS(PG_2) \not= TS(PG_1\interleave PG_2)$
        \end{description}
        \begin{shaded}
            For program graph $PG_i=(Loc_i,Act_i,Effect_i,\longrightarrow_i,Loc_{0,i},g_{0,i})$ over variables $Var_i$, the Program graph $PG_1\interleave PG_2$ over $Var_1\cup Var_2$ is defined by:
            \[ (Loc_1\times Loc_2,Act_1\uplus Act_2,Effect,\longrightarrow,Loc_{0,1}\times Loc_{0,2},g_{0,1}\wedge g_{0,2}) \]
            where $\longrightarrow$ is defined by the inference rules:
            \[
            \frac{\red{l_1} \overset{g:\alpha}{\longrightarrow} \red{l'_1}}
            {\langle \red{l_1},l_2 \rangle \overset{g:\alpha}{\longrightarrow} \langle \red{l'_1},l_2 \rangle}
            \textrm{ and }
            \frac{\red{l_2} \overset{g:\alpha}{\longrightarrow} \red{l'_2}}
            {\langle l_1,\red{l_2} \rangle \overset{g:\alpha}{\longrightarrow} \langle l_1,\red{l'_2} \rangle}
            \]
            and $Effect(\alpha,\eta)=Effect_i(\alpha,\eta)$ if $\alpha\in Act_i$.
        \end{shaded}
        \begin{center}
        \scalebox{.7}{\input{images/interleavePgTs.tikz}}
        \end{center}
        \item \textbf{atomicity} a sequence of statements is called \emph{atomic}, if it cannot be interleaved with program statements from a concurrently executing program. \\
        \[\underset{atomic}{\underbrace{\langle x:=x+1;y:=2x+1\rangle}} ; x:=0\]
    \end{itemize}
\end{itemize}

\subsection*{Inter Process Synchronisation}
\begin{itemize}
    \item concurrent processes need to synchronize their computations
    \begin{itemize}
        \item adjust relative speed
        \item exchange data, that may be needed by other processes
    \end{itemize}
    \item common synchronization methods:
    \begin{itemize}
        \item shared variables
        \item message passing
        \begin{itemize}
            \item synchronous (rendez-vous, handshaking) \\
            wait till other party is ready
            \begin{shaded}
                Let $TS_i=(S_i,Act_i,\longrightarrow_i,I_i,AP_i,L_i), i=1,2$ and $H\subseteq Act_1\cap Act_2$. \\
                Introducing: The \emph{handshake-operator} $\Vert_H$ for an action set $H$ in the following way:
                \[ TS_1 \Vert_H TS_2 = (S_1\times S_2,Act_1\cup Act_2,\longrightarrow,I_1\times I_2, AP_1 \uplus AP_2,L) \]
                where $(\langle s_1,s_2\rangle) = L_1(s_1)\cup L_2(s_2)$ and $\longrightarrow$ is defined as follows
                \begin{itemize}
                    \item for $\alpha\not\in H$ (interleaving)
                    \[
                    \frac{
                    s_1 \overset{\alpha}{\longrightarrow} s'_1
                    }{
                    \langle s_1,s_2 \rangle \overset{\alpha}{\longrightarrow} \langle s'_1,s_2 \rangle
                    }
                    \phantom{\textrm{ and ¬∑}}
                    \frac{
                    s_2 \overset{\alpha}{\longrightarrow} s'_2
                    }{
                    \langle s_1,s_2 \rangle \overset{\alpha}{\longrightarrow} \langle s_1,s'_2 \rangle
                    }
                    \]
                    \item for $\alpha\in H$ (handshaking)
                    \[
                    \frac{
                    s_1 \overset{\alpha}{\longrightarrow}_1 s'_1 \wedge s_2 \overset{\alpha}{\longrightarrow}_2 s'_2
                    }{
                    \langle s_1,s_2 \rangle \overset{\alpha}{\longrightarrow} \langle s'_1,s'_2 \rangle
                    }
                    \]
                    \item $\Vert$ is shorthand for $\Vert_H$ when $H=Act_1\cap Act_2$
                \end{itemize}
            \end{shaded}
            \item asynchronous (typically fifo, queue)
            \begin{itemize}
                \item $c!e$: send the value of expression $e$ along the channel $c$
                \item $c?x$: receive a message from channel $c$ and assign it to variable $x$
                \item channels have storage capacity $cap(c)$
                    \\ if $cap(c)\in\mathbb{N}$, then $c$ is a channel with finite capacity
                    \\ if $cap(c)=\infty$, then $c$ has infinite capacity
                    \\ $cap(c)=0$ sometimes means, that the channel uses synchronous handshake communication
                \item types of communication:
                \begin{description}
                    \item[non-blocking:] execution never delays invoker
                    \item[blocking:] otherwise
                \end{description}
                \item when is blocking taking place?
                    \\ asynchronous message passing with unbounded buffers \follows sender never blocks
                    \\ synchronous message passing: no buffering
                    \\ buffered message passing with bounded, finite capacity
                    \begin{description}
                        \item[sender blocks] on full buffer
                        \item[sender does not block] on full buffer (entails message loss)
                    \end{description}
            \end{itemize}
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection*{Channel System}
\begin{shaded}
    A \emph{channel system} $CS$ over $(Var,Chan)$ consists of $i$ program graphs $PG_i$ over $(Var_i,Chan_i)$, for $1\leq i\leq n$, with $Var=\bigcup_{1\leq i\leq n}Var_i$ and is denoted by $CS=[PG_1 | \dots | PG_n ]$ \\
    Global states are tuples of the form $\langle l_1,\dots,l_n,\eta, \xi \rangle$ where
    \begin{description}
        \item[$l_i$] current control location of process $i$
        \item[$\eta$] current valuation of variables
        \item[$\xi$] current valuation of channels
    \end{description}
    \begin{itemize}
        \item A \emph{channel evaluation} $\xi$ is a mapping from channel $c\in Chan$ onto sequence $\xi(c)\in dom(c)^*$ such that
        \begin{itemize}
            \item current length cannot exceed the capacity of $c:len(\xi(c))\leq cap(c)$
            \item $\xi(x)=v_1v_2\dots v_k, cap(c)\geq k$ denotes, $v_1$ is at front of buffer, etc.
            \item $\xi [c:=v_1\dots v_k]$ denotes channel evaluation
            \[ \xi [c:=v_1\dots v_k] (c') =
            \begin{cases}
            \xi(c') & if c \not= c' \\
            v_1\dots v_k & c=c
            \end{cases}
            \]
            \item initial channel evaluation $\xi_0$ equals $\xi_0(c)=\varepsilon$ for any $c$.
        \end{itemize}
        Let $CS=[PG_1 | \dots | PG_n ]$ be a \emph{channel system} over $(Chan,Var)$ with
        \[ PG_i = (Loc_i, Act_i, Effect_i,) \rightsquigarrow_i, Loc_{0,i}, g_{0,i}, \textrm{ for } 0<i\leq n \]
        $TS(CS)$ is the \emph{transition system} $(S,Act,\to,I,AP,L)$ where
        \begin{itemize}
            \item $S=(Loc_1\times\dots\times Loc_n)\times Eval(Var) \times Eval(Chan)$
            \item $Act = (\biguplus_{0<i\leq n} Act_i) \uplus \{ \tau \}$
            \item $I=\left\lbrace \langle \ell_1,\dots \ell_n,\eta,\xi_0 \rangle | \forall i. (l_i\in Loc_{0,i} \wedge \eta \models g_{0,i}) \wedge \forall c.\xi_0(c)=\varepsilon \right\rbrace$
            \item $AP=\biguplus_{0<i\leq n} Loc_i \uplus Cond(Var)>$
            \item $L(\langle \ell_1,\dots,\ell_n,\eta,\xi\rangle) = \{\ell_1,\dots,\ell\} \cup \{g\in Cond(Var) | \eta \models g \}$
            \item $\to$ is defined by the inference rules:
            \begin{description}
                \item[Interleaving for $\alpha\in Act_i$:]
                \[
                \frac{
                \red{\ell_i} \overset{g:\alpha}{\longrightarrow} \red{\ell'_i} \wedge \eta \models g
                }{
                \langle \ell_1,\dots,\red{\ell_i},\dots,\ell_n,\blue\eta,\xi \rangle
                \overset{\alpha}{\longrightarrow}
                \langle \ell_1,\dots,\red{\ell'_i},\dots,\ell_n,\blue{\eta'},\xi \rangle
                },
                where \;\blue{\eta'} = Effect(\alpha,\blue\eta)
                \]
                \item[Synchronous message passing over $c\in Chan, \; cap(c)=0$:]
                \[
                \frac{
                \red{\ell_i} \overset{g:c?x}{\longrightarrow} \red{\ell'_i}
                \wedge
                \red{\ell_j} \overset{g:c!e}{\longrightarrow} \red{\ell'_j}
                \wedge \eta \models g\wedge g' \wedge i\not=j
                }{
                \langle \ell_1,\dots,\red{\ell_i},\dots, \red{\ell_j}\dots,\ell_n,\blue\eta,\xi \rangle
                \overset{\tau}{\longrightarrow}
                \langle \ell_1,\dots,\red{\ell'_i},\dots,\red{\ell'_j}\dots,\ell_n,\blue{\eta'},\xi \rangle
                },
                where \; \blue{\eta'} = \blue{\eta} [x:=\eta(e)]
                \]
                \item[Asynchronous message passing over $c\in Chan, cap(c)<0$:]
                \[\frac{
                \red{\ell_i} \overset{g:c?x}{\longrightarrow} \red{\ell'_i}
                \wedge
                \eta\models g
                \wedge
                len(\xi(c)) = k>0
                \wedge
                \eta(c) = v_1\dots v_k
                }{
                \langle \ell_1,\dots,\red{\ell_i},\dots,\ell_n,\blue\eta,\dGreen\xi \rangle
                \overset{\alpha}{\longrightarrow}
                \langle \ell_1,\dots,\red{\ell'_i},\dots,\ell_n,\blue{\eta'},\dGreen{\xi'} \rangle
                },
                where \; \blue{\eta'} = \blue{\eta} [x:=v_1] \textrm{ and } \dGreen{\xi'}=\dGreen\xi [c:=v_2\dots v_k]
                \]
                \item[transmit value $\eta(e)\in dom(c)$ over channel $c$:]
                \[\frac{
                \red{\ell_i} \overset{g:c!\blue e}{\longrightarrow} \red{\ell'_i}
                \wedge
                \eta \models g
                \wedge
                len(\eta(c))=k<cap(c)
                \wedge
                \eta(c) = v_1\dots v_k
                }{
                \langle \ell_1,\dots,\red{\ell_i},\dots,\ell_n,\eta,\dGreen\xi \rangle
                \overset{\alpha}{\longrightarrow}
                \langle \ell_1,\dots,\red{\ell'_i},\dots,\ell_n,\eta',\dGreen{\xi'} \rangle
                },
                where \; \dGreen{\xi'}=\dGreen\xi [c:=v_1v_2\dots v_k\eta(\blue e)]
                \]
            \end{description}
        \end{itemize}
    \end{itemize}
\end{shaded}

\subsection*{nanoPromela}
\follows 5-38 to 5-50

\subsection*{State Machine Based Modeling}
\begin{itemize}
    \item Practical use: no TS or PG \follows state machine models \\
    can all be modelled as Program Graphs, Channel Systems or Transition Systems \\
    $\textsc{Uml-Rt} \subset \textsc{Uml}:$ state charts
    \item Mealy and Moore Machines \\
    \begin{itemize}
        \item  expressively equivalent
        \item non-deterministic
    \end{itemize}
    \begin{shaded} let
    \begin{tabular}{ll}
        $Q:$ & finite set of states \\
        $q_0\in Q$: & initial state \\
        $I$: & an alphabet (input symbols) \\
        $O \textrm{ with }I\cap O=\varnothing:$ & an alphabet (output symbols) \\
        $A=I\cup O$ & event alphabet \\
        $\delta: Q\times A\to Q:$ & a relation \\
        $\rho: Q\times I\to O\times Q:$ & a relation \\
        \end{tabular}
    \begin{description}
        \item[Moore machine:] we call $(Q, q_0, A, \delta)$ a \textbf{finite Moore machine}
        \begin{center}
        \scalebox{1}{\input{images/moore.tikz}}
        \end{center}
        \item[Mealey machine:] we call $(Q,q_0,I,O,\rho)$ a \textbf{finite Mealey machine}
        \begin{center}
        \scalebox{1}{\input{images/mealey.tikz}}
        \end{center}
    \end{description}
\end{shaded}
    \item Desiderata for Reactive System Models:
    \begin{enumerate}
        \item representation of \emph{data}
        \item representation of \emph{concurrency}
        \item representation of \emph{communication}\\
        especially: asynchronous communication / message passing
    \end{enumerate}
    \item Communicating Finite State Machines \textsc{Cfsm}s
    \begin{itemize}
        \item groups of independent, concurrently executing state machines
        \item communication and synchronization by message passing over unbounded buffers
    \end{itemize}
    \item Extended Finite State Machines \textsc{Efsm}
    \begin{itemize}
        \item data variables
        \item predicates
        \item operations
    \end{itemize}
    \item \textsc{Cfsm}s after Brand and Zafiropulo
    \begin{shaded}
    \begin{itemize}
        \item concurrenct \textsc{Fsm} ($\geq2$) + communication channels
        \item every \textsc{Fsm} represents a concurrent communicating process with a finite number of control states
        \item every communication channel is:
        \begin{enumerate}
            \item full duplex
            \item error-free
            \item has a first-in-first-out strategy
            \item has unbounded capacity
        \end{enumerate}
        {\tiny 1.-3. characterize a \emph{perfect full-duplex} channel}
        \item one pair of channels ($c_{ij}$ and $c_{ji}$) for each pair $(i,j)$ of machines
    \end{itemize}
    \begin{center}
    \scalebox{1}{\input{images/cfsm.tikz}}
    \end{center}
    \item formalisation:
    \begin{tabular}{ll}
    $N$ : & a positive integer \\
    $i,j=1,\dots N$: & index over processes \\
    $\langle Q_i\rangle^N_{i=1}$: & $N$ disjoint, finite sets, $Q_i$ denots the state set of process $I$ \\
    $\langle A_{ij}^N\rangle_{i,j=1}$: &
        \begin{minipage}[t]{10cm}
        $N^2$ disjoint sets, with $(\forall i)(A_{ii}=\varnothing)$ $A_{ij}$ denotes the message alphabet for the channel $i\to j$ \end{minipage}\\
    $\delta$: &
    \begin{minipage}[t]{10cm}
        relation, determining, for each pair $i,j$ the following function:
        \begin{itemize}
            \item $Q_i\times A_{ij}\to Q_i$
            \item $Q_i\times A_{ji}\to Q_i$
        \end{itemize}\end{minipage} \\
        $\langle q_i^0\rangle$: & tupel of initial states, $(\forall i)(q_i^0\in Q_i)$
    \end{tabular}
    \item we call $\left( \langle Q_i\rangle, \langle q_i^0 \rangle, \langle A_{ij} \rangle, \delta \right)$ a \emph{protocol}
    \item Notation:
    \begin{tabular}{ll}
    $s_i\in Q_i:$ & state of process $i$ \\
    $x_{ij}\in A_{ij}:$ &
        \begin{minipage}[t]{10cm}
        a message
        \begin{itemize}
            \item $?x_{ij}$ reception of a message
            \item $!y_{ji}$ sending of a message
        \end{itemize}
        \end{minipage} \\
        & $f((s_i,\dots,s_n))=(f(s_i),\dots,f(s_n))$ \\
        $x,y$: & message \\
        $X,Y$: & sequence of messages \\
        $x, xy, xY, xXY$: & concatenated sequences of messages
    \end{tabular}
    \end{shaded}
\end{itemize}

\subsubsection*{Formal Semantics for a Promela-like}
\begin{description}
    \item[Semantics] of a protocol: set of admissable state sequences
    \item[State] of a protocol?
    \begin{itemize}
        \item sum of
        \begin{itemize}
            \item local state of each of the $1\dots N$ processes
            \item state of all channels $c_{ij}\in A_{ij}^*$ \\
            each $c_{ij}$ corresponds to a sequence of messages that have been sent, but not yet received
        \end{itemize}
        \item we call this the \emph{global system state}
    \end{itemize}
\end{description}
\begin{itemize}
    \item obtain set of all computations of a protocol:
    \begin{itemize}
        \item initially: all processes in $q_i^0$ and all $c_ij=\varnothing$
        \item system is in current state $s$
        \item state transition triggered by \emph{send} and \emph{receive} events
        \begin{description}
            \item[send event:]
            \begin{itemize}
                \item add a message to the tail of the corresponding message queue
                \item change local system state of sending process
            \end{itemize}
            \item[receive event:]
            \begin{itemize}
                \item take the message to be received from the head of the message queue
                \item change local system state of receiving process
            \end{itemize}
        \end{description}
        \item leads into new global system state $s'$
    \end{itemize}
    \item Global System State
    \begin{itemize}
        \item $P=\left(\langle Q_i\rangle,\langle q_o^0 \rangle, \langle A_ij \rangle,\delta \right)$ a protocol
        \item $S=(S_1,\dots,S_N)$ an $N$-tuple of local process states
        \item $C$ an $N^2$ tuple \\
        \[C= \left(
        \begin{array}{cccc}
         & c_1 & \cdots & c_N \\
         c_1 & \epsilon & & \\
         \vdots & & \ddots & \\
         c_N & & & \epsilon
        \end{array}
        \right)
        \] so that for all $i,j:c_{ij}\in A_{ij}^*$
        \item we call $(S,C)$ a \emph{global system state}
        \item \textbf{State Transition Relation} let $P$ a protocol and $G=\{(S,C) | (S,C) \textrm{ is a global system state}\}$
    \\
    $\vdash: \; G \to G$ is defined as follows \\
    $(S,C) \vdash (S',C') \; iff \; \exists\; i,k,x_{ik}$ such that either
    \begin{enumerate}
        \item $(S,C)$ and $(S',C')$ are identical except for the following exceptions
        \[ s_i'=\delta(s_i.!x_{ik}) \textrm{ (\blue{sending by i})} \]
        \[ \blue{c'_{ik} =c_{ik}x_{ik} } \]
        \item $(S,C)$ and $(S',C')$ are identical except for the following exceptions
        \[ s'_k = \delta(s_k,?x_{ik}) \textrm{ (\dGreen{receiving by k}) } \]
        \[\dGreen{c_{ik} = x_{ik}c'_{ik}} \]
    \end{enumerate}
    \item Reachable Global System State, Paths and Acceptance
    \begin{itemize}
        \item $G^0$ the initial global system state of a protocol
        \item $G$ a global system state of the same protocol
        \item $\vdash$ the state transition relation of this same protocol
        \item $\vdash^*$ denotes the transitive closure of $\vdash$
    \end{itemize}
    \item we say that $G$ is rechable if \[ G^0 \vdash^* G \]
    \end{itemize}
    \item When is a Problem $P$ decidable? \\
    There exists an algorithm which terminates after a finite number of steps whether $P=\varnothing$ or not.
    \item What is a Turing machine? {\tiny you should know \dots}
    \item Example of an undecidable problem?
    \\ There is no TM that will decide whether an arbitrary given TM will halt or not.
    \item When is a formalism Turing-complete?
    \\ When you can simulate a TM in this formalism.
    \item \textsc{Cfsm} are Turing-complete
    \begin{itemize}
        \item three processes: $P_1,P_2,P_3$
        \item simulate the control of the TM in the state machine of $P_2$
        \item use $P_1$ and the channels $c_{21}$ and $c_{c12}$ to simulate the left half tape, use $P_3$ and $c_{23}$ and $c_{32}$ to simulate the right half tape
        \item note: all $c_{ik}$ have unbounded length
        \\ \follows infinite state space (globally)
        \\ \follows undecidable problems:
        \begin{itemize}
            \item termination
            \item will some communication event ever be executed?
            \item is some system state reachable
            \item is the protocol deadlock-free?
        \end{itemize}
        \item a channel $c_{ij}$ is \emph{bounded} if, for every reachable global system state $(C,S)$, the length of $c_ik$ is bounded by a constant $h$
        \\ with bounded channels above problems are decidable, however deadlocks may be introduced due to bounded chans.
    \end{itemize}
\end{itemize}

\subsubsection*{Extended Finite State Machines (EFSM)}
An \textsc{Efsm} is a \textsc{Fsm} extended by
\begin{itemize}
    \item data abstraction
    \item operations on variables
    \item symbolic (explicit states)
    \item boolean transition conditions
\end{itemize}
A (symbolic) state of an \textsc{Efsm} represents an \emph{equivalence class} of system states.

\begin{shaded}
    we call $E=(S,D,V,O,I,T,C)$ an extended finite state machine \textsc{Efsm}, where
    \begin{tabular}{ll}
    $S$: & set of symbolic states \\
    $D$: & $n$-dimensional linear space, each $D_i$ is an (infinite) data domain \\
    $V$ &
    \begin{minipage}[t]{10cm}
    $=\{\Pi,v_1,\dots,v_n\}:$ finite set of programme variables
    \begin{itemize}
        \item $\Pi$: control variable over domain $S$
        \item $\{v_1,\dots,v_2\}\in D$: data variables
    \end{itemize}
    \end{minipage} \\
    $O$: & finite set of output signal types \\
    $I$: & finite set of input signal types \\
    $T$: & $S\times 2^D\times I \to S\times 2^D\times O$ \\
    $C$: & an initial condition over $S\times 2^D$
    \end{tabular}
\end{shaded}

\subsubsection*{Communicating Extended Finite State Machines}
\begin{itemize}
    \item foundation for many practical specifications and modeling languages
    \begin{itemize}
        \item Specification and Description Language \textsc{Sdl} (now part of \textsc{Uml})
        \item Estelle (\textsc{Iso})
        \item \textsc{Room/Uml-Rt}
        \item \textsc{Uml-Rt}
        \item \textsc{SysMl}
    \end{itemize}
\end{itemize}

\subsection*{State Explosion Problem}
\begin{itemize}
    \item Size of Transition System
    \begin{itemize}
        \item size of $TS = |S|+|\to|$
        \begin{itemize}
            \item dependend on
            \begin{itemize}
                \item use of data (variables) (exponentially larger)
                \item use of concurrent composition
                \item use of communication channels
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \begin{itemize}
        \item Program Graphs
        \begin{itemize}
            \item number of states of $ TS(PG)=|\# programm\;locations|\cdot \prod\limits_{variable\; x} |dom(x)|$
            \item growth of $TS(PG)$
            \begin{itemize}
                \item assume $N$ variables, each with $k=|dom(x)|$ possible values
                \\ \follows $k^N$ states {\tiny exponential growth}
                \item Programm with 10 locations, 3 boolean variables, 5 integer variables ranging $1-10$
                \\ $10\times 2^3\times 10^5=8\,000\,000=8\times 10^6$ states
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \item Concurrent Composition of Transition Systems
    \begin{itemize}
        \item derived form concurrent programs
        \item size:
        \begin{itemize}
            \item Cartesian product of state spaces of componens $TS$s, i.e. $\#states\ of \ P_1\times \dots \times \#states\ of \ P_2$
            \item assume $N$ components of size $k$ each \follows size of $TS=k^N$
        \end{itemize}
    \end{itemize}
    \item Channel Systems:
    \begin{itemize}
        \item assynchronous communication channels $c$ with capacity $cap(c)$
        \item assume $K$ components and $N$ channels
        \\ \follows worst case size: $\displaystyle \prod^N_{i=1} \left(|\#programm\ locations| \prod_{variable\ x} |dom(x)|\right)\cdot\prod^K_{j=1}|dom(c_j)^{cap(c_j)}$
    \end{itemize}
\end{itemize}

\section*{Linear-Time Properties and Invariants}
\begin{description}
    \item[Property:] A system execution (computation) will be modeled as a \emph{sequence of states or events}.
    \begin{itemize}
        \item $\sigma_0 = <g,a,z,g,\dots>$
        \item $\sigma_1 = <g,a,d,g,\dots>$
    \end{itemize}
    \begin{shaded}
        A (model of the system/system/program) P has the property $\Pi$ if all its computations are in $\Pi$.
    \end{shaded}
    \item[Property Representation:] too cumbersome to enumerate all infinite computations \follows use mathematical formalisms:
    \begin{itemize}
        \item $\omega$-automata (property corresponds to accepted language)
        \item $\omega$-regular expressions
        \item temporal logic
    \end{itemize}
\end{description}

\subsection*{State Graph}
\begin{shaded}
\begin{itemize}
    \item The \emph{state graph} of $TS$ ($G(TS)$, is the digraph $(V,E)$ with vertices $V=S$ and edges $E=\{(s,s')\in S\times S | s'\in Post(s)\}$ \follows omit all state and transition labels in $TS$ and ignore being inital
    \item $Post^*(s)$ is the set of reachable states $G(TS)$ from $s$:
    \[ Post^*(C)=\bigcup_{s\in C}Post^*(s) \textrm{ for } C \subseteq S \]
    \item $Pre^*(C)$ has analogous meaning
    \item set of reachable states: $Reach(TS)=Post^*(I)$
\end{itemize}
\end{shaded}

\subsection*{Path Fragment}
\begin{shaded}
    \begin{itemize}
        \item A \emph{path fragment} is an execution fragment without actions
        \item A \emph{finite path fragment} $\hat{\pi}$ of $TS$ is a state sequence:
        \[ \hat{\pi} = s_0s_1\dots s_n \textrm{ such that } s_{i+1}\in Post(s_i) \textrm{ for all } 0 \leq i<n \textrm{ where } n\geq0 \]
        \item An \emph{infinite path fragment} $\pi$ of $TS$ is an infinite state sequence:
        \[ \pi=s_0s_1\dots \textrm{ such that } s_{i+1}\in Post(s_i) \textrm{ for all } i\geq0 \]
        \item A \emph{path} of $TS$ is an initial, maximal path fragment
        \begin{itemize}
            \item a \emph{maximal} path fragment is either finite ending in a terminal state or infinite
            \item a path fragment ist \emph{initial} if $s_0\in I$
            \item $Paths(s)$ is the set of maximal path fragments $\pi$ with $first(\pi)=s$
        \end{itemize}
    \end{itemize}
\end{shaded}
\begin{center}
\scalebox{1}{\input{images/semaphore.tikz}}
\end{center}


\subsection*{Traces}
\begin{shaded}
    \begin{itemize}
        \item Let $TS=(S,Act,\to,I,AP,L)$ without terminal states {\tiny all maximal paths (and executions) are infinite}
        \item The \emph{trace} of the infinite path fragment $\pi=s_0s_1\dots$ is $trace(\pi)=L(s_0)L(s_1)\dots$
        \item The \emph{trace} of the finite path fragment $\pi=s_0s_1\dots s_n$ is $(s_n)$
        \item The set of traces of a set $\Pi$ of pahts: $trace(\Pi)=\{ trace(\pi) | \pi\in\Pi \}$
        \item %\hspace*{-2em}
        \begin{align*}
        Traces(s)&=trace(Paths(s)) & Traces(TS)&=\bigcup_{s\in I} Traces(s) \\
        Traces_{fin}(s)&=trace(Paths_{fin}(s)) & Traces_{fin}(TS)&=\bigcup_{s\in I} Traces_{fin}(s)
        \end{align*}
    \end{itemize}
\end{shaded}
\paragraph*{Example}
$AP=\{ crit_1,crit_2 \}$
\begin{align*}
\textrm{path:} & & %\qquad
\pi = &
    \langle n_1,n_2,y=1 \rangle \to
    \langle w_1,n_2,y=1 \rangle \to
    \langle c_1,n_2,y=0 \rangle \to \\
    & & &
    \langle n_1,n_2,y=1 \rangle \to
    \langle n_1,2_2,y=1 \rangle \to
    \langle n_1,c_2,y=0 \rangle \to \dots \\
\textrm{trace:} & & % \qquad
trace(\pi) = &
    \varnothing\varnothing \{crit_1\}\varnothing\varnothing\{crit_2\}\varnothing\varnothing \{crit_1\}\varnothing\varnothing\{crit_2\}\dots
\end{align*}

\subsubsection*{Linear Time Properties for Transition Systems}
\begin{shaded}
    \begin{itemize}
        \item for a given $TS$ a linear time property $\Pi$ over $AP$ is a subset of the set of all infinite strings formed over subset of $AP$: $\Pi\subseteq(2^{AP})^\omega$
        \item $\Pi$ specifies the set of all admissible observable behaviour of the system
        \item satisfaction: $TS\models S \textrm{ iff } Traces(TS) \subseteq \Pi$
        \item notation: state $s\in S$ satisfies $\Pi$, written as $s\models \Pi$, iff $Traces(s)\subseteq\Pi$
    \end{itemize}
\end{shaded}

\subsubsection*{Trace Equivalence}
\begin{itemize}
    \item Let $TS$ and $TS'$ be two transition systems over $AP$ without terminal state
    \begin{description}
        \item[trace inclusion] $Traces(TS\red\subseteq Traces(TS')$ iff for \red{any} $LT$ property $P:\;TS\models P \textrm{ \red{implies} } TS'\models P$
        \item[trace equivalence] $Traces(TS\red= Traces(TS')$ iff $TS$ and $TS'$ satisfy the \red{same} $LT$ properties
    \end{description}
    \item i.e. there is \emph{no LT property} that can distinguish between $TS$ and $TS'$ \follows $TS$ and $TS'$ are trace equivalent
\end{itemize}

\subsubsection*{Invariant $LT$ properties}
\begin{itemize}
    \item Properties over $AP$ that hold for all rechable states, including the initial state (e.g. mutual exclusion, deadlock freedom)
    \item
    \begin{shaded}
        An $LT$ property $P_{inv}$ over $AP$ is called an \emph{invariant} if there is a propositional formula $\psi$ over $AP$ such that
        \[ P_{inv} = \{ A_0,A_1,\dots\in (2^{AP})^\omega | (\forall j\geq0)(A_j\models\psi) \} \]
        $\psi$ is then referred to as the \emph{invariant condition} for invariant $P_{inv}$
    \end{shaded}
    \begin{tabular}[t]{ll}
    $TS\models P_{inv}$ & \\
    & iff $trace(\pi)\in P_{inv}\forall \; \pi \; in \; TS$ \\
    & iff $L(s)\models\psi\forall$ states $s$ that belong to a path of $TS$ \\
    & iff $L(s)\models\psi\forall$ states $s\in Reach(TS)$
    \end{tabular}
    \item Model Checking Invariants
    \begin{itemize}
        \item perform systematic forward search
        \begin{description}
            \item[depth first search] \textsc{Dfs}
            \item[breadth first search] \textsc{Bfs}
        \end{description}
        \item alternative: backwards search
        \begin{itemize}
            \item compute all states violating invariant condition $\psi$
            \item starting here, compute $Pre=\bigcup_{S\in\mathcal{S},S\not\models\psi}Pre^*(s)$
            \item Check if $Pre$ contains an initial state
        \end{itemize}
        \item Time complexity of \textsc{Dfs}: $\mathcal{O}(N\times(|\Phi|+1)+M)$
        \begin{itemize}
            \item $N$: number of reachable states
            \item $(|\Phi|+1)$ length of formula
            \item $M=\sum_{s\in\mathcal{S}}|Post(s):$ number of transitions in the reachable part of $TS$
        \end{itemize}
        \follows time complexity of \textsc{Dfs} is linear
    \end{itemize}
    \item Computation and representation of successor states:
    \begin{description}
        \item[explicit state model checking]
        \begin{itemize}
            \item successor states are implicitly given (program graph, Promela code, \dots)
            \item $Post(s)$ is typically stored as adjacency list
            \item successor states are explicitly computet (state vectors)
        \end{itemize}
        \item[symbolic model checking]
        \begin{itemize}
            \item $Post(s)$ is represented symbolically (binary decision diagrams (BDD))
            \item reachability computation is fixed point computation
        \end{itemize}
    \end{description}
\end{itemize}

\section*{Safety and Liveness}
According to Leslie Lamport
\begin{description}
    \item[safety:] something bad will never happen
    \item[liveness:] something good will eventually happen
\end{description}
\begin{itemize}
    \item Property $P$ corresponds to a language
    \begin{itemize}
        \item $P\subseteq (2^{AP})^*:$ the property is finitary
        \item $P\subseteq (2^{AP})^\omega:$ the property is infinitary
    \end{itemize}
    \item often convenient to express property by $\omega$-regular expressions
\end{itemize}

\subsection*{Safety Properties}
\begin{shaded}
    \begin{itemize}
        \item An LT property $P_{safe}$ is a \emph{safety property}, iff $\forall\sigma\in(2^{AP})^\omega\setminus P_{safe}$ there exists a finite prefix $\hat\sigma$ of $\sigma$ such that $P_{safe}\cap\{ \sigma'\in(2^{AP})^\omega | \hat\sigma \textrm{ is a prefix of } \sigma' \}=\varnothing$ \\{\tiny If we violate the safety property, there is no way to fix it. OR: Violation can be confirmed by a finite prefix.}
        \item $\hat\sigma$ is called a \emph{bad prefix} of $P_{safe}$, and we let $BadPref(P_{safe})$ denote the set of all bad prefixes of $P_{safe}$.
        \item $\hat\sigma$ is a \emph{minimal bad prefix} for $P_{safe}$ iff $\hat\sigma\in BadPref(P_{safe})$ and no proper prefix of $\hat\sigma$ is in $BadPref(P_{safe})$.
        \item Any invariant is a safety property. There are safety properties, that are not invariants.
        \item For a transition system $TS$ without final states and safety property $P_{safe}$ the following holds: \[ TS\models P_{safe} \textrm{ iff } Traces_{fin}(TS)\cap BadPref(P_{safe})=\varnothing \]
        \item The \emph{closure} of an $LT$ property $P$ is defined as: \[ closure(P)=\{ \sigma\in(2^{AP})^\omega | pref(\sigma) \subseteq pref(P) \} \]
        {\tiny This denotes the set of all infinite traces whose finite prefixes are also prefixes of $P$ Example: $closure(a^+b^\omega)=a^\omega+a^+b^\omega$}
        \item $P$ is a safety property iff $closure(P)=P$
    \end{itemize}
\end{shaded}
\begin{itemize}
    \item Finite traces and safety properties:
    \begin{itemize}
        \item $Traces_{fin}(TS)\subseteq Traces_{fin}(TS') \textrm{ iff for any safety property } P_{safe}:\ TS'\models P_{safe} \Rightarrow TS \models P_{safe}$
        \item $Traces_{fin}(TS)\subseteq Traces_{fin}(TS')$ iff $TS$ and $TS'$ satisfy the same set of safety properties
        \item for $TS$ without terminals states and finite $TS'$ the following holds: \[ Traces(TS) \subseteq Traces(TS') \iff Traces_{fin}(TS) \subseteq Traces_{fin}(TS') \]
        \item trace inclusion $\not=$ finite trace inclusion
    \end{itemize}
\end{itemize}

\subsection*{Liveness Properties}
Safety properties can be satisfied by never doing anything. \follows We want some property that ensures something will happen eventually.
\begin{shaded}
    An $LT$ property $P_{live}$ over $AP$ is a \emph{liveness} property whenever $pref(P_{live})=(2^{AP})^*$ \\
    {\tiny \follows Any finite computation can be extended to an execution satisfying the property.}
\end{shaded}

\subsection*{Safety and Liveness component}
Many properties are not pure, but a combination of safety and liveness properties.
\begin{itemize}
    \item let $S$ denote an atomic predicate that holds in a ``sent'' state, and let $R$ denote an atomic predicate that holds in a ``received'' state.
    \item let $S,R\in \Sigma$\qquad {\tiny $\Sigma$ is the alphabet}
    \item Property: when a message has been ``sent'' eventually it will be ``received'': \[ \Pi=S^*R\Sigma^\omega \]
    \item \begin{align*}
    \Pi & \not= closure(\Pi) \\
    &= S^\omega\cup S^*R\sigma^\omega \\
    &= \Pi_s
    \end{align*}
    We call $\Pi_s$ the \emph{safety closure} of $\Pi$
    \item decomposition into safety and liveness property:
    \begin{description}
        \item[liveness:] $\Pi_l$ eventually $R$ will hold: $\Pi_l=\Sigma^* R\Sigma^\omega$
        \item[safety:] $\Pi_s = closure(\Pi)$
        \item[will hold:] $\Pi=\Pi_s\cap\Pi_l=(S^\omega\cup S^*R\Sigma^\omega)\cap(\Sigma^* R \Sigma^\omega)$
    \end{description}
    \item Safety and Liveness properties are \emph{disjoint} except for the trivial property $\Sigma^\omega$
    \item Every property $\Pi$ can be represented as the \emph{intersection}: $\Pi=\Pi_s\cap\Pi_l$
    \item let $\Pi$ be a infinitary and $\Phi$ be an finitary property
    \begin{itemize}
        \item $PREF(\Pi)$ denotes the set of all finite prefixes of $\Pi$
        \item $A(\Phi)$ corresponds to all infinite $\sigma\in\Sigma^\omega$ so that all finite prefixes of $\sigma$ are in $\Phi$ \[ \textrm{Example: } \Phi=a^+b^*\Rightarrow \underset{(closure)}{A(\Phi)}=a^\omega+a^+b^\omega \]
        \item $E(\Phi)$ consists of all infinite $\sigma\in\Sigma^\omega$ so that there exists a prefix of $\sigma$ that belongs to $\Phi$ \[ \textrm{Example: } \Phi=a^+b^*\Rightarrow E(\Phi)=a^+b^*\cdot \Sigma^\omega \] \\
        \vspace*{-4em} {\tiny Note: for every finite property $\Phi: E(\Phi)=\Phi\cdot\Sigma^\omega$}
    \end{itemize}
    \item Other Classifications:
    \begin{itemize}
        \item topological \follows safety (closed sets), liveness (dense sets)
        \item temporal logic
        \item automata theoretic
    \end{itemize}
    \item Safety/Liveness is intuitive:
    \begin{itemize}
        \item checking safety properties: simple exploration of all states
        \item checking liveness property: exploration of all states, checking in every state whether any continuation of prefix will satisfy property
    \end{itemize}
\end{itemize}

\section*{Fairness}
Fairness ensures, that each process wanting to do something at one point will eventually be able to do so.
\paragraph*{Types of Fairness}
\begin{description}
    \item[unconditional fairness:] an activity is executed \emph{infinitely often}
    \item[strong fairness:] if an activity is \emph{infinitely often enabled}, it will \emph{infinitely often be executed}
    \item[weak fairness] if an activity is \emph{continuously enabled}, it will \emph{infinitely often be executed}
\end{description}
\begin{itemize}
    \item Fairness violations often occur due to an unjustifiedly high level of abstraction (e.g. one process indefinitely faster than other)
    \item or due to unjustified assumptions about environment behaviour
\end{itemize}
\begin{shaded}
    For $TS=(S,Act,\to,I,AP,L)$ without terminal states, $A\subseteq Act$, and infinite execution fragment $\rho=s_0\overset{\alpha_0}{\longrightarrow}s_1\overset{\alpha_1}{\longrightarrow}\dots$ of $TS$ {\tiny where $Act(s) = \left\{ \alpha\in Act | \exists s' \in S. s\overset{\alpha}{\longrightarrow}s'\right\}$}
    \begin{enumerate}
        \item $\rho$ is \emph{unconditionally $A$-fair} whenever: $true\Rightarrow \underset{\textrm{infinitely often } A\textrm{ is taken}}{\underbrace{\forall k\geq0.\exists j\geq k.\alpha_j\in A}}$
        \item $\rho$ is \emph{strongly $A$-fair} whenever: $\underset{\textrm{infinitely often } A\textrm{ is enabled}}{\underbrace{(\forall k\geq0.\exists j\geq k.Act(s_j)\cap A\not=\varnothing)}}\Rightarrow \underset{\textrm{infinitely often } A\textrm{ is taken}}{\underbrace{\forall k\geq0.\exists j\geq k.\alpha_j\in A}}$
        \item $\rho$ is \emph{weakly $A$-fair} whenever: $\underset{\textrm{infinitely often } A\textrm{ is enabled}}{\underbrace{(\exists k\geq0.\forall j\geq k.Act(s_j)\cap A\not=\varnothing)}}\Rightarrow \underset{\textrm{infinitely often } A\textrm{ is taken}}{\underbrace{\forall k\geq0.\exists j\geq k.\alpha_j\in A}}$
    \end{enumerate}
\end{shaded}

\subsection*{Which Fairness Notion to Use?}
Fairness filters out ``unreasonable'' runs (may be too strong, unfair)
\begin{itemize}
    \item Too Strong? \follows relevant computations may be ruled out, verification yields:
    \begin{description}
        \item[\red{false}:] error found
        \item[\dGreen{true}:] may still be false, if relevant executions may be considered ``unfair''
    \end{description}
    \item Too Weak? \follows too many computations considered, verification yields:
    \begin{description}
        \item[\dGreen{true}:] property holds
        \item[\red{false}:] may still be true, if violating run was unfair
    \end{description}
    \item Relationship: unconditional \follows strong \follows weak
\end{itemize}

\subsection*{Fairness Assumptions}
\begin{shaded}
    A \emph{fairness assumption} for $Act$ is a triple \[ \mathcal{F}=(\mathcal{F}_{uncond},\mathcal{F}_{strong},\mathcal{F}_{weak}) \] with $\mathcal{F}_{ucond},\mathcal{F}_{strong},\mathcal{F}_{weak}\subseteq 2^{Act}$
    \begin{itemize}
        \item unconditionally $A$-fair \emph{for all} $A\in\mathcal{F}_{ucond}$
        \item stongly $A$-fair \emph{for all} $A\in\mathcal{F}_{strong}$
        \item weakyl $A$-fair \emph{for all} $A\in\mathcal{F}_{weak}$
    \end{itemize}
    e.g. $(\varnothing,\mathcal{F}',\varnothing)$ denotes strong fairness
\end{shaded}
\begin{itemize}
    \item A Path $s_o\to s_1\to s_2\to\dots$ is $\mathcal{F}$-fair, if
    \begin{itemize}
        \item there exists an $\mathcal{F}$-fair execution $s_0\overset{\alpha_0}{\longrightarrow}s_1\overset{\alpha_1}{\longrightarrow}\dots$
        \item $FairPaths_\mathcal{F}(s)$ denotes the set of $\mathcal{F}$-fair paths that start in $s$
        \item $FairPaths\mathcal{F}(TS)=\bigcup_{s\in I} FairPaths\mathcal{F}(s)$
    \end{itemize}
    \item Trace $\sigma$ is $\mathcal{F}$-fair if there exists an $\mathcal{F}$-fair execution $\rho$ with $trace(\rho)=\sigma$
    \begin{itemize}
        \item $FairTraces_\mathcal{F}(s)=trace(FairPaths_\mathcal{F}(s))$
        \item $FairTraces_\mathcal{F}(TS)=trace(FairPaths_\mathcal{F}(TS))$
    \end{itemize}
    \item $TS$ \emph{satisfies} $LT$-property $P$: \[ TS\models P \textrm{ iff } Traces(TS)\subseteq P \]
    \item $TS$ \emph{fairly satisfies} $LT$-property $P$ wrt. fairness assumption $\mathcal{F}$: \[ TS\models_\mathcal{F} P \textrm{ iff } FairTraces_\mathcal{F}(TS)\subseteq P \]
\end{itemize}

\subsection*{Fairness and Safety}
\begin{itemize}
    \item for $TS$ with set of Actions $Act$ and fairness assumption $\mathcal{F}$ for $Act$, $\mathcal{F}$ is defined as \emph{realizable} for $TS$ if for any $s\in Reach(TS):$ \[ FairPaths_\mathcal{F}(s)\not=\varnothing \]
    \item for $TS$ and safety property $P_{safe}$ over $AP$ and $\mathcal{F}$ a realizable fairness assumption for $TS$ the following holds true: \[ TS\models P_{safe} \textrm{ iff } TS\models_\mathcal{F}P_{safe} \] {\tiny i.e. safety properties are preserved by realizable fairness assumption, non-realizable fairness assumptions may harm safety properties}
\end{itemize}

\section*{Model Checking Regular Safety Properties}
\begin{shaded}
A safety property $P_{safe}$ is \emph{regular} if
\begin{itemize}
    \item $BadPref(P_{safe})$ is a regular language.
    \item there exists a finite automaton over $2^{AP}$ recognizing $BadPref(P_{safe})$
\end{itemize}
\end{shaded}
\begin{itemize}
    \item $bp(P_{safe} \equiv BadPref(P_{safe})$
    \item $mbp(P_{safe})$ \follows set of minimal bad prefixes for $P_{safe}$
    \item not regular safety properties: something to do with counting
\end{itemize}

\subsection*{Regular Languages}
\begin{shaded}
    A \emph{nondeterministic finite automaton} \textsc{Nfa} $\mathcal{A}$ is a tuple $(Q,\Sigma,\delta,Q_0,F)$ where
    \begin{itemize}
        \item $Q$ is a finite set of states
        \item $\Sigma$ is an alphabet
        \item $\delta:\ Q\times\Sigma\to2^Q$ is a transition function (nondeterministic)
        \item $Q_0\subseteq Q$ a set of initial states
        \item $F\subseteq Q$ is a set of accept (or: final) states
    \end{itemize}
    assume word $w=A_1\dots A_n\in\Sigma^*$
    \begin{itemize}
        \item A \emph{run} for $w$ in $\mathcal{A}$ is a finite sequence $q_0q_1\dots q_n$ such that:
        \[ q_0\in Q_0 \textrm{ and } q_1\overset{A_{i+1}}{\longrightarrow} q_{i+q} \textrm{ for all } 0\leq i < n \]
        \item Run $q_0q_1\dots q_n$ is \emph{accepting} if $q_n\in F$
        \item $w\in\Sigma^*$ is \emph{accepted} by $\mathcal{A}$ if there exists an accepting run for $w$.
        \item The \emph{accepted language} of $\mathcal{A}$: \[ \mathcal{L}(\mathcal{A})=\{ w\in\Sigma^* | \textrm{ there exists an accepting run for } w \textrm{ in } \mathcal{A} \} \]
        \item \textsc{Nfa} $\mathcal{A}$ and $\mathcal{A}'$ are \emph{equivalent} if $\mathcal{L}(\mathcal{A})=\mathcal{L}(\mathcal{A}')$
    \end{itemize}
\end{shaded}

\subsection*{Synchronous Product}
\begin{shaded}
\begin{multicols}{2}
For transition system $TS=(S,Act,\to,I,AP,L)$ without terminal states and $\mathcal{A}=(Q,\Sigma,\delta,Q_0,F)$ and \textsc{Nfa} with $\Sigma=2^{AP}$ and $Q_0\cap F=\varnothing$, let:
    \[ TS \otimes\mathcal{A}=(S',Act,\to',I',AP',L') \]
    where
    \begin{itemize}
        \item $S'=S\times Q$, $AP'=Q$ and $L'(\langle s,q \rangle) = \{ q \}$
        \item $\to'$ is the smallest relation defined by
        $\displaystyle \frac{
            s\overset{\alpha}{\longrightarrow}\red{t} \wedge q \overset{L(\red{t})}{\longrightarrow} p
        }{
        \langle s,q \rangle \overset{\alpha}{\longrightarrow}' \langle \red{t},p \rangle
        }$
        \item $I'=\{ \langle s_0,q \rangle | s_0\in I\wedge \exists q_0\in Q_0. q_0 \overset{L(s_0)}{\longrightarrow} q\}$
    \end{itemize}
    without loss of generality it may be assumed that $TS\otimes\mathcal{A} has no terminal states$
\columnbreak
\begin{center}
\scalebox{0.5}{\input{images/syncProd.tikz}}
\end{center}
\end{multicols}
\end{shaded}

\subsection*{Properties of \textsc{Nfa}}
\begin{itemize}
    \item They are as expressive as regular languages
    \item They are closed unter $\cap$ and \emph{complementation}
    \begin{itemize}
        \item \textsc{Nfa} $\mathcal{A}\otimes B$ (=cross product) accepts $\mathcal{L}(\mathcal{A})\cap\mathcal{L}(\mathcal{B})$
        \item Total \textsc{Dfa} $\overline{\mathcal{A}}$ (=swap all accept and normal states) accepts $\overline{\mathcal{L}(\mathcal{A})}=\Sigma^*\setminus\mathcal{L}(\mathcal{A})$
    \end{itemize}
    \item They are closed under \emph{determinization} (=removal of choice) {\tiny (although exponentially more runtime)}
    \item $\mathcal{L}(\mathcal{A}=\varnothing$ \follows check for a reachable accept state in $\mathcal{A}$ \follows simple \textsc{Dfs}
    \item For regular language $\mathcal{L}$ there is a unique minimal \textsc{Dfa} accepting $\mathcal{L}$
\end{itemize}

\subsection*{Model Checking regular safety properties}
\note{Check this with exercise sheet}

\begin{itemize}
    \item let $P_{safe}$ be a regular safety property over $AP$
    \item let $\mathcal{A}$ be an \textsc{Nfa} recognizing the bad prefixes of $P_{safe}$
    \begin{itemize}
        \item assume that $\varepsilon\not\in\mathcal{L}(\mathcal{A})$ (otherwise all finite words over $2^{AP}$ are bad prefixes and $P_{safe}=\varnothing$)
    \end{itemize}
    \item let $TS$ be a finite transition system over $AP$ without terminal states
    \item $TS\models P_{safe}$
    \begin{itemize}
        \item iff $Traces_{fin}(TS)\cap bp(P_{safe})=\varnothing$
        \item iff $Traces_{fin}(TS)\cap \mathcal{L}(\mathcal{A})=\varnothing$
        \item iff $TS\otimes\mathcal{A}\models $ ``always $\Phi$''
        \begin{itemize}
            \item invariant checking \follows  \textsc{Dfs}
        \end{itemize}
        \begin{shaded}
            The following statements are equivalent
            \begin{itemize}
                \item $TS\models P$
                \item $Traces_{fin}(TS)\cap\mathcal{L}(\mathcal{A})=\varnothing$
                \item $TS\otimes\mathcal{A} \models P_{inv(\mathcal{A})}=\bigwedge_{q\in F} \neg q$
            \end{itemize}
            \follows checking safety properties is like checking an invariant
        \end{shaded}
    \end{itemize}
\end{itemize}

\subsection*{Counterexample}
\begin{shaded}
    For each initial path fragment $\langle s_0,q_1\rangle\dots\langle s_n,q_{n+q}$ of $TS\otimes\mathcal{A}:$
    \[
    q_1,\dots q_n\not\in F \textrm{ and } q_{n+1}\in F \Rightarrow \underset{\textrm{bad prefix for } P_{safe}}{\underbrace{trace(s_0s_1\dots s_n)\in\mathcal{L(\mathcal{A})}}}
    \]
\end{shaded}
\input{code/basicmc.tex}

\subsection*{Time Complexity}
\begin{shaded}
    The time and space complexity of checking $TS\models P_{safe}$ is in:
    \[ \mathcal{O} (|TS|\cdot|\mathcal{A}|) \]
    where $\mathcal{A}$ is an \textsc{Nfa} with $\mathcal{L}(\mathcal{A}=mbp(P_{safe})$
\\ The \emph{size} of \textsc{Nfa} $\mathcal{A}$, denoted $|\mathcal{A}|$ is the number of states and transitions in $\mathcal{A}:$
\[ \underset{\textrm{rel. small}}{|\mathcal{A}|} = |Q| + \sum_{q\in Q} \sum_{A}\in\Sigma |\delta(q,A)| \]
\end{shaded}

\section*{B√ºchi Automata \& $\omega$-Regular Languages}
\begin{itemize}
    \item Properties of reacive systems contain liveness elements, need to be described with infinite sequences
    \item Need acceptance of languages of infinite words
\end{itemize}
\subsection*{Regular Expression}
\begin{shaded}
\begin{itemize}
    \item Let $\Sigma$ be an alphabet with $A\in\Sigma$
    \item Regular Expressions over $\Sigma$ have the \emph{syntax}:
    \[ E:=\varnothing \ | \ \varepsilon \ | \ A \ | \ E+E'\ | \ E.E'\ | \ E^* \]
    \item The \emph{semantics} of regular expression $E$ is a language $\mathcal{L}(E)\subseteq \Sigma^*$:
    \begin{align*}
    \mathcal{L}(\varnothing) = \varnothing, \; \mathcal{L}(\varepsilon)=\{\varepsilon\},\; \mathcal{L}(A)=\{A\} \\
    \mathcal{L}(E+E') = \mathcal{L}(E)\cup\mathcal{L}(E') \; \mathcal{L}(E.E')=\mathcal{L}(E).\mathcal{L}(E') \; \mathcal{L}(E^*)=\mathcal{L}(E)^*
    \end{align*}
\end{itemize}
\end{shaded}

\subsection*{$\omega$-Regular Expressions}
\begin{shaded}
\begin{itemize}
    \item denote languages of infinite words
    \item An $\omega$-regular expression $G$ over $\Sigma$ has the form
    \[ G=E_1.F_1^\omega + \dots + E_n.F_n^\omega \quad \textrm{for } n>0 \]
    where $E_i,F_1$ are regular expressions over $\Sigma$ with $\varepsilon \not\in\mathcal{L}(F_i)$
    \item The \emph{semantics} of $G$ is a language $\mathcal{L}(G)\subseteq\Sigma^\omega$:
    \[\mathcal{L}_\omega(G)=\mathcal{L}(E_1).\mathcal{L}(F_1)^\omega \cup\dots\cup \mathcal{L}(E_n).\mathcal{L}(F_n)^\omega \]
    \item $G_1$ and $G_2$ are \emph{equivalent}, denotet $G_1\equiv G_2$, if $\mathcal{L}_\omega(G_1)=\mathcal{L}_\omega(G_2)$
    \item $\mathcal{L}$ is $\omega$-regular if $\mathcal{L}=\mathcal{L}\omega(G)$ for some $\omega$-regular expression $G$.
    \item $\omega$-Regular languages are closed under $\cup,\cap$ and \emph{complementation}
\end{itemize}
\end{shaded}

\subsection*{$\omega$-Regular Properties}
\begin{shaded}
        An $LT$ property $P$ over $AP$ is \emph{$\omega$-regular} if $P$ is an $\omega$-regular language over the alphabet $2^{AP}$
\end{shaded}

\subsection*{Acceptance conditions for words inf $(2^{AP})^\omega$}
\begin{enumerate}
    \item finite acceptance {\tiny (the automaton accepts a prefix of $a\in(2^{AP})^\omega$), \red{does not ensure liveness, note even infiniteness}}
    \item looping acceptance {\tiny (the automaton has an infinite execution when reading the word) \red{does not ensure liveness, as the automaton may do anything}}
    \item repeating acceptance {\tiny (looping acceptance $+$ the set of states that the automaton reaches infinitely often an additional acceptance condition) \dGreen{also called ``B√ºchi acceptance condition''}}
\end{enumerate}

\subsection*{$\omega$-Automata}
\begin{itemize}
    \item Definition as for \textsc{Nfa}
    \item[+] B√ºchi acceptance condition: \emph{An infinite word $a\in(2^{AP})^\omega$ will be accepted by a B√ºchi Automaton iff the automaton reaches at least one of the states in the acceptance set $F$ infinitely often when reading $a$.}
\end{itemize}
\begin{shaded}
    A \emph{nondeterministic B√ºchi automaton} \textsc{Nba} $\mathcal{A}$ is a tuple $(Q,\Sigma,\delta,Q_0,F)$ where:
    \begin{itemize}
        \item $Q$ is a finite set of states with $Q_0\subseteq !$ a set of initial states
        \item $\Sigma$ is an alphabet
        \item $\delta:\ Q\times\Sigma\to2^Q$ is a transition function {\tiny (nondeterministic)}
        \item $F\subseteq Q$ is a set of accept (or final) states
    \end{itemize}
\end{shaded}
\subsubsection*{Language accepted by \textsc{Nba}}
\begin{itemize}
    \item \textsc{Nba} $\mathcal{A}=(Q,\Sigma,\delta,Q_0,F)$ and word $\sigma=A_0A_1A_2\dots\in\Sigma^\omega$
    \item A \emph{run} for $\sigma$ in $\mathcal{A}$ is an \emph{in}finite sequence $q_0q_1q_2\dots$ such that:
    \[ q_0\in Q_0 \textrm{ and }  \underset{\delta \textrm{ of the \textsc{Nba}}}{\underbrace{q_i \overset{A_{i+1}}{\longrightarrow} q_{i+1}}} \textrm{ for all } 0\leq i \]
    \item Run $q_0q_1q_2\dots$ is \emph{accepting} if $q_i\in F$ for \emph{infinitely} many $i$
    \item $\sigma\in\Sigma^\omega$ is \emph{accepted} by $\mathcal{A}$ if there exists an accepting run for $\sigma$
    \item The \emph{accepted language} of $\mathcal{A}$:
    \[ \mathcal{L}_\omega(\mathcal{A})=\{ \sigma\in\Sigma^\omega | \textrm{ there exists an accepting run for } \sigma \textrm{ in } \mathcal{A}\} \]
    \item \textsc{Nba} $\mathcal{A}$ and $\mathcal{A}'$ are \emph{equivalent} if $\mathcal{L}_\omega(\mathcal{A})=\mathcal{L}_\omega(\mathcal{A}') $
\end{itemize}
\subsubsection*{More facts about B√ºchi Automata}
\begin{itemize}
    \item assume: the final state will be repeatet infinitely often
    \item finite equivalence $\not\Rightarrow\;\omega$-quivalence
    \item $\omega$-equivalence $\not\Rightarrow$ finite equivalence
    \item The class of languages accepted by \textsc{Nba} is \emph{identical} to the class of $\omega$-regular languages
    \item A B√ºchi automaton is \emph{deterministic}, if $|Q_0|\leq 1$ and $|\delta(q,A)|\leq1$ for all $q\in Q$ and $A\in\Sigma$ \\
    \textsc{Nba} and \textsc{Dba} are note equally expressive \follows \textsc{Nba} are more expressive \follows need for nondeterminism
    \item There is no canonic representation for \textsc{Nba} \follows there is no minimal \textsc{Nba} for a given $\omega$-regular language
    \item alternative: ``Muller, Rabin and Streett automata'' with deterministic/nondeterministic variants \follows same expressivenes as \textsc{N/Dba}
    \item Generalized Nondeterministic B√ºchi Automaton \textsc{GNba}:
    \begin{itemize}
        \item acceptance condition expressed in terms of a set $\mathcal{F}$ consisting of sets $F_1,\dots,F_k$ with $F_i\subseteq Q$
        \item \textsc{GNba} accepts a word, if it visits all sets $F_i$ infinitely often
    \end{itemize}
\end{itemize}

\section*{Linear Temporal Logic \textsc{Ltl}}
\begin{itemize}
    \item B√ºchi automata use operational approach, want to have Logic for the description of temporal requirements
    \item first order logic quite complicated for this
    \item[\follows] need explicit quantification over state sequences
    \item modalities:
    \begin{tabular}[t]{rll}
    $Lp:$ & it is necessary, that $p$ & {\tiny for all visible worlds $p$}\\
    $Mp:$ & it is possible, that $p$ & {\tiny there exists a visible world with $p$}\\
    $\neg Lp:$ & it is not necessary, that $p$ & %{\tiny there does not need to be a visible world with $p$}
    \\
    $\neg Mp:$ & it is not possible, that $p$ & %{\tiny there may be a world, with $p$}
    \end{tabular}
    \item Formulae of Modal Logic:
    \begin{itemize}
        \item $p$ is a formula
        \item if $\Phi$ is a formula, then $\neg\Phi$ is a formula
        \item if $\Phi$ and $\rho$ are formulae, then $\Phi\wedge\rho, \Phi\supset\rho \textrm{ (\tiny implication)}, \Phi\equiv\rho, L\Phi, M\Phi$ are formulae
    \end{itemize}
    \item \begin{shaded}
        Let $\Pi$ a set of atomic propositions. Further let
        \begin{itemize}
            \item $W$ a set of worlds
            \item $R\subseteq W\times W$ a visibility relation on worlds
            \item $A: W\times\Pi\to \{true,false\}$ a truth value assignement
        \end{itemize}
        then we call $(W,R,A)$ a \emph{model} or \emph{Kripke-Structure}
    \end{shaded}
\end{itemize}
\subsection*{Model-theoretic Semantics of Modal Logic}
\begin{shaded}
    Let
    \begin{itemize}
        \item $M=(W,R,A)$ a Kripke-structure
        \item $\Pi$ a set of atomic propositions and $p\in\Pi$
        \item $w$ and $v\in w$
        \item $\Phi$ and $\rho$ formulae
    \end{itemize}
    then we define the relation $\models$ for $M$:
    \begin{align*}
    (M,w) & \models p               & iff \; A(w,p) & = true  \\
    (M,w) & \models \neg p          & iff \; A(w,p) & = false \\
    (M,w) & \models \Phi\wedge\rho  & iff \; (M,w)  & \models \Phi \textrm{ and } (M,w) \models \rho \\
    (M,w) & \models L\Phi           & iff \; (\forall v: (w,v) & \in R)((M,v)\models\Phi) \\
    (M,w) & \models M\Phi           & iff \; (\exists v:(w,v) & \in R)((M,v)\models\Phi)
    \end{align*}
    Further we define:
    \begin{align*}
    \Phi \vee \rho  & \cong \neg(\neg\Phi\wedge\neg\rho) \\
    \Phi\supset\rho & \cong \neg\Phi\vee\rho \\
    \Phi\equiv\rho  & \cong (\Phi\supset\rho)\wedge(\Phi\subset\rho) \\
    M\Phi           & \cong \neg L\neg\Phi
    \end{align*}
    Axiomatisation:
    \begin{multicols}{2}
    \begin{enumerate}
        \item $(\Phi\vee\Phi)\supset\Phi$
        \item $\rho\supset(\Phi\vee\rho)$
        \item $(\Phi\vee\rho)\supset(\rho\supset\Phi)$
        \item $(\Phi\supset\rho)\supset((\rho\vee\Phi)\supset(\sigma\vee\rho))$
        \item $L\Phi\supset\Phi$
        \item $L(\Phi\supset\rho)\supset(L\Phi\supset L\rho)$
        \item $L\Phi\supset LL\Phi$
        \item $M\Phi\supset LM\Phi$
    \end{enumerate}
    \end{multicols}
    We call a formula $\Phi$ a \emph{theorem} if it can be derived from the axioms, notation: $\vdash \Phi$
    \begin{enumerate}
        \item $\vdash\Phi$ and $\vdash(\Phi\supset\rho)$ imply $\vdash\rho$ (modus ponens)
        \item $\vdash\Phi$ implies $\vdash L\Phi$
    \end{enumerate}
\end{shaded}
\subsection*{Temporal Interpretation of Modal Logic}
\begin{itemize}
    \item worlds correspond to system states
    \item visibility relation corresponds to sequences of system states
    \begin{itemize}
        \item system sees its current state \follows reflexivity
        \item state $s_3$ follows $s_2$ and $s_2$ follows $s_1$, then $s_3$ follows $s_1$ \follows transitivity
    \end{itemize}
    \item linear time temporal logic \textsc{Ltl}:
    \begin{multicols}{2}
    \begin{itemize}
        \item reflexivity
        \item transitivity
        \item connectivity
        \item discreteness
    \end{itemize}
    \end{multicols}
\end{itemize}
\subsection*{satisfiability and Validity}
\begin{itemize}
    \item $p$ is \emph{state-satisfiable} if there is a state so that $s\models p$
    \item $p$ is \emph{state-valid} if $s\models p$ for all states $s$
\end{itemize}
\subsection*{Linear Temporal Logic \textsc{Ltl}}
$p,q$ are formulae, the folowing are fomulae:
\begin{itemize}
    \item $\circ p$ (next)
    \item $\diamond$ (eventually)
    \item $\square$ (always)
    \item $p \mathcal{U}q$ (until)
    \item $p \mathcal{W}q$ (unless/weak until) {\tiny either once $q$ or always $p$}
\end{itemize}
\subsubsection*{Satisfaction}
given a state sequence (model) $\sigma$ and formula $p$
\begin{itemize}
    \item $p$ \emph{holds at position $i$} of sequence $\sigma$ iff \[ (\sigma,i) \models p \] we write $\sigma\models p$
\end{itemize}
\subsubsection*{Validity}
a formula $p$ is \emph{valid}, iff \[ (\forall\sigma)(\sigma\models p) \] we write $\models p$
\subsubsection*{Finite Model Property}
\textsc{Ltl} has the finite model property, there are only $4$ distinct temporal modalities \\
$\square p, \diamond p, \square\diamond p, \diamond\square p$ \\
$\square\square\diamond p\equiv\square\diamond p, \square\diamond\square\diamond p\equiv\square\diamond p$
\subsection*{\textsc{Ltl}-example}
\begin{itemize}
    \item $\square(p\to\diamond q)\cong p\leadsto q$ ``response-property'', ``p leads-to q''
    \item ``between process A updating a value and process B reading the cache, the value must be flushed from A's cache''
    \[ \square((UpdateA\wedge\diamond ReadB)\to(\neg ReadB \mathcal{U}FlushA)) \]
\end{itemize}
\begin{multicols}{2}
\subsection*{Property Expansion}
\begin{itemize}
    \item $\square p \Leftrightarrow (p\wedge\circ\neg p)$
    \item $\diamond p\Leftrightarrow(p\vee\circ\diamond p)$
    \item $p \mathcal{U}q\Leftrightarrow(q\vee[p\wedge\circ(p \mathcal{U}q)])$
    \item $p \mathcal{W}q\Leftrightarrow(q\vee[p\vee\circ(p \mathcal{W})])$
\end{itemize}
\subsection*{Dualitites}
\begin{itemize}
    \item $\neg\square p \Leftrightarrow\diamond\neg p$
    \item $\neg\diamond p \Leftrightarrow\square\neg p$
    \item $\neg(p \mathcal{U}q)\Leftrightarrow(\neg q)\mathcal{W}(\neg p\wedge\neg q) $
    \item $\neg(p \mathcal{W} q)\Leftrightarrow(\neg q)\mathcal{U}(\neg p\wedge\neg q) $
    \item $\neg\circ p\Leftrightarrow \circ\neg p$
\end{itemize}
\subsubsection*{Strong and Weak Operators}
\begin{itemize}
    \item $p \mathcal{U}q\Leftrightarrow(p \mathcal{W} q \wedge\diamond q) $
    \item $p \mathcal{W}q\Leftrightarrow(p \mathcal{U} q \wedge\square q) $
    \item $p \mathcal{U}q\Rightarrow p \mathcal{W}q $
\end{itemize}
\subsubsection*{Indempotence}
Two-fold application yields result identical to single application:
\begin{itemize}
    \item $\square\square p \Leftrightarrow\square p$
    \item $\diamond\diamond p\Leftrightarrow\diamond p$
    \item $p \mathcal{U}(p \mathcal{U}q) \Leftrightarrow p \mathcal{U}q$
    \item $p \mathcal{W}(p \mathcal{W}q) \Leftrightarrow p \mathcal{W}q$
    \item $(p \mathcal{U}q)\mathcal{U}q \Leftrightarrow p \mathcal{U}q$
    \item $(p \mathcal{W}q)\mathcal{W}q \Leftrightarrow p \mathcal{W}q$
\end{itemize}
\subsubsection*{Absorption}
\begin{itemize}
    \item $\diamond\square\diamond p\Leftrightarrow \square\diamond p$
    \item $\square\diamond\square p\Leftrightarrow \diamond\square p$
\end{itemize}
Absorption and Indempotence also lead to only $4$ different unary modalities (compare finite-model property):
\[ \square p,\diamond p,\square\diamond p,\diamond\square p \]
\subsubsection{Commutativity of the next-operator}%$\circ$}
\begin{itemize}
    \item $\circ(\neg p)\Leftrightarrow\neg\circ p$
    \item $\circ(p\vee q)\Leftrightarrow\circ p\vee\circ q$
    \item $\circ(p \mathcal{W}q)\Leftrightarrow\circ p \mathcal{W}\circ q$
\end{itemize}
\subsection*{Distribution of Temporal Operators}
\begin{itemize}
    \item $\square(p\wedge q)\Leftrightarrow\square p\wedge\square q$
    \item $\diamond(p\vee q)\Leftrightarrow\diamond p\vee \diamond q$
    \item $\square\diamond(p\vee q)\Leftrightarrow\square\diamond p\vee\square\diamond q$
    \item $\diamond\square(p\wedge q)\Leftrightarrow\diamond\square p\wedge\diamond\square q$
\end{itemize}
\subsection*{Possible Base set of Operators}
$\circ, \mathcal{W}\neg$, derived operators:
\begin{itemize}
    \item $\square p = p \mathcal{W} false$
    \item $\diamond p=\neg\square\neg p=\neg(\neg p \mathcal{W}false)$
    \item $p \mathcal{U}q=p \mathcal{W}q \wedge \diamond q = p \mathcal{W}q \wedge\neg(\neg \mathcal{W}false)$
\end{itemize}
\subsubsection*{Possible Axiomatisation}
\begin{itemize}
    \item $\square p\to p$
    \item $\circ\neg p\Leftrightarrow\neg\circ p$
    \item $\circ(p\to q)\Leftrightarrow(\circ p\to\circ q)$
    \item $\square(p\to q)\Leftrightarrow(\square p \to \square q)$
    \item $\square p\to\square\circ p$
    \item $(p\Rightarrow\circ p)\to(p\Rightarrow\square p)$
    \item $p \mathcal{W}q\Leftrightarrow[q\vee(p\wedge\circ(p \mathcal{W}q))]$
    \item $\square p\Rightarrow p \mathcal{W}false$
\end{itemize}
\end{multicols}
\subsection*{Safety-Progess Classification}
\begin{itemize}
    \item Temporal Logic Property Classes
    \begin{itemize}
        \item classification based on syntactic form of formulae
        \item A property $\Pi\subseteq\Sigma^\omega$ will be specified by temporal logic formula $\Phi$ if $\Phi$ is defined over the state vocabulary $\Sigma$ and the following condition holds:
        \[ \sigma\in\Pi \quad \textrm{iff} \quad \sigma\models\Phi \]
        \item hence, $\Phi$ describes a decision mechanism determining whether a state sequence belongs to the set of valid executions of a system
    \end{itemize}
    \item alternative (Manna and Pnueli)
    \begin{itemize}
        \item orthigonal to safety-liveness classification
        \item classes:
        \begin{multicols}{2}
        \begin{itemize}
            \item safety $\square p$
            \item guarantee $\diamond p$
            \item obligation $\diamond p\to\diamond q$ oder $\square\vee\diamond q$
            \item response $\square\diamond p$
            \item persistence $\diamond\square p$
            \item reactivity $\square\diamond p\vee\diamond\square q$
        \end{itemize}
        \end{multicols}
        \item Temporal Logic Specification Patterns:
        \url{http://www.cis.ksu.edu/santos/spec-patterns/index.html}
        \item Scopes used in Specification Patterns
        \begin{center}
        \scalebox{.7}{\input{images/scopes.tikz}}
        \end{center}
    \end{itemize}
\end{itemize}

\section*{B√ºchi Automata and \textsc{Ltl}}
Relationship of B√ºchi-Automata and \textsc{Ltl}
\begin{itemize}
    \item B√ºchi-Automata more expressive.
    \begin{itemize}
        \item \textsc{Ltl} can not count
    \end{itemize}
    \item \begin{tabular}{llcl}
    \textsc{Etl} & Not counter-free B√ºchi-Automata & $\approx$ & $\omega$-regular languages \\
    \textsc{Ltl} & Counter-free B√ºchi-Automata & $\approx$ & $^*-free \omega$-regular languages
    \end{tabular}
\end{itemize}
\subsection*{\textsc{Ltl} to B√ºchi-Automaton Translation}
\begin{itemize}
    \item \textsc{Ltl} often more abstract / easier than to directly specify as B√ºchi-Automata
    \item next-operator free \textsc{Ltl} specified properties are guaranteed to be stutter invariant \follows Partial Order Reduction
\end{itemize}
\subsubsection*{Overview}
\begin{itemize}
    \item synthesize an automaton that uses B√ºchi acceptance criteria to represent the same set of models that satisfy the \textsc{Ltl} formula
    \item let every node $s$ of this automaton be labeled with an \textsc{Ltl} formula $\eta(s)$
    \begin{itemize}
        \item for some accepting run $\sigma$, if the automaton reaches state $s$, then the suffice $\ sigma[s\dots]$ must satisfy $\eta(s)$, i.e., $\sigma[s\dots]\models\eta(s)$
        \item the $\eta(s)$ are of the form $(\wedge_{i=1\dots m}\nu_i\wedge\circ(\wedge_{j=1\dots n} \kappa_j)$, i.e. the successor nodes of $s$ have to satisfy $(\wedge_{j=1\dots n}\kappa_j)$
        \item refine $\eta(s)$ into shorter subformulas $\nu_i$ until all $\nu_i$ are propositional variables in positive or negative form
    \end{itemize}
    \begin{center}
    \scalebox{.8}{\input{images/ltlToBuechi.tikz}}
    \end{center}
    \begin{itemize}
        \item for $\Phi \mathcal{U} \Psi$
        \begin{itemize}
            \item either satisfy $\Psi$ now or $\Phi$ now and $\Phi \mathcal{U} \Psi$ later
            \item split current node
            \begin{itemize}
                \item first resulting node, add $\Psi$ to $\nu_i$
                \item second resulting node, add $\Phi$ to $\nu_i$ and $\Phi \mathcal{U} \Psi$ to $\kappa_i$
            \end{itemize}
            \item keep all $\nu_i$ and $\kappa_i$ formulas that are not affected by current splitting
            \item when all formulas have been split, generate successor node $s'$ to $s$
            \item $\nu_i$ of $s'$ are the $\kappa_i$ of $s$
            \item $\kappa_i$ of $s'$ are initially empty
            \item no more splitting? define acceptance condition
        \end{itemize}
        \item Not necessarily the most effective algorithm, but no proof for more effective exists
        \item steps of translation
        \begin{enumerate}
            \item preprocessing: bring formulae into negation normal form
            \item construction of node data structure for B√ºchi Automaton: recursively decompose
            \item define acceptance criteria to turn node data structure into B√ºchi Automaton: Use acceptance criterion for \textsc{GNba}
            \item translate the \textsc{GNba} into a ``simple'' \textsc{Nba}
        \end{enumerate}
        \item convert into \emph{negation normal form}, where negation only applies to propositional variables
        \begin{align*}
        \neg\square\Phi             &\Rightarrow \diamond\neg\Phi \\
        \neg\diamond\Phi            &\Rightarrow \square\neg\Phi \\
        \neg(\Phi \mathcal{U}\Psi)  &\Rightarrow (\neg\Phi)\mathcal{V}(\neg\Psi) \\
        \neg(\Phi \mathcal{V}\Psi)  &\Rightarrow (\neg\Phi)\mathcal{U}(\neg\Psi) \\
        \neg(\Phi\vee\Psi)          &\Rightarrow (\neg\Phi)\wedge(\neg\Psi) \\
        \neg(\Phi\wedge\Psi)        &\Rightarrow (\neg\Phi)\vee(\neg\Psi) \\
        \Phi\to\Psi                 &\Rightarrow (\neg\Phi)\vee\Psi \\
        \diamond\Phi                &\Rightarrow  true \mathcal{U}\Phi \\
        \square                     &\Rightarrow  false \mathcal{V}\Phi
        \end{align*}
        \item Semantics of $\mathcal{V}$ (unless): $\Phi$ is false when $\Psi$ is true \note{Is this true?}
        \item node data structure
        \begin{multicols}{2}
        \begin{description}
            \item[Name] unique identifier for the node
            \item[Incoming] list of node names that lead into this node
            \item[New,Old,Next] each is a set of subformulas for $\Phi$
            \begin{itemize}
                \item each node represents suffixes of executions
                \item $New(s)\sup Old(s):\;\nu_i$ formulas
                \item $New(s):$ unprocessed formulas
                \item $Old(s):$ processed formulas
                \item $Next(s):\;\kappa_i$ formulas
            \end{itemize}
            \item[Nodes\_Set] set of all existant nodes
            \begin{center}
            \scalebox{1}{\input{images/nodestructure.tikz}}
            \end{center}
            \item[Observation]
            \begin{itemize}
                \item assumption: $\sigma[\dots s]$ satisfies all subformulae in Old or New
                \item obligation: $\sigma[(s+1)\dots]$ satisfies all subformulae in Next
            \end{itemize}
        \end{description}
        \end{multicols}
        \item Nodes can be split (two nodes after) or evolved (one node after) \note{evolve $\to$ node gets changed only?}
        \item Processing of Current node $s$: is there a subformula to be processed in $New$ of node $s$?
        \begin{description}
            \item[no:] node $s$ is completely processed\\
            is there another node $r$ with the same subformulae as $s$ in both $Old$ and $Next$ field? \follows $s$ is discarded and incoming edges of $s$ are added to $r$\\
            else: add node $s$ to $Nodes\_Set$, continue with new subnode $s'$
            \begin{center}
            \scalebox{1}{\input{images/nodeprocessing.tikz}}
            \end{center}
            \item[yes:] select subformula $\eta$ from $New$
            \begin{itemize}
                \item remove $\eta$ from $New(S):=New(s)-\{\eta\}$
                \item determine main Boolean operator in $\eta$ \follows determine which rule to apply
                \item perform split into $s_1,s_2$ or evolve to $s'$
                \begin{itemize}
                    \item if $\eta$ is $\Phi\wedge\Psi,$\emph{proposition, negated proposition} or \emph{Boolean constant}:
                    \\ if $\eta$ is $false$ or if $\neg\eta$ is in old \follows contradiction, discard
                    \\ else: $s$ evolves into $s'$
                    \item if $\eta=\Phi \mathcal{U}\Psi,\; \Phi \mathcal{V}\Psi,\; \Phi\vee\Psi$, split into $s_1,s_2$
                \end{itemize}
            \end{itemize}
        \end{description}
    \end{itemize}
    \item Automaton construction form node structure
    \begin{itemize}
        \item initial node is initial state
        \item make transitions to states from all states in $Incoming$
        \item \textsc{GNba} Acceptance Conditions
        \begin{itemize}
            \item create set $F_i$ for each subformula of the form $\Phi \mathcal{U}\Psi$
            \item this ensures that if $\Phi \mathcal{U}\Psi$ holds in some run, $\Psi$ must hold later
            \item $F_i$ contains all states that either:
            \begin{itemize}
                \item contain $\Psi$ in its label
                \item does not contain $\Phi \mathcal{U}\Psi$ in its label
            \end{itemize}
        \end{itemize}
    \end{itemize}
    \item Translation from \textsc{GNba} $\mathcal{B}=(\Sigma,S,\delta,I,L,F)$ to \textsc{Nba} $\mathcal{A}'=(\Sigma,S',\delta',I',F')$, $F=\{ F_1\dots F_n \}$
    \begin{itemize}
        \item $S'=S\times\{1\dots n\}$
        \item $I'=I\times\{1\}$
        \item $\delta'$ is defined by $(t,i)\in\delta'((s,k),a)$ if $t\in\delta(s,a)$ and
        \begin{align*}
        i=k             & if\;s\not\in F_k \\
        i=(k \mod n) +1  & if\;s    \in F_k
        \end{align*}
        \item $F'=F_1\times\{1\}$
    \end{itemize}
    \item the construction labels states with numbers from $1\dots n$
    \begin{itemize}
        \item if the current number is $k$, then it will keep $k$ if we do not go though an acceptance state of $F_k$
        \item if we do go though an acceptance state $F_k$, then the new value is $\underset{\textrm{the next} k}{\underbrace{(k \mod n)+1}}$
        \item As soon as we reach an acceptance set from $F_1$ we look for one from $F_2$ next and thus go through all acceptance sets
    \end{itemize}
\end{itemize}
\subsection*{Complexity of Algorithm}
\begin{itemize}
    \item some optimization possible (redundancies, bisimulation reduction, weak alternating automata, prune parts that don't lead to acceptance cycle)
    \item number of nodes and runtime is exponential in the length of the \textsc{Ltl} formula
    \item \textsc{Ltl} are typically small \follows B√ºchi automaton typically less than $10$ states
    \item \textsc{Ltl} model checking is polynomial in the size of the B√ºchi automaton
\end{itemize}

\section*{Algorithms for Checking Safety Properties}
\subsection*{Basic \textsc{Dfs}}
\input{code/basicdfs.tex}
\begin{itemize}
    \item properties for finite state spaces
    \begin{itemize}
        \item complete exploration of state space
        \item termination can be proven
    \end{itemize}
    \item complexity
    \begin{itemize}
        \item linear in the number of nodes (which can be exponential in number of components)
    \end{itemize}
    \item efficiency problem
    \begin{itemize}
        \item ever node needs to be visited twice, once during generation of asynchronous product \textsc{Lts}, once during state space search \follows requires storage of copmlete {\tiny reachable} state space
        \item on-the-fly algorithm \follows expand asynchronous product and search
    \end{itemize}
\end{itemize}
\subsection*{On-the-fly \textsc{Dfs}}
\input{code/otfdfs.tex}
\begin{itemize}
    \item $Control(z,i)$: return control state of $i-th$ component
    \item $Data(z)$: return data values $v_1,\dots,v_n$
    \item $Update(z,i,s,f):$ take $z$, replace control of $i-th$ component with $s$, apply data action $f$ \follows check property
\end{itemize}
\subsection*{Basic-\textsc{Dfs} vs. On-the-fly \textsc{Dfs}}
\begin{itemize}
    \item Trade space complexity (memory) for time-complexity
    \begin{itemize}
        \item On-the-fly \textsc{Dfs} erases the parts of the state space \emph{not on the stack}
        \item danger of multiple generation of some states if erased and need to be visited again
    \end{itemize}
    \item in practical situations: Size (exponential in \dots) prevents use of basic dfs algorithm
\end{itemize}
\subsection*{\textsc{Bfs}}
\input{code/bfs.tex}
\subsection*{Depth-First vs. Breadth-First Search}
\begin{description}
    \item[BFS] always finds shortest counterexample
    \item[otf-DFS]
    \begin{itemize}
        \item easy extension to detect cylces (liveness properties)
        \item stack contents automatically yield counterexample
        \item memory efficiency, only need to store portion of state space
    \end{itemize}
    \item[conclusion]\textsc{Dfs} will be used in most cases, moderately sized models with \textsc{Bfs}
    \item[\textsc{Spin}] Depth-Bounded Breadth First Search
    \begin{itemize}
        \item May lead to incomplete search
    \end{itemize}
\end{description}
\subsection{Bitstate Hashing (Supertrace)}
\begin{minipage}[]{0.48\textwidth}
Don't want to revisit states, that have previously been visited. To efficiently determine, whether a state was visited before: use a \emph{hashtable}
\begin{itemize}
    \item $h$ slots with lists of zero or more states
    \begin{itemize}
        \item store new state $s$: compute $hash(s)$ out of $0\dots (h-1)$
        \item lookup state $s$: compute $hash(s)$, search for $s$ in sorted linked list, if not found add $s$ to linked list
    \end{itemize}
    \begin{itemize}
        \item \textsc{Spin} uses checksum-polynomial as well as Jenkin's hashing
    \end{itemize}
\end{itemize}
\end{minipage}
\begin{minipage}[]{0.48\textwidth}
\begin{center}
\scalebox{.8}{\input{images/hashtable.tikz}}
\end{center}
\end{minipage}
\begin{itemize}
    \item impact of hash collisions:
    \begin{itemize}
        \item $r$ number of states stored in hash table
        \item $h$ number of slots in table
        \item if $h>>r$ then each state can be stored in different slot for equal distribution
        \begin{itemize}
            \fitem linked list in every slot either empty or just one element
            \fitem almost no storage and time overhead
        \end{itemize}
        \item if $h<r$, then hash collisions lead to lists with $length\geq1$
        \begin{itemize}
            \fitem on average $\frac{r}{h}$ comparisions in linked list required per state access
            \fitem overhead grows linearly with $\frac{r}{h}$
        \end{itemize}
        \item if $h>>r$: what should we do
        \begin{itemize}
            \item store just \emph{one bit}, indicating whether state was visited before, or not
            \item dramatic savings in state space consumption
            \item problem of duplicates:
            \begin{itemize}
                \item renders method incomplete, when $hash(s)=hash(s')\textrm{ for } s\not=s'$ {\tiny (two different states with same hash, algo will assume, that state was visited before)}
                \item does not compromise soundness of method {\tiny (every error, that is found is indeed an error, not all errors may be found)}
            \end{itemize}
        \end{itemize}
        \item increased coverage due to bistate hashing
        \begin{itemize}
            \item $m:$ bit to store in hash table
            \item $S:$ bits per state description
            \item $r:$ number of reachable states
            \item $h:$ slots in hash table
        \end{itemize}
        \item less than $\frac{m}{s}$ will fit in memory, since hash table itsself requires space
        \item if $r>\frac{m}{S}$, search will abort after exploring a fraction of $\frac{m}{r*S}$ of the state space
        \item practical experience shows, that bitstate hashing produces greater coverage due to ability to store more states
    \end{itemize}
\end{itemize}

\section*{Model Checking $\omega$-Regular Properties}
To validate liveness-properties we need to visit every state and check, whether a cycle violating the condition can be found. This can be achieved by two nested \textsc{Dfs}'
\subsubsection*{Persistence}
\begin{shaded}
We call \emph{``eventually forever $\neg F$''} a \emph{persistence} property: \\
Let $P_{pers}\subseteq(2^{AP})^\omega$ an LT property and $\Phi$ some propositional logic formula over $AP$. We call
\[ P_{pers}=\{ A_0A_1A_2\dots\in(2^{AP})^\omega | \exists i\geq0.\forall j\geq i.A_j\models\Phi \} \]
a \emph{persistence property} and $\Phi$ a \emph{persistence} (or state) \emph{condition} of $P_{pers}$. $\Phi$ represents a propositional property that after a while (=a finite number of steps) becomes an invariant
\end{shaded}
\subsection*{Persistence Checking}
\begin{itemize}
    \item Check wheter $TS\not\models P_{pers}$ with persistence condition $\Phi$
    \item Algorithmic Idea
    \begin{itemize}
        \item Let $s$ a state reachable in $TS$ with $S\not\models\Phi$ \follows then $TS$ has an initial path fragment leading into $s$
        \item If $s$ is on a cycle
        \begin{itemize}
            \fitem this path fragment can be continued by an infinite path in $TS$ by re-visiting $s$ infinitely often
            \fitem $TS$ may visit the $\neg\Phi$-state $s$ infinitely often, which hence means \[ TS\not\models P_{pers} \]
        \end{itemize}
        \item If no $\neg\Phi$-state $s$ on a cycle can be found, then $TS\models P_{pers}$
    \end{itemize}
    \begin{shaded}
        $TS\not\models P_{pers}$ iff $\exists s\in Reach(TS).s\not\models\Phi\wedge s$ is on a cycle in $G(TS)$
        \\ The following statements are equivalent
        \begin{enumerate}
            \item $TS\not\models P$
            \item $Traces(TS)\cap \mathcal{L}_\omega(\mathcal{A})=\varnothing$
            \item $TS\otimes \mathcal{A}\models P_{pers(\mathcal{A})}$
        \end{enumerate}
    \end{shaded}
    \item model checking $\omega$-regular properties is reduced to checking persistence properties and thus finding cycles in $TS\otimes \mathcal{A}$
\end{itemize}
\subsection*{Nested Depth First Search \textsc{NDfs}}
performs two nested \textsc{Dfs} searches, post-order traversal for the first \textsc{Dfs}. \\
\input{code/ndfs.tex} \note{check this algo with updated script}
\begin{minipage}[]{0.78\textwidth}
Derivation of counterexample for \texttt{terminate(true)}
\begin{itemize}
    \item dfs2($s_1$)
    \item $s_2$ is found by dfs2 on dfs1-stack
    \item counterexample construction: $(q_0\dots s_2)(s_2\dots s_2)^\omega$
\end{itemize}
\end{minipage}
\begin{minipage}[]{0.28\textwidth}
    \begin{center}
    \scalebox{1}{\input{images/lasso.tikz}}
    \end{center}
\end{minipage}
\subsection*{Observations}
\begin{itemize}
    \item \textsc{NDfs} will not produce all accepting runs, but just one, iff there is one (i.e. completeness is not compromised)
    \item \textsc{Dfs2} will only encounter states that have previously been reached by \textsc{Dfs1} (post-order traversal) \follows a state, once flagged will not be re-expanded during cycle detection
    \item Post-Order vs. Pre-Order Traversal Strategy
    \begin{itemize}
        \item alternative: pre-ordered nested search
        \begin{itemize}
            \item search an acceptance state and once encountered, find a cycle
            \item quadratic worst case time overhead, linear worst case space overhead \follows since second search has to be invoked with a newly initialized list of flagged states
            \fitem post-order traversal strategy of \textsc{NDfs} is more efficient
        \end{itemize}
    \end{itemize}
\end{itemize}
\subsection*{Nested \textsc{Dfs} vs. Tarjans's \textsc{Scc} Detection}
\begin{minipage}[t]{0.48\textwidth}
Tarjan
\begin{itemize}
    \item \textsc{Scc}: strongly connected component: each element is reachable from inside an \textsc{Scc}
    \item Tarjan: \textsc{Dfs}-based \textsc{Scc} detection (not on-the-fly)
    \item every state is visited twice
    \item memory-overhead: thee $32-bit$ numbers / addresses per state visited
    \item capable to find all accepting paths
    \item easier to implement strong fairness constraints
\end{itemize}
\end{minipage}
\hfill \vrule \hfill
\begin{minipage}{0.48\textwidth}
\textsc{NDfs}
\begin{itemize}
    \item same worst case complexity
    \item memory overhead: $2-bits$ per state (hash + flag)
    \item enables supertrace / bitstate hashing
    \item finds one accepting path, if one exists (suffices to refute claimed property)
\end{itemize}
\end{minipage}
\subsection*{Property Specification in Promela}
\begin{itemize}
    \item Progress State Labels
    \begin{itemize}
        \item processes may diverge in infinite loops without ever making any visible progress
        \item prepending ``progress'' in front of a name of a control state label means, that any cyclic execution of the Promela model must lead though at least on progress labeled state, otherwise ``non-progress-cycle''
    \end{itemize}
    \item Temporal or Never Claims
    \begin{itemize}
        \item possibility to specify temporal properties directly as B√ºchi automata
        \item Promela model and never claim are executed as synchronous product
    \end{itemize}
    \item also permitted: end, progress, assert
    \item \textsc{Ltl} gets translated to never claim, as those are often unintuitive
\end{itemize}
\subsection*{Path Properties}
\begin{itemize}
    \item evaluated along execution paths
    \item Let $R$ an asynchronous product of a set of \textsc{Mts}
    \begin{shaded}
        \begin{itemize}
            \item $R$ is \emph{free of non-progress cycles} if at least one state in the cyclic suffix of any cyclic trace of $R.P.T.E$ in $R.PRG$ {\tiny (progress states)}
            \item $R$ is \emph{free of accepting cycles} if no state of the cyclic suffix of any cyclic trace of $R.P.T.E$ is in $R.ACC$ {\tiny (acceptance states $F$)}
        \end{itemize}
    \end{shaded}
    \item need for cycle-searching algorithm for accepting cycle detection
    \begin{itemize}
        \item traverse state space to find an accepting state $x$ \follows a procut state $z$ is accepting if at least oine of the component $MTS$  is in $M_i.ACC$
        \item change to second state space, set $x$ as seed, check whether $x$ is reachable form itself \follows post-order traversal
    \end{itemize}
    \follows \textsc{NDfs}
    \item on-the-fly Non-Progress Cycle Detection
    \\ let $x\in M_i.PRG$ for all $i$
    \begin{itemize}
        \item check, whether $x$ is reachable from itself
        \item if so, and if for all states $y$ in this cycle $y\not\in M_i.PRG$ for all $i$, then a non-progress cycle has been detected
    \end{itemize}
\end{itemize}
\subsection*{Automata-based Model Checking}
\begin{itemize}
    \item Computing $L(M)\subseteq L(S)$
    \item let $\Sigma^\omega-L(S)= \overline{L(S)}$ then \[ L(M)\subseteq L(S)\leftrightarrow L(M)\cap \overline{(L(S))} = \varnothing \]
    \item implementation variants:
    \begin{itemize}
        \item direct complementation of $S$: non-trivial operation \\
        for \textsc{Nba} $S$ with $n$ states, complement has $2^{\mathcal{O}(n\log n)}$ states
        \item direct specification of $\overline{S}$
        \item specify \textsc{Ltl} formula $\varphi$, obtain $\neg\varphi$, tranlaste $\neg\varphi$ into equivalent \textsc{Nba}
    \end{itemize}
    \item Existence of counterexample \\
    \begin{minipage}{0.48\textwidth}
    \begin{itemize}
        \item $L(M)\cap \overline{L(S)}=\varnothing$ \follows $A$ satisfies $S$
        \item $L(M)\cap \overline{L(S)}\not=\varnothing$ \follows $C$ is counterexample for the non-satisfaction of $S$ by $M$
        \item it can be shown, that any word in $C$ can be represented by an $\omega$-regular expression of the form $uv^\omega$ where $u$ and $v$ are finite state event sequences
    \end{itemize}
    \end{minipage}
    \hfill \vrule \hfill
    \begin{minipage}{0.48\textwidth}
    \begin{center}
        \scalebox{1}{\input{images/lasso2.tikz}}
        \end{center}
    \end{minipage}
    \item Construction of the Intersection of B√ºchi Automata
    \begin{itemize}
        \item let $M_1=(Q_1,q_0,q_{0,1},A,\delta_1,F_1)$ and $M_2=(Q_2,q_2,q_{0,2},A,\delta_2,F_2)$ be two B√ºchi automata
        \item the B√ºchi automaton accepting $L(M_1)\cap L(M_2)$ can be defined as \[ M_1\cap M_2 = (Q_1\times Q_2\times\{0,1,2\},(q_{0,1},q_{0,2},0),A,\delta,Q_1\times Q_2\times\{2\}) \] such that $(\langle r_i,q_i,x\rangle,a,\langle r_k,q_n,y\rangle)\in\delta$ iff all of the following contidions hold:
        \begin{enumerate}
            \item $(r_i,a,r_k)\in\delta_1$ and $(q_j,a,q_n)\in\delta_2$ (the transition of the intersection automaton agree with the transition of the operand automata)
            \item The third component of the state tuples can be computed as follows:
            \begin{itemize}
                \item if $x=0$ and $r_k\in F_1$, then $y=1$
                \item if $x=1$ and $q_n\in F_2$, then $y=2$
                \item if $x=2$ then $y=0$
                \item else, $y=x$
            \end{itemize}
        \end{enumerate}
        \item third component in state ensures, that acceptance states of both operand automata $M_1$ and $M_2$ occur infinitely often in accepting cycle
        \item construction is generally considered to inefficient
    \end{itemize}
\end{itemize}
\subsection*{Emptiness Check for B√ºchi Automata}
\begin{itemize}
    \item Let $M=(Q,q_0,A,\delta,F)$ a B√ºchi automaton, let $\rho$ a run on $\sigma$ such that $\sigma$ is being accepted by $M$
    \item $\rho$ contains infinitely many accepting states from $F$
    \item since $Q$ is finite, there is a suffix $\rho'$ of $\rho$ such that every state in $\rho'$ occurs infinitely often
    \item Every state in $\rho'$ is reachable from every other state in $\rho'$ \follows states in $\rho'$ form an \textsc{Scc}
\end{itemize}
\subsection*{Promela Never Claim}
\begin{itemize}
    \item just one instance per Promela model
    \item executed synchronously with the rest of the model
    \item can perform a step when condition label on transition is satisfied in current state of Promela model
    \item the final state of never claim is always indicating a property violation: stuttering semantics: final state repeated forever
    \item \red{there is something missing here:} part 15.44-47
\end{itemize}
\subsection*{Fairness}
\begin{description}
    \item[strong fairness:] a $\omega$-run $\sigma$ satisfies the property of \emph{strong fairness} if it contains infinitely many transitions from every componen automaton (proctype), which is infinitely often enabled in $\sigma$
    \[\forall \textrm{ component automata } i:\square\diamond enabled(i)\Rightarrow\square\diamond taken(i) \]
    \item[weak fairness:] a $\omega$-run $\sigma$ satisfies the property of \emph{weak fairness} if it contains infinitely many transitions from every componen automaton (proctype), which is enabled infinitely long in $\sigma$
    \[ \forall \textrm{ component automata } i:\diamond\square enabled(i)\Rightarrow \square\diamond taken(i) \]
\end{description}
\begin{itemize}
    \item avoidance of explicit specification of fairness constraints using \textsc{Ltl} formulae by \emph{built-in} fairness checking algorithms
    \begin{description}
        \item[strong fairness:] runtime increase by factor $n^2$, where $n$ is the number of concurrent components
        \item[weak fairness] runtime increase by factor $n$\\
        implemented in \textsc{Spin} \\
        in practice the factor is often 2
    \end{description}
    \item Construction: based on Chouekas flag construction
    \item \textsc{NDfs} checks LTS consisting of $k$ component LTSs
    \item create $k+2$ copies of the LTS that is obtained from the asynchronous product of the component LTSs
    \item preserve acceptance labels only in copy 0
    \item change outgoing transitions from acceptance states in copy 0 to point to corresponding state in copy 1
    \item in $i$th component ($1\leq i \leq k$) component, destination state of each transition contributed by LTS$_i$ to corresponding state in LTS$_{i+1}$, transitions contributed by other LTSs remain in same component
    \item all outgoing transition in copy $k+1$ are pointing to copy 0
    \item a component LTS that has no enabled transition in some state s does not need to participate in infinite run that traverses $s$
    \item add a null transition from every state $s$ in copy $i$ to the same state $S$ in copy $i$
    \begin{center}
    \scalebox{.75}{\input{images/weakfairness.tikz}}
    \end{center}
    \item effect:
    \begin{itemize}
        \item no change in behaviour
        \item accepting $\omega$ run now contains transitions from all $k$ component LTSs
        \item there can be no accepting cycles in copy 0
    \end{itemize}
    \item use \textsc{NDfs} on undolded graph to detect weakly fair acceptance cycles
    \item Implementation optimizations:
    \begin{itemize}
        \item do not store $n+2$ copies, but a $k-bit$ vector indicating in which copy this state has been reached
    \end{itemize}
    \item wirst case time penalty $2(k+2)$
    \\ in practice: factor = 2
\end{itemize}

\section*{Partial Oder Reduction}
for concurrent events $a \Vert b$ any possible interleaving will be part of set of valid system executions that the model checkers explores. Partial Order Reduction tries to prune execution sequences, that don't change the effect with respect to the property to be checked (i.e. reduces redundancy w.r.t. property).
\input{code/otfdfspor.tex}
\subsection*{Ample Set}
Calculation of $ample(q)\subseteq enabled(q)$
\begin{itemize}
    \item include sufficiently many elements from $enabled(q)$ so that model checking algorithm delivers \emph{correct results}
    \item use of $ample(q)$ should lead to a \emph{significantly smaller} state graph (in terms of states and transitions)
    \item computation of $ample(q)$ should be doable with \emph{acceptable computation overhead}
\end{itemize}
\begin{shaded}
A \emph{state transition system} is a tuple $(S,T,S_0,L)$ where
\begin{itemize}
    \item $S:$ finite set of states
    \item $S_0\subseteq S:$ finite set of initial states
    \item $L:S\to2^{AP}:$ function that labels every state with the $AP$ true int that state
    \item $T:$ finite set of transition relations so that for each $\alpha\in T,\alpha\subseteq S\times S$
\end{itemize}
let $\alpha\in T, s\in S$ then
\begin{itemize}
    \item $\alpha\in enabled(s)$ iff $(\exists s'\in S)((s,s')\in\alpha)$
    \item $\alpha$ is deterministic if for every $s$, there is at most one $s'$ so that $(s,s')\in\alpha$ {\tiny (consider only deterministic transitions)}
    \item we write $s'=\alpha(s)$ for $(s,s')\in\alpha$
\end{itemize}
\end{shaded}
\subsection*{Independence}
\begin{shaded}
    $I\subseteq T\times T$ is an independence relation if $I$ is symmetric and antireflexive and the following conditions hold for each $s\in S$ and for each $(\alpha,\beta)\in I:$
    \begin{enumerate}
        \item if $\alpha,\beta\in enabled(s)$ then $\alpha\in enabled(\beta(s))$\\
        \emph{enabledness:} a pair of independent transitions do not disable each other when taken
        \item if $\alpha,\beta\in enabled(s)$ then $\alpha(\beta(s))=\beta(\alpha(s))$ \\
        \emph{commutativity:} executing pair of independent transitions in any order result in same state
    \end{enumerate}
    \emph{Dependence Relation:} $D:=(T\times T)-I$
\end{shaded}
\subsection*{Correctness of Pruning}
Elimination may still deliver incorrect results (even if you show independence before) if:
\begin{enumerate}
    \item $s_1$ and $s_2$ may influence the outcome of the property check {\tiny (the property is not insensitive to whether $s_1$ or $s_2$ is being reached)}
    \item $s_1$ or $s_2$ may have successor states other than $r$ that would be pruned in case either of the two states did not belong to the reduced state space
\end{enumerate}
\subsection{Invisibility}
\begin{shaded}
    $T=(S,T,S_0,L)$ a state transition system, $AP'\subseteq AP$ \\
    $\alpha\in T$ is \emph{invisible} w.r.t $AP'$ if
    \[ (\forall s,s'\in S| s'=\alpha(s))((L(s)\cap AP')=(L(s')\cap AP')) \]
    {\tiny (i.e. a transition is invisible w.r.t. some selected set of propositions if its execution doesn't change the truth value for the selected set of propositions)}
\end{shaded}
\subsection{Invariance under Stuttering}
\begin{shaded}
    two paths $\sigma$ and $\rho$ though a state transition system are \emph{stuttering equivalent} (written as $\sigma\sim_{st}\rho$) if the following condition holds:
    \begin{itemize}
        \item there are two infinite sequences of integers
        \begin{align*}
        0&=i_0<i_2<\dots \\
        0&=j_0<j_1<\dots
        \end{align*}
        such that for every $k\geq0$
        \[ L(s_{i_k})=L(s_{i_{k+1}})=L(s_{_{k+1}-1})=L(r_{j_k})=L(r_{j_{k+1}})=L(r_{j_{k+1}-1}) \]
        \item identically labeled sequences of states are called blocks
        \begin{center}
        \scalebox{1}{\input{images/stutter.tikz}}
        \end{center}
    \end{itemize}
\end{shaded}
\subsection*{Invariance under Stuttering}
\begin{shaded}
    An \textsc{Ltl} formula $f$ is invariant under stuttering, if for each pair of paths $\pi$ and $\pi'$ such that $\pi\sim_{st}\pi'$: \[ \pi\models f \textrm{ iff } \pi'\models f \]
    \begin{itemize}
        \item let \textsc{Ltl}$_\upchi$ denote the set of all \textsc{Ltl} formulae free of the nexttime operator $\circ$
        \item any property expressible in\textsc{Ltl}$_\upchi$ is invariant under stuttering
        \item any stutter invariant property that is expressible with \textsc{Ltl} can be expressed in \textsc{Ltl}$_\upchi$
    \end{itemize}
\end{shaded}
\begin{shaded}
    Stutter Invariance for Transition Systems\\
    Let $M$ and $M'$ be state transition systems. $M$ and $M'$ are \emph{stutter invariant} iff
    \begin{itemize}
        \item they have the same set of initial states
        \item for each path $\sigma$ of $M$ that starts in an initial state of $M$ there is a path $\sigma'$ of $M'$ that starts in an initial state of $M'$ such that $\sigma\sim_{st}\sigma'$
        \item the same for the other way around
        \item Let $M$ and $M'$ two stuttering equivalent state transition systems. For ever property expressed by an \textsc{Ltl}$_\upchi$ formula $f$ and every initial state $s\in S_0$ the following holds true:
        \[ (M,s)\models f\textrm{ iff } (M',s)\models f \]
        {\tiny (\textsc{Ltl}$_\upchi$ formulae cannot distinguish between stuttering equivalent state transition systems)}
    \end{itemize}
\end{shaded}
\subsection*{Partial Order Reduction for \textsc{Ltl}$_\upchi$}
\begin{shaded}
    \begin{itemize}
        \item $s$ is fully expanded, iff $enabled(s)=ample(s)$
        \item else: provide conditions for selecting $ample(s)$ such that reduced state space satisfies property expressed by \textsc{Ltl}$_\upchi$ formula $f$
        \begin{description}
            \item[C0:] at-leat-one-successor rule
            \[ (\forall s\in S)(ample(s)=\varnothing \textrm{ iff } enabled(s)=\varnothing) \]
            {\tiny if a state has at least one successor in the full state space, it has at least on successor in the reduced state space}
            \item[C1:] dependent-transition rule \\
            Along every path in the full state space that starts at $s$, a transition that is dependent on a transition in $ample(s)$ cannot be executed without a transition in $ample(s)$ occuring first.

            for all paths in the full state space starting at $s$, the following holds true: \\
            {\tiny need to check for $C1$ without actually computing full state space in order to enable on-the-fly model checking, will later be done by approximation}
            \begin{itemize}
                \item a transition $\alpha'$ that is dependent on a transition $\alpha\in ample(s)$ cannot be executed without a transition from $ample(s)$ occuring first
                \item the transition in $enabled(s)-ample(s)$ are all independent of those in $ample(s)$
            \end{itemize}
            \item[C2:] invisibility rule \\
            for all states $s\in S$: if $s$ is not fully expanded, then every $\alpha\in ample(s)$ is invisible
            \item[C3:] cycle condition {\tiny (also called ``Cycle Proviso'')} \\
            The reduced state graph may not contain a cycle in which $\alpha\in enabled(s)$ for some state $s$ of the cycle so that $\alpha\not\in ample(s')$ for all states $s'$ of the cycle
        \end{description}
        \item for \textsc{Ltl}$_\upchi$ property $f$, reduction depends on the set $AP_f$ of atomic propositions occurring in $f$
    \end{itemize}
\end{shaded}
\subsection*{Preservation of Correctness}
\subsubsection*{C1: dependend transition rule}
Ensure, that the \textsc{Dfs} algorithm, when applied to the reduced statespace does not prune any parts of the graph, that are essential to the property when choosing the next transition to explore from $ample(s)$ \\
$C1$ ensures that:
\begin{description}
    \item[case 1:]$\beta_0\beta_1\dots\beta_m\alpha$, where $\alpha\in ample(s)$ and each $\beta_i$ is independent of all transitions in $ample(s)$, including $\alpha$
    \item[case 2:] $\beta_0\beta_1\dots$ where $\beta_i$ is independent of all transitions in $ample(s)$
    \fitem $\beta_i$ is independent from transitions on $ample(s)$ \follows cannot disable them
\end{description}
\subsubsection*{C2: Invisibility rule}
as alls transitions in $ample(s)$ are invisible, for $\alpha\in ample(s)$:
\[ \alpha\beta_0\beta_1\dots \textrm{ is stuttering equivalent to } \beta_0\beta_1 \]
\subsection*{Partial Order Reduction and Search}
Conditions $C0,C1,C2$ are independent of search algorithm, $C3$ is global condition and as expensive to check as model checking itself
\begin{itemize}
    \item $C3$ can be over-approximated as $C3_{cycle}:$
    \begin{itemize}
        \item every cycle in the reduced state space contains at least one state, that is fully expanded ($enabled(s)=ample(s)$)
        \item expensive, since it requires cycle detection
        \item not on-the-fly
    \end{itemize}
    \item $C3$ further over-approximated for safety-properties as $C3_{stack}$
    \begin{itemize}
        \item if a state is not fully expanded, then at least one transition in $ample(s)$ does not lead to a state that is on the search stack
        \item only applicable to stack-based \textsc{Dfs} search
        \item stronger than $C3$, less reduction
    \end{itemize}
    \item Overapproximation of $C3$ for non-\textsc{Dfs} (e.g. \textsc{Bfs}, $A^*$)
    \begin{itemize}
        \item[$C3_{duplicate}$:] if a state is not entirely expanded, then at least one transition in $ample(s)$ does not lead into a previously visited state \follows will not necessarily close a cycle
        \item[$C3_{static}$:] if a state is not fully expanded, then there is no transition in $ample(s)$ which closes a cycle in the control flow of a local process
    \end{itemize}
    \begin{center}
    \scalebox{1}{\input{images/approx.tikz}}
    \end{center}
\end{itemize}
\subsection*{Computational effort:}
\begin{description}
    \item[C0] easy, constant time
    \item[C1] checking this is at least as hard as checking reachability for full state space \follows over-approximation heuristics
    \item[C2] easy, static analysis of the transitions in the set
\end{description}
\subsubsection*{Heuristics for C1}
\begin{itemize}
    \item $pc_i(s):$ program counter for process $P_i$ in state $s$
    \item $pre(\alpha):$ all transitions $\beta$, such that there is a state $s$ for which $\alpha\not\in enabled(s),\beta\in enabled(s)$ and $\alpha\in enabled(\beta(s))$
    \item $dep(\alpha)=\{\beta|(\beta,\alpha)\in D\}$, the set of all dpeendent transitions of $\alpha$
    \item $T_i(s):$ transitions of process $i$ enabled in state $s$
    \item $current(s):$ set of transitions of $P_i$ that are enabled in some state $s'$ such that $pc_i(s')=pc_i(s)$
\end{itemize}
Definition of $pre(\alpha)$ and $D$ may not be exact
\begin{description}
    \item[$pre(\alpha)$] may contain transitions that do not enable $\alpha$
    \item[$D$] may contain transitions that are actually independent
\end{description}
This allows for efficient computation of ample sets while preserving correctness of p.o. reduction.
\subsubsection*{Specialization of $pre(\alpha)$ for different Modles of Computation}
\begin{itemize}
    \item $pre(\alpha)$ includes transitions of processes that contain $\alpha$ and that can change some $pc_i$ to a value from which $\alpha$ can execute
    \item if enabling condition for $\alpha$ involves shared variables, then $pre(\alpha)$ contains all other transitions that can change these shared variables
    \item if $\alpha$ involves sending/receiving to/from quere $d$, then all transitions from other processes sending or receiving to/from $d$ are in $pre(\alpha$
\end{itemize}
\subsubsection*{Statically computing $D$ for Different Model of Computation}
D includes:
\begin{itemize}
    \item pairs of transitions that share a variable that is changed by at least one of them
    \item pairs of transitions belonging to the same process $i$
    \begin{itemize}
        \item transitions in $P_i$ share ``variable'' $pc_i$
        \item includes in particular pairs of transitions in $current_i(s)$ for given $s$ and $P_i$
        \item rendez-vous communication: common transition of two processes, all transitions of both processes included in $D$
    \end{itemize}
not included in $D$
\begin{itemize}
    \item pair of send and receive transitions in different processes referring to the same channel d. {\tiny they can enable, but never diable each other}
\end{itemize}
\end{itemize}




%part 16.2.28

\end{document}