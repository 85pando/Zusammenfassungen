\documentclass{scrartcl}

% \usepackage{Header}
\usepackage{newclude}
\input{../zusammenfassung.tex}

%\usepackage{scalefnt}
%\usepackage{parcolumns}
%\usepackage{tikz-er2}
\usepackage{hyperref}

\begin{document}


\Gruppe{Stephan Heidinger}{TI - Zusammenfassung v0.1}
\Header{Theoretische Grundlagen der Informatik}{Sommersemester 2012}{Stephan Heidinger}{}%leave last variable empty, else there will be aufgabenblatt überschrift

\begin{shaded}
Dieses Dokument wurde unter der Creative Commons - Namensnennung-NichtKommerziell-Weitergabe unter gleichen Bedingungen (\textbf{CC by-nc-sa}) veröffentlicht. Die Bedingungen finden sich unter \href{http://creativecommons.org/licenses/by-nc-sa/3.0/de}{diesem Link}. \\
\centerline{\includegraphics[scale=1]{../cc-by-nc-sa.png} }
\end{shaded}

\textit{Find any errors? Please send them back, I want to keep them!}

\section*{Allgemeines}
\subsection*{Definitionen}
\begin{description}
    \item[$\bullet$] $\mathds{N}^0 = \{0,1,2,\dots\}$
    \item[$\bullet$] $\mathds{N}^{\backslash\{0\}}=\{1,2,\dots\}$
    \item[Alphabet:] endliche Menge von Zeichen {\tiny $\Sigma=\{a,b\}$}
    \item[Wort] Zeichenfolge {\tiny $w=abab \in\Sigma^*$}
    \item[$\Sigma^*$:] Menge der Wörter
    \item[$\Sigma^+$:] $\Sigma^* \backslash\{\varepsilon\}$ {\tiny $\{\}\not= \varepsilon \not=\{\varepsilon\}$}
    \item[Operator $\circ$:]Konkatenation {\tiny $\varepsilon \circ w = w, w\circ w=ww=w^2$}
    \item[$w^n=\underset{n-mal}{\underbrace{www\dots w}}$] $n \in \mathds{N}^0$
    \item[$|w_1|$:] Wortlänge {\tiny $|w|=5$}
    \item[$|w|_\sigma, \sigma\in\Sigma$] Anzahl $\sigma$ in $\Sigma$ {\tiny $|w|_a=3$}
\end{description}

Seiten $A,B$ Mengen (Sprachen): {\tiny $A=\{\varepsilon, a, bba, bbabb, B=\{a,aa,aaa\}$}
\begin{description}
    \item[$|A|$] Mächtigkeit = Anzahl der Elemente
    \item[Sprache:] Teilmenge von $\Sigma^*$
    \item[Vereinigung] $A\cup B=\{x\in\Sigma^* | x\in A \vee x\in B\}$
    \item[Schnitt] $A\cap B=\{c\in\Sigma^* | x\in A \wedge x\in B\}$
    \item[Komplement] $\overline{A}=\{x\in\Sigma^* | x \not\in A\} = \Sigma^*\backslash A$
    \item[Produkt] $AB=\{xy\in\Sigma^* | x\in A \wedge y\in B\}$
\end{description}

\subsubsection*{De Morgan Regeln}
\begin{align*}
\overline{A \cup B} &= \overline{\overline{A}\cap \overline{B}} \\
\overline{A\cap B} &= \overline{\overline{A} \cup \overline{B}}
\end{align*}

\subsubsection*{Klassen}
Sei $\mathcal{C}$ eine Klasse von Sprachen. $\mathcal{C}$ heisst
\begin{tabular}[t]{|c|}
vereinigungs- \\
schnitt- \\
komplement- \\
produkt-
\end{tabular}
abgeschlossen $\Leftrightarrow A\in\mathcal{C} \wedge B\in\mathcal{C}$
\begin{tabular}[t]{|c|}
$A\cup B \in \mathcal{C}$ \\
$A\cap B \in \mathcal{C}$ \\
$\overline{A} \in \mathcal{C}$ \\
$AB \in \mathcal{C}$
\end{tabular}. \\
$A$ ist abgeschlossen gegen Vereinigung und Komplement $\Leftrightarrow A$ ist abgeschlossen gegen Schnitt und Komplement.
\begin{align*}
    A^0 &= \{\varepsilon\} \\
    A^1 &= A\\
    A^{n+q} &= A^nA\\
    A^i A^j &= A^{i+j}\\
    \left( A^i \right)^j &= A^{i \cdot j}\\
    A^* &= \underset{n\geq0}{\bigcup}A^n &= A^0\cup A^1\cup A^2\cup\dots \\
    A^+ &= \underset{n > 0}{\bigcup}A^n &= \phantom{A^0\cup\;}A^1\cup A^2\cup\dots \\
        &= \underset{n\geq0}{\bigcap}A^n &= A^0\cap A^1\cap A^2\cap\dots \\
    \textrm{Potenzmenge} &= 2^A = \{B | B\subseteq A\} \\
    M_a &= \{x\in\Sigma^* | x=n^a\} \\
    M_2 &= \{1,4,9,16,\dots\} \\
    M_3 &= \{1,8,27,64,\dots\} \\
    M_4 &= \{1,16,81\dots\} \\
    \bigcup^4_{i=2}M_i &= \{1,4,8,9,16,\dots\} \\
    \bigcap^4_{i=2}M_i &= \{1^12,2^12,3^12,\dots\} \\
    M &= \{1,2,3\} \\
    2^M &= \left\{\emptyset, \{1\}, \{2\}, \{3\}, \{1,2\}, \{1,3\}, \{2,3\}, \{1,2,3\} \right\}
\end{align*}

Kreuzprodukt: \\
Seien $A_i$ Mengen,
\begin{align*}
A_1 \times A_2 \times A_3 \times \dots \times A_n &= \{ \left(a_1,a_2,a_3,\dots,a_n\right) | a_i\in A_i, i\in \mathds{N}^n\} \\
\chi^n_i\leq1 A_i &=
\begin{cases}
\emptyset & i<1 \\
A_1 & n=1 \\
\chi^{n-1}_{i=1} A_i \times A_n & n>1
\end{cases}
\end{align*}

\subsubsection*{Relationen}
Relationen, $\tau_{A_i} \subseteq \chi^n_{i=1} A_i$ setzen Elemente von Mengen zueinander in Beziehung. \\
Bsp:
\begin{align*}
    \{a,b,\dots,z\} \tau \{1,2,\dots,26\} &= \{(a,1),(b,2),\dots,(z,26)\} \\
    \mathds{N}^0 \leq \mathds{N}^0 &= \{(a,b) | a+c=b,\; a,b,c\in \mathds{N}^0\}
\end{align*}
Eigenschaften von Relationen auf gleichen Mengen $A$:
\begin{description}
    \item[reflexiv:] $\forall a\in A: a\tau a$
    \item[irreflexiv:]$\forall a\in A: \overline{a\tau a}$
    \item[symmetrisch:]$\forall a,b\in A: a\tau b \Rightarrow b\tau a$
    \item[antisymmetrisch:] $\forall a,b\in A: \left(a\tau b\wedge b\tau a\right) \Rightarrow a=b$ {\tiny (antisymmetrisch $\Rightarrow$ reflexiv)}
    \item[asymmetrisch:] $\forall a,b\in A: a\tau b \Rightarrow \overline{b\tau a}$
    \item[transitiv:] $\forall a,b,c\in A: \left(a\tau b\wedge b\tau c\right) \Rightarrow a\tau c$
    \item[äquivalent:]
    \item[Ordnungsrelationen Typ "`$\leq$"':] reflexiv, transitiv, antisymmetrisch
    \item[Ordnungsrelationen Typ "`$<$"':] irreflexiv, transitiv, antisymmetrisch
    \item[$\tau^+$] transitive Hülle
    \item[$\tau^*$] reflexive, transitive Hülle
\end{description}
\paragraph{Satz:}
$\tau^*$ ist die kleinste, reflexive und transitive Relation (Hülle), die $\tau$ selbst umfasst.
\begin{align*}
geg \; A = \{1,2,3,4,5\} \\
& & R,S &\subseteq A\times A \\
& & R &= \{(1,2), (2,3), (2,5), (3,4), (5,4)\} \\
& & S &= \{(1,3), (3,5), (5,1)\} \\
ges \; R^+, S^+, R^*, S^* \\
& & R^+ &= R \cup   \{(1,3), (1,4), (2,4), (1,5)\} \\
& & R^* &= R^+ \cup \{(1,1),(2,2),(3,3),(5,5) \} \\
& & S^+ &= S^+ \cup \{(1,5),(1,1),(3,1),(3,3),(4,5),(5,3) \} \\
& & S^* &= S^* \cup \{(2,2),(4,4) \} \\
\end{align*}

\paragraph{Bsp}
\begin{description}
    \item[a] "`ist blutsverwandt"' auf Menge der Personen
    \item[b] "`$x$ ist Teiler von $y$"', d.h. $\exists z$ mit $x\cdot z=y\; x,y,z\in \mathds{Z}$
    \item[c] $R\subseteq \mathds{Z} \times \mathds{Z}$ mit $R=\{(x,y) | xy > 0\}$
    \item[d] "`$w$ ist Präfix von $v$"', d.h. $\exists u$ mit $v=wu$,\; $u,v,w\in\Sigma^*,\;\Sigma$ sei Menge
\end{description}

\begin{tabular}{c|c|c|c|c|c|c|c|c|c|}
\hline
& refl. & irrefl. & symm. & antiymm. & asymm. & trans. & äquiv. & "`<"' & "`$\leq$"' \\
\hline
a & \correct & \wrong & \correct & \wrong & \wrong & \wrong & \wrong & \wrong & \wrong \\
\hline
b & \correct & \wrong & \wrong & \wrong & \wrong & \correct & \wrong & \wrong & \wrong \\
\hline
c & \wrong   & \wrong & \correct & \wrong & \wrong & \correct & \wrong & \wrong & \wrong \\
\hline
d & \correct & \wrong & \wrong & \correct & \wrong & \correct & \wrong & \correct & \wrong \\
\hline
\end{tabular}

\begin{description}
    \item[Äquivalenzklasse:] Sei $R \subseteq A\times A$ eine ÄR, dann heissen für $a\in A$ die Mengen $[a]_R:=\{b\in A | aRb\}$ Äquivalenzklassen von R.
    \item[Partitionierung:] Menge aller ÄK $A/_R:=\{[a]_R | a\in A\}$
    \item[Index] Anzahl der ÄK $|A/_R|$ \\
    Bsp $R=\{(x,y) | x \mod 2 = y \mod 2\}$ partitioniert $\mathds{N}^0$ in 2 ÄK:
    \begin{itemize}
        \item $[0]_a = \{0,2,3,\dots\}$
        \item $[1]_a = \{1,3,5,\dots\}$
    \end{itemize}
\end{description}

\part*{Automatentheorie und formale Sprachen}
\section*{Grammatik}
Eine Grammatik ist ein 4-Tupel $G=(V,\Sigma,P,S)$ \\[.5cm]
\begin{minipage}[t]{4.5cm}
\begin{description}
\item[V -] Variblen
\item[$\Sigma$ -] Terminalalphabet
\item[P -] Regeln/Produktionen
\item[S -] Startvariable
\end{description}
\end{minipage}
\begin{minipage}[t]{10cm}
    \begin{align*}
        |V|         & < \infty \\
        |\Sigma|    & < \infty \\
        |P|         & < \infty
    \end{align*}
\end{minipage}

\subsection*{Chomsky-Hirarchie}
\begin{description}
\item[Typ 0:] (Phrasenstrukturgrammatik) - keine Einschränkungen
\item[Typ 1:] (kontextsensitiv) - $(w_1\to w_2) \Rightarrow (\vert w_1 \vert \leq \vert w_2 \vert)$ {\tiny (Wort wird nicht kürzer)}
\item[Typ 2:] (kontextfrei) - $(w_1\to w_2 \Rightarrow (w_1\in V)$ {\tiny $w_1$ ist einzelne Variable}
\item[Typ 3:] (regulär) - $w_2\in\Sigma\cup\Sigma V$ {\tiny "`rechte Seiten"' von Regeln Terminalsymbol oder Terminalsymbole gefolgt von Variablen}
\end{description}
Alle Sprachen der Typen 1,2 und 3 sind \emph{entscheidbar}.

\subsection*{$\varepsilon$-Sonderregelung {\tiny (Zulassen des leeren Wortes $\varepsilon$ in Typ 1,2 oder 3)}}
\begin{itemize}
\item Regel hinzufügen: $S\to\varepsilon$
\item Verhindern von $S$ auf rechter Seite von Regeln: Regel mit "`$\to S$"' ersetzen durch "`$\to S'$"'
\item Zulassen von $A\to\varepsilon$ {\tiny (verändert Sprache nicht)}\\
Algorithmus:
\begin{enumerate}
\item Zerlege $V\to V_1,V_2$, $(A\Rightarrow^*\varepsilon)\in V_1$ und $V_1\cap V_2=\emptyset$.
\item Entferne alle $A\to\varepsilon$, füge für $(B\to xAy)$ $(B\to xy)$ hinzu.
\end{enumerate}
\end{itemize}

\subsection*{Wortproblem {\tiny (Gehört ein Wort zu einer Sprache?)}}
$(\exists \textrm{Algorithmus})[(\textrm{Algo terminiert in endl. Zeit}\wedge(Algo entscheidet (x\in\mathcal{L}(G))\vee(x\not\in\mathcal{L}(G)))]$ \\
$\Rightarrow$ das Wortproblem ist für Typ 1,2 und 3 entscheidbar (aber NP-hart für Typ 1)

\subsection*{Syntaxbäume}
Wurzel: $S$ \\
Für $i=1,2,\ldots,n\; A\to z\in P\Rightarrow\vert z\vert\textrm{ viele Söhne }\to \textrm{"`weitere Kette"'}$\\
\begin{description}
\item[Linksableitung:] Variable am weitesten links wird abgeleitet.
\item[Rechtsableitung:] Variable am weitesten rechts wird abgeleitet.
\item[mehrdeutige Grammatik:] für ein $x$ verschiedene Syntaxbäume möglich
	\begin{itemize}
	\item Mehrdeutigkeit kann oft beseitigt werden.
	\item Ist dies nicht möglich $\Rightarrow$ \emph{inhärent mehrdeutig}
	\end{itemize}
\end{description}

\subsection*{Backus-Naur-Form Bnf (Typ 2 Grammatiken)}
Metaregeln für selbe linke Seite
\[
\left. \begin{array}{ccc}
A & \to    & \beta_1 \\
A & \to    & \beta_2 \\
  & \vdots &         \\
A & \to    & \beta_3
\end{array} \right\rbrace A\to\beta_1\vert\beta_2\vert\ldots\beta_n
\]

\subsection*{erweiterte Backus-Naur-Form Ebnf}
\begin{align*}
A &\to \alpha[\beta]\gamma \Rightarrow \left\lbrace
\begin{array}{ccc}
A & \to & \alpha\gamma \\
A & \to & \alpha\beta\gamma
\end{array}
\right. \\
A &\to \alpha\{\beta\}\gamma \Rightarrow \left\lbrace
\begin{array}{ccc}
A & \to & \alpha\gamma \\
A & \to & \alpha B\gamma \\
B & \to & \beta \\
B & \to & \beta B
\end{array}
\right.
\end{align*}

\section*{Reguläre Sprachen}
\subsection*{Endliche (deterministische) Automaten DFA}
\begin{minipage}{6cm}
    $M = \left(Z,\Sigma,\delta,z_0,E\right)$
    \begin{description}
        \item[$\Sigma$] Eingabealphabet
        \item[$z_0$] Startzustand
        \item[$z\cap\Sigma = \emptyset$]
    \end{description}
\end{minipage}
\begin{minipage}{5.5cm}
\begin{description}
    \item[$Z$] Menge der Zustände
    \item[$E\subseteq Z$] Menge der Endzustände
    \item[$\delta: z\times E\to z$] Überführungsfunktion
    \item[$|z|< \infty,\; |\Sigma |<\infty$]
\end{description}
\end{minipage}\\
$\to$ Zustandsgraphen

\subsection*{akzeptierte Sprache}
Die von $M$ akzeptierte Sprache ist:
\begin{align*}
    T(M) &= \{x\in\Sigma^* \vert \hat\delta(z,e)\} \\
    & \textrm{wobei} & \hat\delta(z,\varepsilon)&=z \\
    & & \hat\delta(z,ax) &= \hat\delta\left(\delta(z,a),x\right)
\end{align*}

\begin{shaded}
    \ \\ Jede durch Endliche Automaten erkennbare Sprache ist Regulär (Typ 3).\\
    Jede Reguläre Sprache ist durch einen Endlichen Autoamten erkennbar.
\end{shaded}

\subsection*{Nichtdeterministische Automaten} % (fold)
Ein \emph{nichtdeterministischer, endlicher Automat} (\textsc{Nfa}) wird spezifiziert durch ein 5-Tupel: \\
\begin{minipage}{6cm}
    $M = \left(Z,\Sigma,\delta,S,E\right)$
    \begin{description}
        \item[$\Sigma$] Eingabealphabet
        \item[$S\subseteq Z$] Menge der Startzustände
        \item[$z\cap\Sigma = \emptyset$]
    \end{description}
\end{minipage}
\begin{minipage}{7cm}
\begin{description}
    \item[$Z$] Menge der Zustände
    \item[$E\subseteq Z$] Menge der Endzustände
    \item[$\delta: Z\times E\to \mathcal{P}(z)$] Überführungsfunktion
    \item[$|z|< \infty,\; |\Sigma |<\infty$]
\end{description}
\end{minipage}\\

\begin{shaded}
    Jede durch einen \textsc{Nfa} akzeptierbare Sprache ist auch durch einen \textsc{Dfa} akzeptierbar.
\end{shaded}

\begin{shaded}
    Für jede Reguläre Grammatik $G$ gibt es einen \textsc{Nfa} $M$ mit $L(G)=T(M)$.
\end{shaded}

\subsection*{regulärer Ausdruck} % (fold)
\begin{description}
    \item[$\emptyset$] ist regulärer Ausdruck.
    \item[$\varepsilon$] ist regulärer Audruck.
    \item[$a\in\Sigma$] ist regulärer Audruck.
    \item[$\alpha\beta, \left(\alpha\vert\beta\right), \left(\alpha\right)^* $] sind reguläre Ausdrücke, wenn $\alpha,\beta$ reguläre Ausrdücke sind.
\end{description}

\begin{minipage}[t]{0.48\textwidth}
    \begin{align*}
        \gamma &:= \emptyset & \Rightarrow L(\gamma) &= \emptyset \\
        \gamma &:=\varepsilon & \Rightarrow L(\gamma) &= \{\varepsilon\} \\
        \gamma &:=\alpha & \Rightarrow L(\gamma) &= \{\alpha\} \\
        \gamma &:=\alpha\beta & \Rightarrow L(\gamma) &= L\{\alpha\}L\{\beta\}
    \end{align*}
\end{minipage}
\hfill \vrule \hfill
\begin{minipage}[t]{0.48\textwidth}
    \begin{align*}
        \gamma &:= \left(\alpha\vert\beta\right) & \Rightarrow L\left(\gamma\right)&=L(\alpha)\cup L(\beta) \\
        \gamma &:= \left(\alpha\right)^* & \Rightarrow L(\gamma) &= L(\gamma)^* \\
        \gamma &:= \alpha\alpha = \alpha^2
    \end{align*}
\end{minipage}

\begin{shaded}
    Die Menge der durch Reguläre Ausdrücke beschreibbaren Sprachen ist genau die Menge der Regulären Sprachen.
\end{shaded}

\subsection*{Pumping-Lemma {\tiny Schleifenlemma, Iterationslemma, Lemma von Bar-Hillel, $uvw-$Theorem}} % (fold)
\begin{shaded}
    Sei $L$ eine Reguläre Sprache. Dann gibt es eine Zahl $n$ so, dass sich alle Wörter $x\in L$ mit $|x|\geq n$ zerlegen lasen in $x=uwv$, so dass folgende Eigenschaften erfüllt sind:
    \begin{itemize}
        \item $|v|\geq1$
        \item $|uv|\leq n$
        \item $\forall i\in\{0,1,\dots\}$ gilt: $uv^iw\in L$
    \end{itemize}
\end{shaded}
\begin{description}
    \item[$\to$] Zum Erkennen von nicht regulären Sprachen (geht nicht bei allen).
    \item[$\to$] $v^i$-Schleifen
\end{description}
Anwendung: Annehmen, $L$ sei regulär \follows Wenn Widerspruch, $L$ nicht regulär.

\subsection*{Äquivalenzrelationen und Minimalautomaten}
$xR_Ly$ gdw für alle $z\in\Sigma^*: xz\in L$
\begin{shaded}
    Eine Sprache $L$ ist genau dann Regulär, wenn der Index von $R_L$ endlich ist:
    \[L \textrm{ regulär } \Leftrightarrow Index(R_L) < \infty \]
    {\tiny $Index$: Anzahl erzeugbarer Äquivalenzklassen}
\end{shaded}

Äquivalenzklassenautomat $\equiv$ Minimalautomat (nur DFA!) \\
Minimalautomat $\to$ Minimalautomat mit min Zustandszahl

\subsubsection*{Algorithmus Minimalautomat $\mathcal{O}(n^2)$}
\textbf{Eingabe:} \textsc{Dfa}, alle Zustände erreichbar.
\textbf{Ausgabe:} zu verschmelzende Zustände
\begin{enumerate}
    \item Tabelle mit Zustandspaaren $\{z,z'\}, z\not= z'$
    \item Markiere Paare $\{z,z'\}$ mit $z\in E$ und $z'\not\in E$ und umgekehrt
    \item unmarkierte Felder: Teste, ob $\underset{1\textrm{ hop!}}{\underbrace{\{\delta(z,a),\delta(z',a)\}}}$ markiert ist, wenn ja, markiere $\{z,z'\}$
    \item Punkt $3$ widerholen, bis keine Änderung mehr in der Tabelle passiert.
    \item Verschmelze unmarkierte Paare.
\end{enumerate}

\subsubsection*{Abschlusseigenschaften}
\begin{shaded}
    Reguläre Sprachen sind abgeschlossen unter:
    \begin{itemize}
        \item Vereinigung
        \item Schnitt
        \item Komplement
        \item Produkt
        \item Stern
    \end{itemize}
\end{shaded}

\subsubsection*{Entscheidbarkeit}
\begin{description}
    \item[Wortproblem:] Linearer Aufwand bei bekanntem \textsc{Dfa}
    \item[Leerheitsproblem:] Entscheidbar (\textsc{Dfa}, kein Weg $S\to E$)
    \item[Endlichkeitsproblem:] $T(M) = \infty \Leftrightarrow S\to\circlearrowright\to E$
    \item[Schnittproblem:] $\to$ Leerheitsproblem
    \item[Äquivalenzproblem] \textsc{Dfa} $\to$ Minimalautomat $\to$ Isomorphie checken $\to \mathcal{O}(n)$
    \[ L_1 = L_2 \Leftrightarrow \left(L_1 \cap \overline{L_2}\right) \cup \left(L_2 \cap L_1\right) = \emptyset \]
    $\to$ Leerheitsproblem $\to$ NP-hart
\end{description}

\section*{Kontextfreie Sprachen}
{\tiny korrekt geklammerte Ausdrücke}
\subsubsection*{Normalformen}
\begin{description}
    \item[Chromsky-Normalform:] (\textsc{Cnf}) Alle Regeln haben die Form $A\to BC$ oder $A\to a$
    \begin{shaded}
        Zu jeder Kontextfreien Grammatik $G$ mit $\varepsilon\not\in L(G)$ gibt es eine Chromsky-Normalform-Grammatik $G'$ mit $L(G) = L(G')$.
    \end{shaded}
    \item[Greibach-Normalform:] (\textsc{Gnf}) Alle Regeln haben die Form $A\to aB_1B_2\dots B_k\; (K\geq0)$ \\ {\tiny Erweiterung der Regulären Sprachen, hier nur $k=0$ und $k=1$}
    \begin{shaded}
        Zu jeder Kontextfreien Grammatik $G$ mit $\varepsilon\not\in L(G)$ gibt es eine Greibach-Normalform-Grammatik $G'$ mit $L(G) = L(G')$.
    \end{shaded}
\end{description}

\subsection*{Pumpinglemma}
\begin{shaded}
    Sei $L$ eine kontextfreie Sprache. Dann gibt es eine Zahl $n\in \mathds{N}$, so adss sich alle Wörter $z\in L$ mit $|z|\geq n$ zerlegen lassen in $z=uvwxy$ mit folgenden Eigenschaften:
    \begin{itemize}
        \item $|vx|\geq 1$
        \item $|vwx|\leq n$
        \item $\forall i\geq0$ gilt $uv^iwx^iy\in L$
    \end{itemize}
    Jede kontextfreie Sprache über einem einelementigen Alphabet ist bereits regulär.
\end{shaded}

\subsection*{Abschlusseigenschaften}
\begin{shaded}
Die Kontextfreien Sprachen sind\dots \\
\begin{minipage}[t]{0.48\textwidth}
\dots abgeschlossen unter
\begin{itemize}
    \item Vereinigung
    \item Produkt
    \item Stern
\end{itemize}
\end{minipage}
\hfill \vrule \hfill
\begin{minipage}[t]{0.48\textwidth}
\dots nicht abgeschlossen unter
\begin{itemize}
    \item Schnitt
    \item Komplement
\end{itemize}
\end{minipage}
\end{shaded}

\subsection*{Der CYK-Algorithmus}
\begin{algorithm}[H]
    \caption{CYK}
    \SetAlgoLined
    \LinesNumbered
    \PrintSemicolon
    \KwData{$x=a_1a_2\dots a_n$}
    %\KwResult{}
    initialisation\;
    \For{$i:=1$ \KwTo $n$ {\tiny ($j=1$)}}{
        $T[i,1]:=\{A\in V | A\to a_i \in P\}$
    }
    \For{$j:=2$ \KwTo n {\tiny ($j>1$)}}{
        \For{$i:=1$ \KwTo $n+1-j$}{
            $T[i,j]:=\emptyset$
            \For{$k:=1$ \KwTo $j-1$}{
                $T[i,j] := T[i,j]\cup \{A\in V | A\to BC\in P\wedge B\in T[i,k]\wedge C\in T[i+k,j-k]\}$
            }
        }
    }
    \eIf{$S\in T[1,n]$}{
    "`$x$ liegt in $L(G)$"'
    }{
    "`$x$ liegt nicht in $L(G)$"'
    }
\end{algorithm}

\subsection*{Kellerautomaten (PDA)}
\begin{shaded}
    Ein \emph{(nichtdeterministischer) Kellerautomat} (\emph{pushdown automaton}) wird angegeben durch ein 6-Tupel: $M=\left(Z,\Sigma,\Gamma,\delta,z_0,\#\right) $ \\
    \begin{minipage}[t]{0.48\textwidth}
        \begin{itemize}
            \item $Z$ - endliche Zustandsmenge
            \item $\Sigma$ - Eingabealphabet
            \item $\Gamma$ - Kelleralphabet
        \end{itemize}
    \end{minipage}
    \hfill \vrule \hfill
    \begin{minipage}[t]{0.48\textwidth}
        \begin{itemize}
            \item $ \delta:Z\times(\Sigma\cup\{\varepsilon\})\times\Gamma\to\mathcal{P}_e (Z\times\Gamma^* $ - die Überfühungsfunktion
            \item $z_0\in Z$ Startzustand
            \item $\#\in\Gamma$ unterstes Kellerzeichen
        \end{itemize}
    \end{minipage}
\end{shaded}

Um Schreibarbeit zu sparen, schreibt man statt $(z',x)\in\delta(z,a,A)$ einfach $zaA\to z'x$.

\begin{shaded}
    Eine Sprache $L$ ist kontextfrei genau dann, wenn $L$ von einem nichtdeterministischen Kellerautomaten erkannt wird.
\end{shaded}

\section*{Deterministisch kontextfreie Sprachen}
\begin{shaded}
    Ein Kellerautomat $M$ heisst \emph{deterministisch}, falls für alle $z\in Z,a\in \Sigma, A\in\Gamma$ gilt: $|\delta(z,a,A)| + |\delta(z,\varepsilon,A|\leq 1$. \\
    Hinzu kommt, dass deterministisch kontextfreie Kellerautomaten \emph{per Endzustand} akzeptieren, nicht per leerem Keller.
\end{shaded}

\begin{shaded}
    Eine Sprache heisst \emph{deterministisch kontextfrei}, falls sie von einem deterministischen Kellerautomaten erkannt wird.
\end{shaded}

\subsubsection*{Abgeschlossenheit}
Deterministisch kontextfreie Sprachen sind\dots
\begin{minipage}[t]{0.48\textwidth}
\dots abgeschlossen unter:
\begin{itemize}
    \item Komplement
\end{itemize}
\end{minipage}
\hfill \vrule \hfill
\begin{minipage}[t]{0.48\textwidth}
\dots nicht abgeschlossen unter:
\begin{itemize}
    \item Schnitt
    \item Vereinigung
\end{itemize}
\end{minipage}

Zudem ist der \emph{Schnitt} einer deterministisch kontextfreien Sprache mit einer regulären Sprache wieder deterministisch kontextfrei.

\subsubsection*{Entscheidbarkeit}
\begin{description}
    \item[Wortproblem] \textsc{Cyk}
    \item[Leerheitsproblem] \textsc{Cnf} $\to$
    \begin{enumerate}
        \item Markiere Variablen, die auf Terminale ableiten $A\to a$
        \item markiere sukzessive alle Variablen, die auf diese führen $A\to BC$ ($B,C$ bereits markiert)
        \item Wenn die Startvariable nicht markiert ist, ist die Sprache leer.
    \end{enumerate}
    \item[Endlichkeitsproblem] Pumping Lemma
    \item Äquivalenzproblem
\end{description}

\section*{Kontextsensitive und Typ-0-Sprachen}
\subsection*{Kuroda-Normalform}
{\tiny Vergleichbar mit \emph{Chromsky-Normalform}}
\begin{shaded}
    Eine Typ 1-Grammatik ist in \emph{Kuroda-Normalform}, falls alle Regeln eine der $4$ Formen haben: \[ A\to a, A\to B, A\to BC, AB\to CD \]
    hierbei stehen $A,B,C,D$ für Variablen und $a$ für ein Terminalsymbol.
\end{shaded}

\begin{shaded}
    Für jede Typ-1 Grammatik $G$ mit $\varepsilon \not\in L(G)$ gibt es eine Grammatik $G'$ in Kuroda-Normalform mit $L(G) = L(G')$.
\end{shaded}

\subsection*{Turingmaschine}
{\tiny Turingmaschinen sind grundsätzlich nichtdeterministisch.}
\begin{shaded}
    Eine \emph{Turingmaschine} ist gegeben durch ein 7-Tupel $M=(Z,\Sigma,\Gamma,\delta,z_0,\square,E)$
    \begin{minipage}[t]{0.48\textwidth}
    \begin{itemize}
        \item $Z$ endliche Zustandsmenge
        \item $\Sigma$ Eingabealphabet
        \item $\Gamma\supset\Sigma$ Arbeitsalphabet
        \item $\delta:Z\times\Gamma\to Z\times\Gamma\times\{L,R,N\}$ im deterministischen Fall (bzw. $\delta:Z\times\Gamma\to\mathcal{P}(Z\times\Gamma\times\{L,R,N\})$ im nichtdeterministischen Fall) die Überführungsfunktion
    \end{itemize}
    \end{minipage}
    \hfill \vrule \hfill
    \begin{minipage}[t]{0.48\textwidth}
    \begin{itemize}
        \item $z_0\in Z$ der Startzustand
        \item $\square\in\Gamma-\Sigma$ das Blank
        \item $E\subseteq Z$ Menge der Endzustände
    \end{itemize}
    \end{minipage}
\end{shaded}
Dabei bedeutet $\delta(z,a)=(z',b,x)$: Wenn sich $M$ im Zustand $z$ befindet und unter dem Schreib-Lesekopf das Zeichen $a$ steht, so geht $M$ im nächsten Schritt in den Zustand $z'$ über, schreibt (auf den Platz von $a$) $b$ auf das Band und führt danach die Kopfbewegeung $x\in\{L,R,N\}$ aus.

\begin{shaded}
    Eine \emph{Konfiguration} einer Turingmaschine ist ein Wort $k\in\Gamma^* Z\Gamma^*$.
\end{shaded}
{\tiny Konfiguration = Momentaufnahme $k=\alpha z\beta$ mit $z$ aktueller Zustand.}
\begin{shaded}
    Definieren auf Menge der Konfigurationen zweistellige Relation $\vdash$
    {\tiny $\vdash$ 1 Schritt \\ $\vdash^*$ mehrere Schritte }
    \[ a_1\dots a_mzb_1\dots b_n\vdash
    \begin{cases}
        a_1\dots a_mz'cb_2\dots b_n, & \delta(z,b_1)=(z',c,N), m\geq0, n\geq1 \\
        a_1\dots a_mcz'b_2\dots b_n, & \delta(z,b_1)=(z',c,R), m\geq0, n\geq2 \\
        a_1\dots a_mz'cb_2\dots b_n, & \delta(z,b_1)=(z',c,L), m\geq1, n\geq1
    \end{cases}
     \]
\end{shaded}

\begin{shaded}
    Die von einer Turingmascheine $M$ \emph{akzeptierte Sprache} ist wie folgt definiert: \[ T(M)=\{x\in\Sigma^* | z_0x\vdash^*\alpha z\beta; \alpha,\beta\in\Gamma^*; z\in E\} \]
\end{shaded}

\subsubsection*{linear beschränkte Turingmaschine (LBA)}
\begin{shaded}
    Eine nichteterministische Turingmaschine heisst \emph{linear beschränkt}, wenn für alle $a_1a_2\dots a_{n-1}a_n\in\Gamma^+$ und alle Konfigurationen $\alpha z\beta$ mit $z_0a_1a_2\dots a_{n-1}\hat{a_n}\vdash^*\alpha z\beta$ gilt $|\alpha\beta|=n$.\\
    Die von einer linear beschränkten Turingmaschine $m$ \emph{akzeptierte Sprache} ist wie folgt definiert.
    \[
    T(M) = \{a_1a_2\dots a_{n-1}\in\Sigma^* | z_0a_1a_2\dots a_{n-1}\hat{a_n}\vdash^*\alpha z\beta,\; \alpha,\beta\in\Gamma^*; \;z,\in E\}
    \]
\end{shaded}

\begin{shaded}
    Die von linear beschränkten, nichtdeterministischen Turingmaschine (\textsc{Lba}s) akzeptierten Sprachen sind genau die kontextsensitiven (\textsc{Typ} 1) Sprachen.
\end{shaded}

\begin{shaded}
    Die durch algemeine Turingmaschinen akzeptierbaren Sprachen sind genau die \textsc{Typ} 0-Sprachen.
\end{shaded}

\begin{shaded}
    Eine \emph{Mehrband-Turingmaschine} ist eine Maschine mit $k\geq1$ Bändern und $k$ Schreib-Leseköpfen. Sie kann daher auf jedem Band unabhängig agieren.\\[1cm]
    Zu jeder Mehrbandturingmaschine $M$ gibt es eine (Einband-)Turingmaschine $M'$ mit $T(M)=T(M')$, bzw so, dass $M'$ dieselbe Funktion berechnet wie $M$.
\end{shaded}

\section*{Überblick}
\subsection*{Beschreibungsmittel}
\begin{tabular}{c|c}
\hline
Typ 3&
\begin{minipage}[t]{6cm}
reguläre Grammatik \\
\textsc{Dfa} \\
\textsc{Nfa} \\
regulärer Ausdruck
\end{minipage}
\\
\hline
Deterministisch kontextfrei & deterministische Kellerautomaten (\textsc{Dpda})\\
\hline
Typ 2 &
\begin{minipage}[t]{6cm}
kontextfreie Gramatik \\
Kellerautomat \textsc{Pda}
\end{minipage}\\
\hline
Typ 1 &
\begin{minipage}[t]{6cm}
kontextsensitive Grammatik
linear beschränkter Automat \textsc{Lba}
\end{minipage}\\
\hline
Typ 0 &
\begin{minipage}[t]{6cm}
Typ 0-Grammatik \\
Turingmaschine \textsc{TM}
\end{minipage}
\\
\hline
\end{tabular}

\subsection*{Determinismus und Nichtdeterminismus}
\begin{tabular}{c|c|c}
nichtdet. Automat & determ. Automat & äquivalent? \\
\hline
\textsc{Nfa} & \textsc{Dfa} & \correct \\
\hline
\textsc{Pda} & \textsc{Dpda} & \wrong \\
\hline
\textsc{Lba} & \textsc{Dlba} & ? {\tiny \textsc{Lba}-Problem} \\
\hline
\textsc{Tm} & \textsc{Dtm} & \correct
\end{tabular}

\subsection*{Abschlusseigenschaften}
\begin{tabular}{c|c|c|c|c|c|}
 & Schnitt & Vereinigung & Komplement & Produkt & Stern \\
\hline
Typ 3 & \correct & \correct & \correct & \correct & \correct \\
\hline
Det. kf. & \wrong & \wrong & \correct & \wrong & \wrong \\
\hline
Typ 2 & \wrong & \correct & \wrong & \correct & \correct \\
\hline
Typ 1 & \correct & \correct & \correct & \correct & \correct \\
\hline
Typ 0 & \correct & \correct & \wrong & \correct & \correct \\
\hline
\end{tabular}

\subsection*{Entscheidbarkeit}
\begin{tabular}{c|c|c|c|c|}
& Wort- & Leerheits- & Äquivalenz- & Schnitt- \\
\hline
Typ 3 & \correct & \correct & \correct & \correct \\
\hline
Det. kf. & \correct & \correct & \correct & \wrong \\
\hline
Typ 2 & \correct & \correct & \wrong & \wrong \\
\hline
Typ 1 & \correct & \wrong & \wrong & \wrong \\
\hline
Typ 0 & \wrong & \wrong & \wrong & \wrong \\
\end{tabular}

\subsection*{Wortproblem (Komplexität)}
\begin{tabular}{c|c}
\hline
Typ 3 (\textsc{Dfa gegeben}) & lineare Komplexität \\
\hline
Det.kf. & lineare Komplexität \\
\hline
Typ 2 (\textsc{Cnf gegeben}) & $\mathcal{O}(n^3)$ \\
\hline
Typ 1 & exponentielle Komplexität, NP-hart \\
\hline
Typ 0 & unlösbar \\
\hline
\end{tabular}

\part*{Berechenbarkeitstheorie}
\begin{shaded}
    \textbf{Churchse These} \\
    Die durch die formale Definition der \emph{Turing-Berechenbarkeit} (äquivalent: \emph{\textsc{While}-Berechenbarkeit, \textsc{Goto}-Berechenbarkeit, $\mu$-Rekursivität}) erfasste Klasse von Funktionen stimmt genau mit der im intuitiven Sinne berechenbaren Funktionen überein.
\end{shaded}

\section*{Turing-Berechenbarkeit}
\begin{shaded}
    Eine Funktion $f:\mathds{N}^k\to \mathds{N}$ heisst \emph{Turingberechenbar}, falls es eine (deterministische) Turingmaschine $M$ gibt, so dass für alle $n_1,\dots,n_k,m\in \mathds{N}$ gilt:
    \[ f(n_1,\dots n_k) = m \] \textbf{genau dann, wenn} \[ z_0 bin(n_1)\#bin(n_2)\#\dots\#bin(n_k)\vdash^* \square\dots\square z_e bin(m)\square\dots\square \] wobei $z_e\in E$, $bin(n)$ ist die binäre Darstellung der Zahl $n\in \mathds{N}$.
\end{shaded}
\begin{shaded}
    Eine Funktion $f:\Sigma^*\to\Sigma^*$ heisst \emph{Turingberechenbar}, falls es eine (deterministische) Turingmaschine $M$ gibt, so dass für alle $x,y\in\Sigma^*$ gilt:
    \[ f(x)=y \] genau dann wenn \[ z_0x\vdash^*\square\dots\square z_e\square\dots\square\] wobei $z_e\in E$
\end{shaded}

Man beachte, dass beide Definitionen die Turingmaschine in eine Endlosschleife übergehen kann, wenn $f(x)=undefiniert$.

\section*{LOOP-, WHILE- und GOTO-Berechenbarkeit}
\subsection*{LOOP-Programme}
\begin{description}
    \item[Variablen:] $x_0\;x_1\;x_2\;\dots$
    \item[Konstanten:] $0\;1\;2\;\dots$
    \item[Trennsymbole:] $;\; :=$
    \item[Operationszeichen] $+\;-$
    \item[Schlüsselwörter:] \textsc{Loop}, \textsc{Do}, \textsc{End}
\end{description}

\begin{shaded}
    Eine Funktion $f: \mathds{N}^k\to \mathds{N}$ heisst \textsc{Loop}-berechenbar, falls es ein \textsc{Loop}-Programm $P$ gibt, dass $f$ in dem Sinne berechnet, dass $P$, gestartet mit $n_1,\dots,n_k$ in den Variablen $x_1,\dots,x_k$ (und $0$ in den restlichen Variablen) stoppt mit dem Wert $f(n_1,\dots,n_k)$ in der Variablen $x_0$.
\end{shaded}

\subsection*{WHILE-Programme}
Wir erweitern \textsc{Loop}-Programme durch das Konzept der \textsc{While}-Schleife: \[ WHILE x_i\not=0 DO P END \]

\begin{shaded}
    Eine Funktion $f:\mathds{N}^k\to \mathds{N}$ heisst \textsc{While}-berechenbar, falls es ein \textsc{While}-Programm gibt $P$ gibt, das $f$ in dem Sinne berechnet, dass $P$, gestartet mit $n_1,\dots,n_k$ in den Variablen $x_1,\dots,x_k$ (und 0 in den restlichen Fällen) stoppt mit dem Wert $f(n_1,\dots,n_k)$ in der Variablen $x_0$, sofern $f(n_1,\dots,n_k)$ definiert ist, ansonsten stoppt $P$ nicht.
\end{shaded}

\begin{shaded}
    Turingmaschinen können \textsc{While}-Programme simulieren. Dass heisst, jede \textsc{While}-berechenbare Funktion ist auch Turing-berechenbar.
\end{shaded}

\subsection*{GOTO-Programme}
\textsc{Goto}-Programme bestehen aus Sequenzen von Anweisungen $A_i$, die jeweils durch eine Marke $M_i$ eingeleitet werden: \[ M_1:A_1;\;M_2:A_2;\;\dots;\;M_k:A_k \] Als mögliche Anweisungen $A_i$ sind zugelassen:
\begin{description}
    \item[Wertzuweisungen:]  $x_i:=x_j\pm c$
    \item[unbedingter Sprung:] \textsc{Goto} $M_i$
    \item[bedingter Sprung:] \textsc{If} $x_i=c$ \textsc{Then Goto} $M_j$
    \item[Stopanweisung] \textsc{Halt}
\end{description}

\begin{shaded}
    Jedes \textsc{While}-Programm kann durch ein \textsc{Goto}-Programm simuliert werden. Das heisst, jede \textsc{While}-berechenbare Funktion ist auch \textsc{Goto}-berechenbar.
\end{shaded}

\begin{shaded}
    Jedes \textsc{Goto}-Programm kann durch ein \textsc{While}-Programm (mit nur einer \textsc{While}-Schleife) simuliert werden. Also ist jede \textsc{Goto}-berechenbare Funktion auch \textsc{While}-berechenbar
\end{shaded}

\begin{shaded}
    \textbf{Kleensche Normalform für \textsc{While}-Programme} \\
    Jede \textsc{While}-berechenbare Funktion kann durch ein \textsc{While}-Programm mit nur einer \textsc{While}-Schleife berechnet werden.
\end{shaded}

\begin{shaded}
    \textsc{Goto}-Programme können Turingmaschinen simulieren. Also ist jede Turingberechenbare Funktion auch \textsc{Goto}-berechenbar.
\end{shaded}
\begin{center}
\input{images/berechenbarkeit.tikz}
\end{center}

\subsection*{Primitiv und $\mu$-rekursive Funktionen}
\red{Prüfungsrelevant?}

\subsection*{Halteproblem, Unentscheidbarkeit, Reduzierbarkeit}

\begin{shaded}
    Eine Menge $A\subseteq\Sigma^*$ heisst \emph{entscheidbar}, falls die \emph{charakteristische Funktion} von $A$, nämlich $\chi_A:\Sigma^*\to\{0,1\}$, berechenbar ist. Hierbei gilt für alle $w\in\Sigma^*$:
    \[
    \chi_A(w)=
    \begin{cases}
        1, & w\in A \\
        0, & w\not\in A
    \end{cases}
    \]

    Eine Menge $A\subseteq\Sigma^*$ heisst \emph{semi-entscheidbar}, falls die \emph{"`halbe"' charakteristische Funktion} von $A$, nämlich $\chi_A:\Sigma^*\to\{0,1\}$, berechenbar ist. Hierbei gilt für alle $w\in\Sigma^*$:
    \[
    \chi_A(w)=
    \begin{cases}
        1, & w\in A \\
        undefiniert, & w\not\in A
    \end{cases}
    \]
\end{shaded}

\begin{center}
\scalebox{0.75}{\input{images/entscheid.tikz}}
\end{center}

\begin{shaded}
    Eine Sprache $A$ ist genau dann entscheidbar, wenn sowohl $A$, als auch $\overline{A}$ semi-entscheidbar sind.
\end{shaded}
\begin{shaded}
    Eine Sprache ist genau dann semi-entscheidbar, wenn sie rekursiv aufzählbar ist.
\end{shaded}

Äquivalente Aussagen:
\begin{itemize}
    \item $A$ ist rekursiv aufzählbar.
    \item $A$ ist semi-entscheidbar.
    \item $A$ ist vom Typ 0.
    \item $A=T(M)$ für Turingmaschine $M$
    \item $\chi'_A$ ist (Turing-, \textsc{While}-, \textsc{Goto-}) berechenbar.
    \item $A$ ist Definitionsbereich einer berechenbaren Funktion.
    \item $A$ ist Wertebereich einer berechenbaren Funktion.
\end{itemize}

\subsubsection*{Halteproblem}
Turingmaschinen sind als Wort schreibbar. Dazu nummerieren wir Elemente von $\Gamma$ und $Z$ durch. Hierbei sei festgelegt, welche Nummern die Symbole $\square,0,1,\#$ sowie Start- und Endzustände erhalten.
\begin{align*}
\Gamma &= \{a_0,a_1,\dots,a_k\} \\
Z &= \{z_0,z_1,\dots,z_k\}
\end{align*}
Jeder $\delta$-Regel ordnen wir ein Wort zu
\[
\delta(z_i,a_j) = (z_{i'},a_{j'},y)
\Rightarrow w_{i,j,i',j',y} = \#\#bin(i)\#bin(j)\#bin(i')\#bin(j')\#bin(m)
\]
wobei
\[
m=
\begin{cases}
    0, & y=R \\
    1, & y=L \\
    2, & y=N
\end{cases}
\]
Somit erhalten wir einen Code für die Turingmaschine über dem Alphabet $\{0,1,\#\}$. Sei $\hat M$ eine beliebige, feste Turingmaschine. Dann können wir für jedes Wort $w\in\{0,1\}^*$ festlegen, dass $M_w$ eine Turingmaschine bezeichnet:
\[
M_w=
\begin{cases}
    M, &\text{ falls } w \textrm{ Codewort von } M \textrm{ ist}\\
    \hat M, & \textrm{sonst}
\end{cases}
\]

\begin{shaded}
    Unter dem \emph{speziellen Halteproblem} oder \emph{Selbstanwendbarkeitsproblem} verstehen wir die Sprache
    \[ K=\{w\in\{0,1\}^* | M_w \textrm{ angesetzt auf } w \textrm{ hält (im Endzustand)}\} \]
\end{shaded}

\begin{shaded}
    Das spezielle Halteproblem ist nicht entscheidbar.
\end{shaded}

\subsubsection*{Reduktion}
\begin{shaded}
    Seien $A\subseteq\Sigma^*$ und $B\subseteq\Gamma^*$ Sprachen. Dann heisst \emph{$A$ auf $B$ reduzierbar} - symbolisch mit $A\leq B$ bezeichnet - falls es eine totale und berechenbare Funktion $f:\Sigma^*\to\Gamma^*$ gibt, so dass für alle $x\in\Sigma^*$ gilt:
    \[ x\in A \Longleftrightarrow f(x)\in B \]
\end{shaded}

\begin{shaded}
    Falls $A\leq B$ und $B$ entscheidbar (bzw. semi-entscheidbar), dann ist auch $A$ entscheidbar (bzw- semi-entscheidbar).
\end{shaded}

\begin{shaded}
    Das (allgemeine) Halteproblem ist die Sprache \[H=\{w\#x | M_w \textrm{ angesetzt auf } w \textrm{ hält}\} \]
    Das allgemeine Halteproblem $H$ ist nicht entscheidbar.\\
    {\tiny $K\leq H$, da K Spezialfall von H}
\end{shaded}

\begin{shaded}
    Das Halteproblem auf leerem Band ist die Sprache \[H=\{w\#x | M_w \textrm{ angesetzt auf } w \textrm{ hält}\} \] \\
    Das Halteproblem auf leerem Band $H_0$ ist nicht entscheidbar. \\
    {\tiny $H\leq H_0$, da Turingmaschine einfach das nichtleere Band von $H$ auf das leere Band von $H_0$ schreiben kann.}

    \begin{shaded}
        \textbf{Satz von Rice}\\
        Sei $\mathcal{R}$ die Klasse aller Turing-berechenbaren Funktionen. Sei $\mathcal{S}$ eine \emph{beliebige} Teilmenge hiervon (ausgenommen $\mathcal{S}=\emptyset$ und $\mathcal{S}=\mathcal{R}$). Dann ist die Sprache \[ C(\mathcal{S} = \{w | \textrm{ die von } M_w \textrm{ berechnete Funktion liegt in } \mathcal{S}\} \] unentscheidbar.
    \end{shaded}
\end{shaded}

\subsection*{Das Postsche Korrespondenzproblem (PCP)}
\begin{description}
    \item[gegeben:] Eine endliche Folge von Wortpaaren $(x_1,y_1), (x_2,y_2),\dots,(x_k,y_k)$, wobei $x_i,y_i\in\Sigma^+$.
    \item[gefragt:] Gibt es eine Folge von Indizes $i_1,i_2,\dots,i_n\in\{1,2,\dots,k\},n\geq1$, mit $x_{i_1},x_{i_2},\dots,x_{i_n} = y_{i_1},y_{i_2},\dots,y_{i_n}$?
\end{description}
Das \textsc{Pcp} ist semi-entscheidbar {\tiny Immer längere Indexfolgen daraufhin untersuchen, ob sie Lösung sind.}.
\subsubsection*{modifiziertes Postsches Korrespondenzproblem (MPCP)}
\begin{description}
    \item[gegeben:] wie \textsc{Pcp}
    \item[gefragt:] Gibt es eine Lösung $i_1,i_2,\dots,i_n$ mit $i_1=1$
\end{description}

$\textsc{Mpcp} \leq \textsc{Pcp}$ und $H\leq \textsc{Mpcp} $

\begin{shaded}
\ \\
    Das Postsche Korrespondenzproblem ist untentscheidbar.\\[.5cm]
    Das Postsche Korrespondenzproblem ist bereits untentscheidbar, wenn man sich auf das Eingabealphabet $\{0,1\}$ beschränkt.
\end{shaded}

\subsection*{Unentscheidbare Grammatik-Probleme}
\red{nicht Prüfungsrelevant}
\subsection*{Der Gödelsche Satz}
\red{nicht Prüfungsrelevant}

\part*{Komplexitätstheorie}
\subsection*{Komplexitätsklasse und P-NP-Problem}
\begin{shaded}
    Sei $f:\mathds{N}\to \mathds{N}$ eine Funktion. Die Klasse $TIME(f(n))$ besteht aus allen Sprachen $A$, für die es eine deterministische Mehrbandturingmaschine $M$ gibt mit $A=T(M)$ und $time_M(x)\leq f(|x|)$.\\
    Hierbei bedeutet $time_M:\Sigma^*\to \mathds{N}$ die Anzahl der Rechenschritte von $M$ bei Eingabe $x$.
\end{shaded}

\begin{shaded}
    Ein \emph{Polynom} ist eine Funktion $p:\mathds{N}\to \mathds{N} $ der Form \[ p(n)=a_kn^k+a_{k-1}n^{k-1}+\dots+a_1n+a_0, a_i\in \mathds{N}, k\in \mathds{N} \]
    Die \emph{Komplexitätsklasse $\mathsf{P}$} ist wie folgt definiert:
    \begin{align*}
        \mathsf{P} &= \{A | \textrm{ es gibt eine Turingmaschine } M \textrm{ und ein Polynom } p \textrm{ mit } T(M)=A \textrm{ und } time_M(x)\leq p(|x|) \} \\
        &= \underset{p \textrm{ Polynom}}{\bigcup} TIME(p(n))
    \end{align*}
\end{shaded}

\begin{shaded}
    Die Klasse $\mathsf{P}$ (ebenso wie größere Komplexitätsklassen wie $TIME(2^n)$ oder $TIME\left(\left.2^{2^{\dots^{2^2}}}\right\}n\textrm{-mal}\right) $ ) sind immer noch in der Klasse der primitiv rekursiv bzw \textsc{Loop}-berechenbaren Sprachen enthalten
\end{shaded}

\begin{shaded}
    Für nichtdeterministische Turingmaschinen $M$ sei
    \[ ntime_M(x)=
    \begin{cases}
        min \textrm{ Länge einer akzeptierenden Rechnung von } M \textrm{ auf } x, & x\in T(M) \\
        0, & x\not\in T(M) \\
    \end{cases}
     \]
     Sei $f:\mathds{N}\to \mathds{N}$ eine Funktion. Die Klasse $NTIME(f(n))$ besteht aus allen Sprachen $A$, für die es eine \emph{nichtdeterministische} Mehrband-Turingmaschine $M$ gibt mit $A=T(M)$ und $ntime_M(x)\leq f(|x|)$. \\
     Weiter definieren wir
     \[ \mathsf{NP} = \underset{p \textrm{ Polynom}}{\bigcup} NTIME(p(n)) \]
\end{shaded}

\subsubsection*{\textsf{P-NP}-Problem}
\begin{description}
    \item[bekannt:] $\textsf{P} \subseteq \textsf{NP}$
    \item[erhofft:] $\textsf{P} = \textsf{NP}$
    \item[vermutet:] $\textsf{P} \not= \textsf{NP}$
\end{description}

\begin{center}
\scalebox{.75}{\input{images/komplexitaet.tikz}}
\end{center}

\subsection*{\textsf{NP}-Vollständigkeit}
\begin{shaded}
    Seien $A\subseteq\Sigma^*$ und $B\subseteq\Gamma^*$ Sprachen. Dann heisst \emph{$A$ auf $B$ polynomial reduzierbar} - symbolisch mit $A\leq_p B$ bezeichnet - falls es eine totale und mit polynomieller Komplexität berechenbare Funktion $f:\Sigma^*\to\Gamma^*$ gibt, so dass für alle $x\in\Sigma^*$ gilt:
    \[ x\in A\Longleftrightarrow f(x)\in B \]
    Falls $A\leq_p B$ und $B\in\mathsf{P}$ (bzw. $B\in\mathsf{NP}$), so ist auch $A\in\mathsf{P}$ (bzw. $A\in\mathsf{NP}$)
\end{shaded}

\begin{shaded}
\ \\
    Eine Sprache $A$ heisst \emph{\textsf{NP}-hart}, falls für alle Sprachen $L\in\mathsf{NP}$ gilt: $L\leq_p A$. \\[.5cm]
    Eine Sprache $A$ heisst \emph{\textsf{NP}-vollständig}, falls $A$ \textsf{NP}-hart ist und $A\in\mathsf{NP}$ gilt.
\end{shaded}

\begin{shaded}
    Sei $A$ \textsf{NP} vollständig. Dann gilt $A\in P \Leftrightarrow \mathsf{P} = \mathsf{NP}$. {\tiny falls es einnmal so wäre\dots}
\end{shaded}

\begin{center}
\scalebox{.75}{\input{images/np-vollst.tikz}}
\end{center}

\subsubsection*{\textsf{NP}-vollständige Probleme}
\begin{shaded}
    Das \emph{Erfüllbarkeitsproblem der Aussagenlogik}, kurz \textsc{Sat}, ist das Folgende:
    \begin{description}
        \item[gegeben:] eine Formel $F$ der Aussagenlogik
        \item[gefragt:] Ist $F$ erfüllbar, d.h. gibt es eine Belegung der Variablen mit Konstanten $\in\{0,1\}$, so dass $F$ den Wert $1$ erhält?
    \end{description}
    \[\textsc{Sat}=\{code(F)\in\Sigma^* | F \textrm{ ist eine erfüllbare Formel der Aussagenlogik} \}\]
    \[\Sigma=\{(,),\neg, \wedge,\vee,\times,0,1 \} \]
    Das Erfüllbarkeitsproblem derAussagenlogik, \textsc{Sat} , ist \textsf{NP}-vollständig.

\end{shaded}

\begin{center}
\scalebox{.75}{\input{images/np-probs.tikz}}
\end{center}

\end{document}