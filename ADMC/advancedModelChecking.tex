\documentclass[a4paper, 10pt]{article}

%\usepackage{scalefnt}
%\usepackage{parcolumns}

\usepackage{newclude}
\include{../zusammenfassung}


% \newmdenv[%
% roundcorner=5pt,
% subtitlebelowline=true,subtitleaboveline=true,
% subtitlebackgroundcolor=yellow!70!white,
% backgroundcolor=blue!20!white,
% frametitle={Theorem},frametitlerule=true,
% frametitlebackgroundcolor=yellow!70!white,
% ]{subtitleenv}

\newcommand{\until}{\,\mathcal{U}\,}
\newcommand{\wuntil}{\,\mathcal{W}\,}
\renewcommand{\O}{\mathcal{O}}
\newcommand{\underbraceset}[2]{\underset{#1}{\underbrace{#2}}}

%line between multicols
\setlength{\columnseprule}{.5pt}

\begin{document}

\Gruppe{Stephan Heidinger}{ADMC - Zusammenfassung v0.9}
\Header{advanced Model Checking}{SS 14}{Stephan Heidinger}

% \begin{shaded}
% This document has been published under a Creative Commons - Attribution-NonCommercial-ShareAlike (\textbf{CC by-nc-sa}). The conditions of the licence can be found \href{http://creativecommons.org/licenses/by-nc-sa/3.0/}{here}. \\
% \centerline{\href{http://creativecommons.org/licenses/by-nc-sa/3.0/}{\includegraphics[scale=1]{../cc-by-nc-sa.png} } }
% \end{shaded}

\textit{\ensuremath{\overset{-\mkern-11mu-\mkern-3.5mu\rhook}{\smash{\odot}\rule{0ex}{.46ex}}\underline{\hspace{0.5em}}\overset{-\mkern-11mu-\mkern-3.5mu\rhook}{\smash{\odot}\rule{0ex}{.46ex}}}
Find any errors? Please send them back, I want to keep them!}

\section{Preliminaries}

\begin{definition}
Some things probably important:
\mdfsubtitle{Transformational Systems}
Transform set of input data into output data: $S_i\to S_k$. E.g. Compilers, database processing. \\
Correctness criteria: Termination, Correctness of $S_i\to S_k$
\mdfsubtitle{Reactive Systems}
Ongoing interaction with environment, driven by events/stimuli. E.g. Operating Systems, Control Systems.\\
Correctness: non-termination, correctness of stimuli-response pair.
\mdfsubtitle{Embedded Systems}
Usually reactive systems, tightly connected to the hardware they control.
\mdfsubtitle{Cyber-Physical systems}
Integration of computation and physical processes, often networked, e.g. sensor-/actuator systems, automotive control systems.
\mdfsubtitle{Real-Time Systems}
Correctness depends on time bounds:
\begin{description}
    \item[soft:] violating soft time bounds will decrease quality of system.
    \item[hard:] violating hard time bounds will make the system fail.
\end{description}
\mdfsubtitle{Hybrid systems}
Systems characterized by discrete and continuous variables. E.g. thermostat, \dots
\mdfsubtitle{Fault}
Mistake made by a human during software development/production.
\mdfsubtitle{Failure}
Behaviour of a system deviating from its specified behaviour. This is most often the result of a fault being executed.
\mdfsubtitle{Safety-Critical Systems}
When a safety-critical system fails, people, the environment or damage to property or assets may occur.
\end{definition}

\subsection{System Correctness}
When is a system correct?
\begin{enumerate}
    \item It does what we expect it to do. \follows functional model checking
    \item It does so in a timely manner. \follows real time or probabilistic model checking.
    \item It does so with a certain probability over a certain period of time. \follows probabilistic model checking.
\end{enumerate}

\begin{minipage}[t]{3cm}
\begin{center}
\scalebox{1}{\input{images/model-spec.tikz}}
\end{center}
\end{minipage}
\begin{minipage}[t]{12cm}
\begin{itemize}
    \item Given a \blue{model} and a \red{specification}: \\ Does $\blue{M}\models\red{S}$?
    \item When every behaviour of \blue{M} is also behaviour of \red{S} this is the case. \follows Model does not reveal properties violating the specification.
    \item Model of course has to represent the behaviour of the system.
\end{itemize}
\end{minipage}

\section{CTL and CTL Model Checking}
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={State}
]
Characterizes the salient features of a system at a given point of observation. \follows A state can be observed as long as the features of interest don't change.
\end{mdframed}

\subsection{State-Based Modelling}
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={State Transition in Discrete Systems}
]
Instantaneous change of observed features of systems. Represents computation step.
\mdfsubtitle{real-time models}
time passes in a state \& state must be left when time-bound is reached
\mdfsubtitle{stochastic systems}
state transitions are labeled with probabilities
\mdfsubtitle{hybrid systems}
\begin{itemize}
    \item continuous state variables change in a state
    \item discrete state variables change during state transition
\end{itemize}
\end{mdframed}

State transitions:
\begin{itemize}
    \item In a given state a certain number of events are possible (Leading to several different successor states).
    \item Represent valid sequence of computations.
    \item They encode history information (a state can only be reached trough a series of transitions).
\end{itemize}

Guidelines:
\begin{description}
    \item[Abstraction:] Focus only on important facts, disregard the rest.
    \item[Simplicity:] Find simplest abstraction that still reveals phenomena of interest.
\end{description}

Characterization of reactive systems:
\begin{itemize}
    \item State of the system.
    \item State transitions (caused by events/stimuli).
    \item Reactions triggered by transitions
\end{itemize}

\subsection{Transition Systems}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Transition System}
]
A \emph{Transition System} TS is a tuple $(S,Act,\rightarrow, I, AP, L)$ where:\\
\begin{tabular}{ll}
$S$ & set of states\\
$Act$ & set of actions\\
$\rightarrow\subseteq S\times Act\times S$ & transition relation\\
$I\subseteq S$ & set of initial states\\
$AP$ & atomic propositions\\
$L:S\rightarrow 2^{AP}$ & labeling function\\
\end{tabular}
\begin{itemize}
    \item $(s,\alpha.s')$ can be written as $s\rightarrow^\alpha s'$ or $s\overset{\alpha}{\longrightarrow}s'$.
\end{itemize}
\end{mdframed}
\begin{center}
\scalebox{1.5}{\input{images/TS.tikz}}
\end{center}

Atomic Propositions:
\begin{itemize}
    \item logical representation of facts that may hold in a given state.
    \item AP set of all atomic propositions used in the system model.
\end{itemize}

Labeling functions:
\begin{itemize}
    \item which atomic propositions actually hold in a given state.
\end{itemize}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Predecessors and Successors}
]
\begin{align*}
Post(s,\alpha)&= \left\{ s'\in S | s\overset{\alpha}{\longrightarrow}s' \right\} &
Post(s) &= \bigcup_{\alpha\in Act} Post(s\alpha)
\\
Pre(s,\alpha)&= \left\{ s'\in S | s'\overset{\alpha}{\longrightarrow}s \right\} &
Pre(s) &= \bigcup_{\alpha\in Act} Pre(s\alpha)
\\
Post(C,\alpha) &= \bigcup_{s\in C} Post(s,\alpha) &
Post(C) &= \bigcup_{s\in C} Post(s) \text{ for } C\subseteq S
\\
Pre(C,\alpha) &= \bigcup_{s\in C} Pre(s,\alpha) &
Pre(C) &= \bigcup_{s\in C} Pre(s) \text{ for } C\subseteq S
\end{align*}
\mdfsubtitle{Terminal/Final State}
a state for which $Post(s)=\varnothing$
\mdfsubtitle{Action-Determinism}
A TS is \emph{action-deterministic}, iff for all $s,\alpha$
\begin{itemize}
    \item $|I|\leq 1$
    \item $|Post(s,\alpha)|\leq 1$
\end{itemize}
otherwise it is \emph{action-nondeterministic}. In other words: For every state $s$ and every action $\alpha$ there is at most one outgoing transition labeled with $\alpha$.
\mdfsubtitle{$AP-Determinism$}
A TS is \emph{$AP$-deterministic}, iff for all $s,A\in 2^{AP}$
\begin{itemize}
    \item $|I|\leq 1$
    \item $|Post(s)\cap\{ s'\in S | L(s')=A \} | \leq 1$
\end{itemize}
where $|Post(s)\cap\{ s'\in S | L(s')=A \}$ denotes the set of all equally labeled successors of $s$. In other words: For every state $s$, every successor state has a unique $AP$ labeling.
\end{mdframed}

Nondeterminism can be used to implement abstraction and concurrency.

\subsection{System Executions}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Finite Execution Fragment}
]
A \emph{finite execution fragment} $\varrho$ of TS is an alternating sequence of states and executions ending with a state:
\[ \varrho=s_0\alpha_1 s_2 \alpha_2\dots\alpha_n s_n \text{ such that } s_i\overset{\alpha_{i+1}}{\longrightarrow} s_{i+1} \text{ for all } 0\leq i<n \]
\mdfsubtitle{infinite execution fragment}
An \emph{infinite execution fragment} $\varrho$ of TS is an alternating sequence of states and executions ending with a state:
\[ \varrho=s_0\alpha_1 s_2 \alpha_2\dots \text{ such that } s_i\overset{\alpha_{i+1}}{\longrightarrow} s_{i+1} \text{ for all } 0\leq i \]
\mdfsubtitle{maximal execution fragment}
An execution fragment, that is
\begin{description}
    \item[either] finite and ending in terminal state
    \item[or] infinite.
\end{description}
\mdfsubtitle{initial execution fragment}
An execution fragment is initial, iff $s_0\in I$.
\mdfsubtitle{Execution}
A initial, maximal execution fragment.
\mdfsubtitle{Reachability}
State $s\in S$ is called \emph{reachable} in a TS, if there exists an initial, finite execution fragment $s_0\alpha_1 s_1\alpha_2\dots\alpha_n s_n$ such that $s_n=s$.\\
$Reach(TS)$ denotes the set of all reachable states in TS.
\mdfsubtitle{State Graph}
The \emph{State Graph} of TS, $G(TS)$, is the directed Graph $(V,E)$ with vertices $V=S$ and edges $E=\{s,s'\}\in S\times S | s'\in Post(s)\}$.
\mdfsubtitle{Transitive Post Hull}
\begin{align*}
Post^*(s) & \text{ is the set of states reachable from } s &
Post^*(C) &= \bigcup_{s\in C} Post^*(s), \text{ for } C\subseteq S \\
Pre^*(s) & \text{ is the set of states from which } s \text{ is reachable} &
Pre^*(C) &= \bigcup_{s\in C} Pre^*(s), \text{ for } C\subseteq S \\
Reach(TS) &= Post^*(I)
\end{align*}
\mdfsubtitle{Path fragments}
A \emph{path fragment} is an exeuction fragment without actions.
\mdfsubtitle{Finite Path fragments}
A \emph{Finite path fragment} $\hat{\pi}$ of $TS$ is a state sequence:
\[ \hat{\pi} = s_0s_1\dots s_n \text{ such that } s_{i+1}\in Post(s_i) \text{ for all } 0\leq i\leq n \text{ where } n\geq0\]
\mdfsubtitle{Infinite Path fragments}
An \emph{Infinite path fragment} $\hat{\pi}$ of $TS$ is a infite state sequence:
\[ \hat{\pi} = s_0s_1\dots \text{ such that } s_{i+1}\in Post(s_i) \text{ for all } i\geq 0 \]
\mdfsubtitle{Path}
A \emph{Path} is a maximal, initial path fragment
\mdfsubtitle{Trace}
When only registering the atomic propositions along execution, this is called a \emph{trace}.
\begin{align*}
\hat{\pi}&=s_0s_1\dots,s_n &
trace(\hat{\pi})&=L(s_0)L(s_1)\dots L(s_n)
\\
Traces(s) &= trace(Paths(s)) &
Traces(TS) &= \bigcup_{s\in I} Traces(s)
\\
Traces_{fin} &= trace(Paths_{fin}(s)) &
Traces_{fin}(s)(TS) &= \bigcup_{s\in I} Traces_{fin}(s)
\end{align*}
\end{mdframed}

\subsection{Structural Operational Semsantics}

Semantics of a program in terms of computation steps defined by transition system: \[ \frac{premise}{conclusion} \]
If the premise holds, the conclusion holds (and can be used to trigger a new inference rule).
Can be recursively applied \follows structural inductive creation.

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Interleaving}
]
\[ TS_1 ||| TS_2 = (S_1\times S_2, Act_1 \uplus Act_2,\longrightarrow, I_1\times I_2, AP_1\uplus AP_2, L) \]
    where $L(\langle s_1,s_2\rangle) = L_1(s_1) \cup L_2(s_2)$ and the transition relation $\longrightarrow$ is defined by:
    \begin{align*}
    \frac{s_1\overset{\alpha}{\longrightarrow}_1 \red{s'_1}}
    {\langle s_1,s_2\rangle\overset{\alpha}{\longrightarrow}\langle \red{s'_1},s_2\rangle}
    \text{ and }
    \frac{s_2\overset{\alpha}{\longrightarrow}_2 \red{s'_2}}
    {\langle s_1,s_2\rangle\overset{\alpha}{\longrightarrow}\langle s_1,\red{s'_2}\rangle}
    \end{align*}
\end{mdframed}

A Computation tree is obtained from transition system by unfolding operation:
\begin{itemize}
    \item $s_k$ is a successor node of $s_i$ in the computation tree, iff there is a transition from $s_i$ to $s_k$ in the transition system.
\end{itemize}

\subsection{Property Specification}

based on modal logic:
\begin{description}
    \item[$Lp$] it is \emph{necessary} that $p$
    \item[$Mp$] it is \emph{possible} that $p$
    \item[$\neg Lp$] it is \emph{not necessary} that $p$
    \item[$\neg Mp$] it is \emph{not possible} that $p$
\end{description}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Kripke-Structure}
]
Let
\begin{itemize}
    \item $M=W,V,A$ be a Kripke-Structure:
    \item $\Pi$ a set of atomic propositions and $p\in\Pi$
    \item $w,v\in W$
    \item $\Phi,\rho$ formulae
\end{itemize}
then we define the relation $\models$ (satisfaction relation) for $M$:
\begin{align*}
(M,w)&\models p & \iff&& A(w,p)&=true \\
(M,w)&\models\neg p& \iff&& A(w,p)&=false \\
(M,w)&\models\Phi\wedge\rho & \iff&& (M,w)&\models\Phi \text{ and } (M,w)\models \rho \\
(M,w)&\models L\Phi& \iff& & (\forall v:(w,v)&\in V)((M,v)\models\Phi) \\
(M,w)&\models M\Phi& \iff& & (\exists v:(w,v)&\in V)((M,v)\models\Phi)
\end{align*}

Further syntactic definitions:

\begin{align*}
\Phi&\vee\rho & \cong && &\neg(\neg\Phi\wedge\neg\rho) \\
\Phi&\supset\rho & \cong && &\neg\Phi\vee\rho & \text{\tiny implies}\\
\Phi&\equiv\rho & \cong && &(\Phi\supset\rho)\wedge(\rho\supset\Phi)\\
M\Phi& &\cong&& &\neg L\neg\Phi
\end{align*}
\end{mdframed}

In temporal logic:
\begin{itemize}
    \item $Mp$ corresponds to $\square p$
    \item $Lp$ corresponds to $\diamond p$
\end{itemize}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Computation Tree Logic Syntax (CTL Syntax)}
]
$a\in AP$
\\
CTL state formula $\Phi$:
\begin{align*}
true && \neg\Phi \\
a && \exists\upvarphi \\
\Phi_1\wedge\Phi_2 && \forall\upvarphi
\end{align*}
CTL path formula
\begin{align*}
\circ\Phi && \Phi_1\until\Phi_2
\end{align*}
To be syntactically correct, temporal operators and path quantifiers alternate.

Derived Operators:
\begin{align*}
potentially\ \Phi: && \exists\diamond\Phi&=\exists(true\until\Phi) \\
inevitably\ \Phi: && \forall\diamond\Phi&=\forall(true\until\Phi) \\
potentially\ always \Phi: && \exists\square\Phi&=\neg\forall\diamond\neg\Phi \\
invariantly\ \Phi: && \forall\square\Phi&=\neg\exists\diamond\neg\Phi \\
weak\ until\ \Phi: && \exists(\Phi\wuntil\Psi) &= \neg\forall((\Phi\wedge\neg\Psi)\until(\neg\Phi\wedge\neg\Psi)) \\
&& \forall(\Phi\wuntil\Psi)&=\neg\exists((\Phi\wedge\neg\Psi)\until(\neg\Phi\wedge\neg\Psi))
\end{align*}
\mdfsubtitle{Computation Tree Logic Semantic (CTL Semantic)}
CTL state formulae:
\begin{align*}
s&\models a & \iff& & a&\in L(s) \\
s&\models\neg\Phi &\iff& & \neg(s&\models\Phi) \\
s&\models\Phi\wedge\Psi &\iff&& (s&\models\Phi)\wedge(s\models\Psi) \\
s&\models\red\exists\varphi &\iff&& \pi&\models\varphi \text{ for \red{some} path $\pi$ that starts in $s$} \\
s&\models\red\forall\varphi &\iff&& \pi&\models\varphi \text{ for \red{all} path $\pi$ that starts in $s$} \\
\end{align*}
\mdfsubtitle{Satisfaction Set}
The satisfaction set $Sat(\Phi)$ for a CTL formula is defined by: \[ Sat(\Phi)=\{ s\in S| s\models\Phi \} \]
A $TS$ satisfies a CTL formula $\Phi$ if $\Phi$ holds in all initial states: \[ TS\models\Phi \; \iff\; \forall s_0\in I: s_0\models\Phi \]
\mdfsubtitle{CTL Equivalence}
CTL formulas $\Phi$ and $\Psi$ are \emph{equivalent}, $\Phi\equiv\Psi$ iff $Sat(\Phi)=Sat(\Psi)$.
\[ \Phi\equiv\Psi\;\iff\;(TS\models\Phi\,\iff\,TS\models\Psi) \]
\mdfsubtitle{Equivalence-based Rewrite Rules}
Duality Laws:
\begin{align*}
\forall\circ\Phi &\equiv \neg\exists\circ\neg\Phi \\
\exists\circ\Phi &\equiv \neg\forall\circ\neg\Phi \\
\forall\diamond\Phi &\equiv \neg\exists\square\neg\Phi \\
\exists\diamond\Phi &\equiv \neg\forall\square\neg\Phi \\
\forall(\Phi\until\Psi) &\equiv \neg\exists((\Phi\wedge\neg\Psi)\wuntil(\neg\Phi\wedge\neg\Psi))
\end{align*}
Expansion Laws:
\begin{align*}
\forall(\Phi\until\Psi) &\equiv \Psi\vee(\Phi\wedge\forall\circ\forall(\Phi\until\Psi)) \\
\forall\diamond\Phi &\equiv \Phi\vee\forall\circ\forall\diamond\Phi \\
\forall\square\Phi &\equiv \Phi\wedge\forall\circ\forall\square\Phi \\
\exists(\Phi\until\Psi) &\equiv \Psi\vee(\Phi\wedge\exists\circ\exists(\Phi\until\Psi)) \\
\exists\diamond\Phi &\equiv \Phi\vee\exists\circ\exists\diamond\Phi \\
\exists\square\Phi &\equiv \Phi\wedge\exists\circ\exists\square\Phi
\end{align*}
Distributive Laws:
\begin{align*}
\forall\square(\Phi\wedge\Psi) &\equiv \forall\square\Phi\wedge\forall\square\Psi \\
\exists\diamond(\Phi\wedge\Psi) &\equiv \exists\diamond\Phi\wedge\exists\diamond\Psi
\end{align*}
But:
\begin{align*}
\exists\square(\Phi\wedge\Psi) &\not\equiv \exists\square\Phi\wedge\exists\square\Psi \\
\forall\diamond(\Phi\wedge\Psi) &\not\equiv \forall\diamond\Phi\wedge\forall\diamond\Psi
\end{align*}
\end{mdframed}

\subsubsection{LTL}
\begin{missing}
    Definition and Explanation of LTL, see Model Checking aggregation.
\end{missing}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={CTL and LTL equivalence}
]
CTL formula $\Phi$ and LTL formula $\psi$ are \emph{equivalent}, $\Phi\equiv\psi$, iff for any transition system $TS$ over $AP$
\[ TS\models\Phi \iff TS\models\psi \]
\\
There can only be equivalent $\Phi$ and $\psi$ if by omitting all path quantifiers from $\Phi$ yields \[ \Phi\equiv\psi \] otherwise there does not exist an equivalent LTL formula.
\\
\follows LTL and CTL have incomparable expressiveness.
\end{mdframed}

\subsubsection{CTL*}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={CTL$^*$}
]
State formula: $\Phi\;:=\;true\;|\;a\;|\;\Phi_1\wedge\Phi_2\;|\;\neg\Phi\;|\;\exists\varphi$
\\
path formula: $\varphi\;:=\;\Phi\;|\varphi_1\wedge\varphi_2\;|\;\neg\varphi\;\circ\varphi\;|\varphi_1\until\varphi_2$
\mdfsubtitle{CTL$^*$ Semantics}
\begin{align*}
s&\models a &\iff&& a&\in L(s) \\
s&\models \neg\Phi &\iff&& not\,s&\models\Phi \\
s&\models \Phi\wedge\Psi &\iff&& (s&\models\Phi) \text{ and }(s\models\Psi) \\
s&\models \exists\varphi &\iff&& \pi&\models\varphi \text{ for some } \pi\in Paths(s)\\
\pi&\models\Phi &\iff&& \pi[0]&\models\Phi\\
\pi&\models \varphi_1\wedge\varphi_2 &\iff&& \pi&\models\varphi_1 \text{ and } \pi\models\varphi_2\\
\pi&\models \neg\varphi &\iff&& \pi&\not\models\varphi\\
\pi&\models \circ\varphi &\iff&& \pi[1..]&\models\varphi\\
\pi&\models \varphi_1\until\varphi_2&\iff&& \exists j&\geq0.(\pi[j..]\models\varphi_2\wedge(\forall 0\leq k<j.\pi[k..]\models\varphi_1))
\end{align*}
Satisfaction set and TS satisfaction is same as for CTL.
\begin{center}
\scalebox{1}{\input{images/ltlctlctlstar.tikz}}
\end{center}
\end{mdframed}

\subsubsection{CTL Model Checking Procedure}

\begin{enumerate}
    \item convert CTL formula $\Phi'$ into an equivalent CTL formula $\Phi$ in \emph{Existential Normal Form (ENF)}
    \item recursively compute the set $Sat(\Phi)=\{s\in S|s\models\Phi\}$
    \item $TS\models\Phi$ iff \emph{each initial sate} of TS belongs to $Sat(\Phi)$
\end{enumerate}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={ENF Conversion}
]
ENF Subset of CTL:
\[ \Phi\;:=\;true\;|\;a\;|\;\Phi_1\wedge\Phi_2\;|\;\neg\Phi\;|\;\exists\circ\Phi\;|\;\exists(\Phi_1\until\Phi_2\;|\;\exists\square\Phi) \]
Conversion Rules:
\begin{align*}
\forall&\circ\Phi &\equiv&& \neg\exists&\circ\neg\Phi \\
\forall&(\Phi\until\Psi) &\equiv&& \neg\exists&(\neg\Psi\until(\neg\Phi\wedge\neg\Psi))\wedge\neg\exists\square\neg\Psi
\end{align*}
\mdfsubtitle{Computation of $Sat(\Phi)$}
\begin{multicols}{2}
\begin{enumerate}
    \item create \emph{parse tree} from formula
    \item compute $Sat(a_i)$ for leaf nodes
    \item move up in the parse tree by level, computing $Sat(.)$ from child nodes
    \item when all root tree is computed, check if $I\in Sat(\Phi)$
\end{enumerate}
\begin{center}
\scalebox{1}{\input{images/parse-tree.tikz}}
\end{center}
\end{multicols}
Computation of $Sat(a_i)$
\begin{align*}
Sat(true) &= S \\
Sat(a) &= \{s\in S | a\in L(s)\} \text{ for any } a\in AP \\
Sat(\blue\Phi\wedge\red\Psi) &= Sat(\blue\Phi) \cap Sat(\red\Psi) \\
Sat(\neg\Phi) &= S\setminus Sat(\Phi) \\
Sat(\exists\circ\Phi) &= \{s\in S | Post(s)\cap Sat(\Phi)\not=\varnothing\} \\
%
Sat(\exists(\blue\Phi\until\red\Psi)) &\text{ is the smallest subset $T$ of $S$, such that } \\
&Sat(\red\Psi)\subseteq T \text{ and} \\
&(s\in Sat(\blue\Phi) \text{ and } Post(s)\cap T\not=\varnothing)\Rightarrow s\in T \\
%
Sat(\exists\square\Phi) &\text{ is the largest subset $T$ of $S$, such that} \\
&T\subseteq Sat(\Phi) \text{ and} \\
&s\in T \longrightarrow Post(s)\cap T\not=\varnothing
\end{align*}
smallest Fixpoint calculation: $\exists(\Phi_1\until\Phi_2)$\\
\begin{algorithm}[H]
$T:=Sat(\Phi_2);$ \\
\While{$\{ s\in Sat(\Phi_1)\setminus T | Post(s)\cap T\not=\varnothing\}\not=\varnothing$}{
    $\{ s\in Sat(\Phi_1)\setminus T | Post(s)\cap T\not=\varnothing\}\not=\varnothing$ \\
    $T:=T\cup\{ s \}$
}
\end{algorithm}
\ \\
greatest Fixpoint calculation: $\exists\square\Phi$\\
\begin{algorithm}[H]
$T:=Sat(\Phi)$ \\
\While{$\{s\in T | Post(s)\cap T=\varnothing\}\not=\varnothing$}{
    let $\{s\in T | Post(s)\cap T=\varnothing\}$ \\
    $T:=T\setminus\{s\}$;
}
\end{algorithm}
\ \\ Compute $Sat(\exists(\blue\Phi\until\red\Psi))$ by \emph{Enumerative Backward Search} \\
\begin{algorithm}[H]
$T:=Sat(\red\Psi);$ \\
$E:=T$\\
\While{$E\not=\varnothing$}{
    $s'\in E;$ \\
    $E:=E\setminus\{s'\};$ \\
    \For{ all $s\in Pre(s')$ }{
    \If{$s\in Sat(\blue\Phi)\setminus T$}{
        $E:=E\cup \{s\};$ \\
        $T:=T\cup\{s\};$
        }
    }
}
\Return T
\end{algorithm}
\ \\ Compute $Sat(\exists\square\Phi)$ by \emph{Enumerative Backwards Search} \\
\begin{algorithm}[H]
$E:=S\setminus Sat(\Phi)$ \tcc*{$E$ contains any unvisited $s'$ with
$s'\not\models\exists\square\Phi$}
$T:=Sat(\Phi)$ \tcc*{$T$ contains any $s$ for which $s\models\exists\square\Phi$ is not disproven}
\For{all $s\in Sat(\Phi)$}{
    $c[s]:= |Post(s)|;$
}
\While{$E\not=\varnothing$}{
    $s'\in E;$ \\
    $E:=E\setminus\{s'\};$ \tcc*{$s'$ has been considered}
    \For{all $s\in Pre(s')$}{
        \If{$s\in T$}{
            $c[s]:=c[s]-1;$ \tcc*{update counter $c[s]$ for predecessor $s$ of $s'$}
            \If{$c[s]=0$}{
                $T:=T\setminus\{s\};$ \\
                $E:=E\cup\{s\}$
            }
        }
    }
}
\Return T
\end{algorithm}
\ \\ Alternative Algorithm for $Sat(\exists\square\Phi)$: \\
\begin{enumerate}
    \item Consider state $s$ only if $s\models\Phi$, otherwise \emph{eliminate} $s$
    \begin{itemize}
        \item change $TS$ into $TS[\Phi]=(S',Act,\to',I',AP,L')$ with $S'=Sat(\Phi)$
        \item $\to'=\to\cap(S'\times Act\times S'), I'=I\cap S', L'(s)=L(s)$ for $s\in S'$
        \item[\follows] all removed states do not satisfy $\exists\square\Phi$ and can therefore be removed
    \end{itemize}
    \item Dtermine all \emph{non-trivial strongly connected components} in $TS[\Phi]$
    \begin{itemize}
        \item non-trivial SCC \follows maximal, connected subgraph with at least one transition
        \item[\follows] any state in such SCC satisfies $\exists\square\Phi$
    \end{itemize}
    \item $s\models\exists\square\Phi$ is equivalent to ``some SCC is reachable from $s$''
    \begin{itemize}
        \item simple reachability search (backward manner)
    \end{itemize}
\end{enumerate}
\end{mdframed}

\subsubsection{Time Complexity}

The CTL Model Checking Problem $TS\models\Phi$ can be determined in $\mathcal{O}(|\Phi|\cdot(N+M)$, where $N$ is the number of states and $M$ the number of transitions, $N+M$ is the size of the transition system, which can be exponentially large.
\\
LTL Model Checking can be done in $\mathcal{O}((N+M)\cdot 2^{|\Phi|}$. But LTL formulae can be exponentially shorter.

\subsubsection{Counterexamples}

\begin{missing}
    Counterexamples in LTL, see Model Checking aggregation.
\end{missing}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Counterexample and Witnesses}
]
\begin{itemize}
    \item counterexample: path fragment $s\to s'$ such that
    \begin{itemize}
        \item $s\in I$ and $s'\in Post(s)$ with $s'\not\models\Phi$
    \end{itemize}
    \item witness: a path fragment $s\to s'$ such that
    \begin{itemize}
        \item $s\in I$ and $s'\in Post(s)$ with $s'\models\Phi$
    \end{itemize}
    \item algorithmic computation: Inspection of direct successors of initial states.
\end{itemize}
\mdfsubtitle{Witness for $\Phi\until\Psi$}
backwards search starting in $Sat(\Psi)$
\mdfsubtitle{Counterexample for $\Phi\until\Psi$}
has one of the forms:
\begin{itemize}
    \item $\underset{\text{satisfy } \Phi\wedge\neg\Psi}{\underbrace{s_0\dots s_{n-1}\underset{cycle}{\underbrace{s_ns_1'\dots s'_r}}}}$ with $s_n=s'_r$ (would work for $\wuntil$, but not $\until$)
    \item $s_0\dots s_{n-1}s_n$ where $s_n\models\neg\Phi\wedge\neg\Psi$
\end{itemize}
Computing Counterexample:
\begin{itemize}
    \item let $G=(S,E)$ a directed graph, where $S$ is the set of states of the $TS$ and $E=\{(s,s')\in S\times S | s'\in Post(s)\wedge s\models\Phi\wedge\neg\Psi\}$
    \item Each path in $G$ starting in an $s_0\in I$ leading to an trivial or non-trivial SCC yields a counterexample.
    \item[\follows] counterexample generation requires SCC computation (e.g. Tarjans Algorithm)
\end{itemize}
\end{mdframed}

\section{CTL* Model Checking}
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={CTL$^*$ Model Checking}
]
Follow same recursive pattern using parse tree as for CTL model checking.
\\
\begin{itemize}
    \item replace maximal proper state formula by new proposition $a_\Psi$
    \item $\Psi$ is a \emph{maximal proper state subformula} of $\Phi$ whenever $\Psi$ is a subformula of $\Phi$ that differs from $\Phi$ and that is not contained in any other proper state formula of $\Phi$.
    \item adjust labeling of $TS$ such that $a_\Psi\in L(s)$ iff $s\in Sat(\Psi)$
    \item[\follows] LTL formula \[ s\models\exists\varphi \;\iff\; s\not\models_{CTL^*}\forall\neg\varphi \;\iff\; s\not\models_{LTL}\neg\varphi \]
\end{itemize}
\mdfsubtitle{Algorithm}
\begin{algorithm}[H]
\For{all $i\leq|\Phi|$}{
    \For{all $\Psi\in Sub(\Phi)$ with $|\Psi|=i$}{
        \Switch{$\Psi$}{
            \begin{align*}
            true &:& Sat(\Psi)&:=S \\
            a &:& Sat(\Psi)&:=\{s\in S|a\in L(s)\}; \\
            a_1\wedge a_2 &:& Sat(\Psi)&:=Sat(a_1)\cap Sat(a_2); \\
            \neg a &:& Sat(\Psi)&:=S\setminus Sat(a); \\
            \exists\varphi &:& determine &\ Sat_{LTL}(\neg\varphi); \\
            \square\varphi &:& Sat(\Psi)&:=S\setminus Sat_{LTL}(\neg\varphi)
            \end{align*}
        }
        $AP:=AP\cup\{a_\Psi\};$ \tcc*{introduce fresh atomic proposition}
        replace $\Psi$ with $a_\Psi;$
        \For{all $s\in Sat(\Psi)$}{
            $L(s)\cup\{a_\Psi\};$
        }
    }
}
\Return $I\subseteq Sat(\Phi)$
\end{algorithm}
\end{mdframed}

\subsection{Time Complexity}

For transition systems with $N$ states and $M$ transitions the CTL$^*$ model checking problem $TS\models\Phi$ can be determined in $\mathcal{O}(N+M)\cdot2^{|\Phi|}$

\subsection{Fairness}
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Fairness}
]
\emph{Fairness Constraints} \follows rule out unrealistic executions by putting constraints on actions that occur along infinite executions
\begin{align*}
unconditional && \Rightarrow && strong && \Rightarrow && weak
\end{align*}
weak rules out the least executions\\
\emph{Fairness Assumptions \follows distinct constraints on distinct action sets}
\mdfsubtitle{Fairness Constraints}
\begin{description}
    \item[unconditional LTL fairness constraint:] $u_{fair} = \square\diamond\Psi$
    \item[strong LTL fairness constraint:] $s_{fair}=\square\diamond\Phi\longrightarrow\square\diamond\Psi$
    \item[weak LTL fairness constraint:] $w_{fair}=\diamond\square\Phi\longrightarrow\square\diamond\Psi$
\end{description}
\[ fair = u_{fair} \wedge s_{fair} \wedge w_{fair} \]
\begin{itemize}
    \item strong and unconditional fairness \follows solve contentions
    \item weak fairness \follows resolve nondeterminism
\end{itemize}
\begin{align*}
FairPaths_{fair}(s) &= \{\pi\in Paths(s) | \pi\models fair\} \\
FairTraces_{fair}(s) &= \{trace(\pi)|\pi\in FairPaths_{fair}(s)\} \\
s\models_{fair}\varphi &\text{ iff } \forall\pi\in FairPaths_{fair}(s).\pi\models \varphi \\
TS\models_{fair}\varphi &\text{ iff }\forall s_0\in I.s_0\models_{fair}\varphi
\end{align*}
For TS and LTL formula $\varphi$ and LTL fairness assumption $fair$:
\[ TS\models_{fair}\varphi \text{ iff } TS\models(fair\to\varphi) \]
\mdfsubtitle{Fairness in CTL}
\follows ignore unfair paths
\begin{description}
    \item[unconditional] $u_{fair} = \bigwedge_{0<i\leq k}\square\diamond\Psi$
    \item[strong:] $s_{fair} = \bigwedge_{0<i\leq k}(\square\diamond\Phi_i\to\square\diamond\Psi_i)$
    \item[weak] $w_{fair} = \bigwedge_{0<i\leq k}(\diamond\square\Phi_i\to\square\diamond\Psi_i)$
\end{description}
A \emph{CTL fairness} constraint is an \emph{LTL} formula over \emph{CTL formulas}
\[ Sat_{fair}(\Phi) = \{s\in S| s\models_{fair} \Phi\} \]
For transition system $TS$ without terminal states, a CTL formula $\Phi$ in ENF and CTL fairness assumption $fair$:
\begin{enumerate}
    \item establish whether $TS\models_{air}\Phi$
    \item use bottom-up CTL procedure to determine $Sat_{fair}(\Phi)$
    \begin{enumerate}
        \item replace CTL-state formulas in $s_{fair}$ by atomic propositions \[ s_{fair}:=\bigwedge_{0<i\leq k}(\square\diamond a_i \to \square\diamond b_i) \]
    \end{enumerate}
\end{enumerate}
\mdfsubtitle{Fair CTL Model Checking}
$s\models_{fair}\exists\circ a$ iff $\exists s'\in Post(s)$ with $s'\models a$ and $\underset{s'\models_{fair}\exists\square true}{\underbrace{FairPaths(s')\not=\varnothing}}$
\\
$s\models{fair}\exists(a\until a')$ iff there exists a finite path fragment $s_0s_1\dots s_{n-1}s_n\in Paths_{fin}(s)$ with $n\geq 0$ such that $s_i\models a$ for $0\leq i<n,s_n\models a'$ and $\underset{s'\models_{fair}\exists\square true}{\underbrace{FairPaths(s')\not=\varnothing}}$
\\
Model Checking with fairness can be reduced to:
\begin{itemize}
    \item Model Checking CTL
    \item computing $Sat_{fair}(\exists\square a)$ for $a\in AP$
\end{itemize}

Algorithm: \\
\begin{algorithm}[H]
compute $Sat_{fair}(\exists\square true) = \{s\in S | FairPaths(s)\not=\varnothing\}$
\For{all $s\in Sat_{fair}(\exists\square true)$}{
    $L(s) := L(s) \cup \{a_{fair}\}$
    \tcc*{compute $Sat_{fair}(\Phi)$}
}
\For{all $0<i\leq|\Phi|$}{
    \For{all $\Psi\in Sub(\Phi)$ with $|\Psi|=i$}{
    \Switch{$\Psi$}{
    \begin{align*}
        true   &&: & &Sat_{fair}(\Psi) &:= S;\\
        a      &&: & &Sat_{fair}(\Psi) &:= \{s\in S | a\in L(s)\}; \\
        \neg a &&: & &Sat_{fair}(\Psi) &:= S\setminus Sat_{fair}(a); \\
        a \wedge a' &&: & &Sat_{fair}(\Psi) &:= Sat_{fair}(a) \cap Sat_{fair}(a'); \\
        \exists\circ a &&: & &Sat_{fair}(\Psi) &:= Sat(\exists\circ(a\wedge\red{a_{fair}})); \\
        \exists(a\until a') &&: & &Sat_{fair}(\Psi) &:= Sat(\exists(a\until(a'\wedge\red{a_{fair}}))); \\
        \exists\square a &&: & &Sat_{fair}(\Psi) &:= compute \, Sat_{fair}(\exists\square a);
    \end{align*}
    }
    replace all occurrences of $\Psi$ (in $\Phi$) b< the fresh atomic proposition $a_\Psi$
    \For{all $s\in Sat_{fair}(\Psi)$}{
        $L(s):=L(s)\cup\{a_\Psi\}$
    }
    }
}
\Return $I\subseteq Sat_{fair}(\Phi)$
\end{algorithm}

Computation of $Sat_{fair}(\exists\square a)$:
\begin{itemize}
    \item Consider state $s$ only if $s\models a$, otherwise eliminate $s$
    \item $s\models_{fair}\exists\square a$ iff there is a non-trivial SCC $D$ in $TS[a]$ reachable from $s$: \[ D\cap Sat(a_i)=\varnothing \text{ or } D\cap Sat(b_i)\not=\varnothing \text{ for } 0<i\leq k \]
    \item $Sat_{sfair}(\exists\square a)=\{s\in S| Reach_{TS[a]}(s)\cap T\not=\varnothing\}$ where $T$ is the union of all non-trivial SSCs $C$ that contain $D$ satisfying above equation.
\end{itemize}
\mdfsubtitle{Time Complexity}
$TS$ with $N$ states and $M$ transitions, CTL formula $\Phi$, CTL fairness constraint $fair$ with $k$ conjuncts: \\
CTL model checking in $\O(|\Phi|\cdot(N+M)\cdot k)$
\end{mdframed}

\section{Real-Time Model Checking}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={soft real-time systems}
]
Violating soft real-time bounds does \emph{not} lead to invalidation of system. \follows ``quality of service'' requirements. Usually with probabilities attached (reach state X with probility of Y in Z time).
\mdfsubtitle{hard real-time systems}
Correctness of system depends on satisfying real-time constraints.
\mdfsubtitle{discrete time domain}
\begin{itemize}
    \item time advances in discrete steps
    \item actions only happen at natural time values \follows time domain $\mathds{N}$
\end{itemize}
\begin{description}
    \item[advantages]
    \begin{itemize}
        \item conceptually simple
        \item no need to change $TS$
        \item take LTL or CTL
        \item use traditional model checking algorithms
    \end{itemize}
    \item[disadvantages]
    \begin{itemize}
        \item fixed minimal delay granularity, between two points not observable
        \item not invariant to changes in time scale
        \item for asynchronous systems determination of mimimal delay hard
    \end{itemize}
\end{description}
\begin{itemize}
    \item time domain is dense
    \item infinite branching of computation tree
\end{itemize}
\mdfsubtitle{Clocks}
\begin{itemize}
    \item value increases while in a state
    \item may only be reset to zero
    \item can be referenced in constraints
    \item clocks increase at same pace (with rate $1$)
    \item[\follows] guards on edges
    \item[\follows] invariants on locations
\end{itemize}
\mdfsubtitle{Clock Constraints ($CC$)}
$c\in\mathds{N},\, x\in C,\, C \text{ set of clocks}$
\[ g:= x<c | x\leq c | x>c | x\geq c | g\wedge g \]
Clock constraints without any conjunctions are atomic: $ACC(C)$ \\
\follows \emph{rational} valued constraints can be translated into naturals by proper scaling.
\mdfsubtitle{Timed Automata}
$TA=(Loc,Act,C,\hookrightarrow,Loc_0,Inv,AP,L)$, where:
\begin{align*}
Loc & \text{ is a finite set of locations} \\
Loc_0 & \text{ is a set of initial locations} \\
C & \text{ is a finite set of clocks} \\
\hookrightarrow\subseteq Loc\times CC(C)\times Act\times2^C\times Loc & \text{ is a transition relation} \\
Inv: Loc\to CC(C) & \text{ is an invariant-assignement function} \\
L:Loc\to2^{AP} & \text{ is a labeling function} \\
\end{align*}
Edge $\ell \overset{g:\alpha, C}{\scalebox{5}[1]{$\hookrightarrow$}} \ell'$ means intuitively:
\begin{itemize}
    \item action $\alpha$ is enabled once guard $g$ holds
    \item when moving from $\ell$ to $\ell'$
    \begin{itemize}
        \item perform action $\alpha$
        \item reset any clock in $C$ to zero
        \item all clocks not in $C$ keep their value
    \end{itemize}
    \item Nondeterminism if multiple transitions are enabled
    \item $Inv(\ell)$ constraints amount of time that may be spent in location $\ell$
    \begin{itemize}
        \item once it becomes invalid, $\ell$ must be left
        \item if leaving is not possible, deadlock
    \end{itemize}
\end{itemize}
\mdfsubtitle{Composition}
$TA_i = (Loc_i,Act_i,C_i,\hookrightarrow_i,Loc_{0,i},Inv_i,AP_i,L_i)$ and handshake action set $H$:
\[ TA_1 \Vert_H TA_2= (Loc,Act_1\cup Act_2,C,\hookrightarrow,Loc_0,Inv,AP,L) \]
where
\begin{align*}
Loc   &= Loc_1\times Loc_2 \\
Loc_0 &= Loc_{0,1} \times Loc_{0,2} \\
C     &= C_1 \cup C_2 \\
Inv(\langle\ell_1,\ell_2\rangle) &= Inv_1(\ell_1) \wedge Inv_2(\ell_2) \\
L(\langle\ell_1,\ell_2)\rangle) &= L_1(\ell_1) \cup L_2(\ell_2)
\end{align*}
$\hookrightarrow$ is defined by
\begin{description}
    \item[$\alpha\in H$:] $\frac{
    \ell_1 \overset{g_1:\alpha, D_1}{\scalebox{5}[1]{$\hookrightarrow$}}_1 \ell'_1 \wedge \ell_2 \overset{g_2:\alpha, D_2}{\scalebox{5}[1]{$\hookrightarrow$}}_2 \ell'_2
    }{
    \langle\ell_1,\ell_2\rangle\overset{g_1\wedge g_2: \alpha, D_1\cup D_2}{\scalebox{5}[1]{$\hookrightarrow$}} \langle\ell_1,\ell_2\rangle
    }$
    \item[$\alpha\not\in H$:] $\frac{
    \ell_1 \overset{g_1:\alpha, D_1}{\scalebox{5}[1]{$\hookrightarrow$}}_1 \ell'_1
    }{
    \langle\ell_1,\ell_2\rangle\overset{g_1: \alpha, D_1}{\scalebox{5}[1]{$\hookrightarrow$}} \langle\ell_1,\ell_2\rangle
    }$
    and
    $\frac{
    \ell_2 \overset{g_2:\alpha, D_2}{\scalebox{5}[1]{$\hookrightarrow$}}_2 \ell'_2
    }{
    \langle\ell_1,\ell_2\rangle\overset{g_2: \alpha, D_2}{\scalebox{5}[1]{$\hookrightarrow$}} \langle\ell_1,\ell_2\rangle
    }$
\end{description}
\mdfsubtitle{Clock Valuations}
\begin{itemize}
    \item \emph{clock valuation} $\eta$ for set $C$ of clocks is a function $\eta:C\to\mathds{R}_{\geq0}$ assigning each clock $x\in C$ its current value $\eta(x)$
    \item $\eta+d$ for $d\in\mathds{R}_{\geq0}$ is defined by: $(\eta+d(x)=\eta(x)+d$ for all clocks $x\in C$
    \item $reset\,x$ in $\eta$ for clock $x$ is defined by:
    \[ (reset\, x\,in\, \eta)(x)=\begin{cases} \eta(y) & if\,y\not=x \\ 0 & if\,y=x \end{cases} \]
\end{itemize}
\mdfsubtitle{Satisfaction of Clock Constraints}
$\models\subseteq Eval(C)\times CC(C)$ is defined by:
\begin{align*}
\eta\models true \\
\eta\models x<c         & iff\,\eta(x) <c \\
\eta\models x\leq c     & iff\,\eta(x) \leq c \\
\eta\models x>c         & iff\,\eta(x) >c \\
\eta\models x\geq c     & iff\,\eta(x) \geq c \\
\eta\models g\wedge g'  & iff\,\eta\models g \wedge\eta\models g'
\end{align*}
\mdfsubtitle{Transition System from Timed Automata}
For the timed automaton $TA=(Loc,Act,C,\hookrightarrow,Loc_0,Inv,AP,L)$ the transition system is: $TS(TA) = (S,Act',\to,I,AP',L')$
\begin{align*}
S &= Loc\times Eval(C), \text{ so states are of the form } s=\langle\ell,\eta\rangle \\
Act'&=Act\cup\mathds{R}_{\geq0},\text{ (discrete) actions and time passage actions} \\
I &= \{\langle\ell_0,\eta_0\rangle | \ell_0\in Loc_0 \wedge\eta_0(x)=0 \text{ for all } x\in C\} \\
AP' &= AP\cup ACC(C) \\
L' (\langle\ell,\eta\rangle) &= L(\ell)\cup\{g\in ACC(C)|\eta g\} \\
\to& \text{is the transition relation defined below}
\end{align*}
\begin{description}
    \item[Discrete Transition:] $\langle\ell,\eta\rangle\overset{\alpha}{\longrightarrow}\langle\ell',\eta'\rangle$ if there is a transition labeled $(g:\alpha,D)$ from location $\ell$ to $\ell'$ such that:
    \begin{itemize}
        \item $g$ is satisfied by $\eta$, i.e. $\eta\models g$
        \item $\eta'=\eta$ with all clocks in $D$ resets to $0$, i.e. $\eta'=reset\, D\,in\,\eta$
        \item $\eta'$ fulfills the invariant of location $\ell'$, i.e. $\eta'\models Inv(\ell')$
    \end{itemize}
    \item[Delay Transition] $\langle\ell,\eta\rangle\overset{d}{\longrightarrow}\langle\ell,\eta+d\rangle$ for $d\in\mathds{R}_{\geq0}$ if $\eta+d\models Inv(\ell)$
\end{description}
\follows uncountably many states of the form $\langle\ell,\eta+t\rangle$ possible
\mdfsubtitle{Timed Paths through $TS(TA)$}
Model possible behaviour of $TA$. Not every Path is realistic:
\begin{description}
    \item[time convergence:] time converges to a specific value \\
    Time convergence is unrealistic and needs to be ignored (similar to unfair paths) \follows only use time-divergent paths.
    \item[timelock:] passage of time stops \\
    $TA$ is \emph{timelock-free} if no state in $Reach(TS(TA))$ contains a timelock \\
    timelocks are modelling flaws \follows need mechanisms to check for them
    \item[zenoness:] infinitely many actions take place in finite time. \\
\end{description}
\mdfsubtitle{Zenoness}
\begin{itemize}
    \item A $TA$ that performs infinitely many actions in finite time is \emph{zeno}.
    \item Path $\pi$ in $TS(TA)$ is \emph{zeno}, if it is time-convergent and infinitely many actions $\alpha\in Act$ are executed along $\pi$
    \item $TA$ is \emph{non-zeno} if there does not exist a zeno path in $TS(TA)$
    \begin{itemize}
        \item any $\pi$ in $TS(TA)$ is time-divergent
        \item any time-convergent path has at least one delay transition.
    \end{itemize}
    \item Sufficient Condition for \emph{Non-Zenoness} (static analysis):\\
    Let $TA$ with set $C$ of clocks such that for every (control) cycle:
    \[ \ell_0\overset{g_1:\alpha_1,C_1}{\scalebox{5}[1]{$\hookrightarrow$}}\ell_1\overset{g_2:\alpha_2,C_2}{\scalebox{5}[1]{$\hookrightarrow$}}\dots\overset{g_n:\alpha_n,C_n}{\scalebox{5}[1]{$\hookrightarrow$}}\ell_n=\ell_0 \] there exists a clock $x\in C$ such that:
    \begin{enumerate}
        \item $x\in C$, for some $0<i\leq n$, and
        \item for all clock evaluations $\eta$ there exists $c\in\mathds{N}_{>0}$ such that \[ \eta(x)<c \text{ implies } (\exists0<j\leq n.n\not\models g_j \text{ or } \eta\not\models Inv(\ell_j)) \]
    \end{enumerate}
\end{itemize}
\mdfsubtitle{Adequate Modelling}
A timed automaton is adequately modeling a time-critical system whenever it is \emph{non-zeno} and \emph{timelock-free}.
\end{mdframed}

\subsection{Timed CTL}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Syntax of Timed CTL (TCTL)}
]
TCTL formula over $AP$ and set $C$:
\[ \Phi:= true | a | g | \Phi\wedge\Phi | \neg\Phi | \exists\varphi | \forall\varphi \]
where $a\in AP, g\in ACC(C)$ and $\varphi$ is a path formula defined by $\varphi:=\diamond^J\Phi$ where
$J\subseteq\mathds{R}_{\geq0}$ is an interval whose bounds are natural: $J:[n,m], (n,m], [n,m), (n,m)$ for $n,m\in\mathds{N}$ and $n\leq m$, $m=\infty$ allowed for right-open intervalls.
\\
\begin{align*}
\exists\square^J\Phi&=\neg\forall\diamond^J\neg\Phi \\
\forall\square^J\Phi&= \neg\exists\diamond^J\neg\Phi \\
\diamond\Phi&=\diamond^{[0,\infty)}\Phi \\
\square\Phi&=\square^{[0,\infty)}\Phi
\end{align*}
\mdfsubtitle{Semantics of TCTL}
\begin{align*}
s&\models true \\
s&\models a &iff&& a&\in L(\ell) \\
s&\models g &iff&& & \eta\models g\\
s&\models \neg\Phi &iff&& & \neg s\models\Phi\\
s&\models \Phi\wedge\Psi &iff&& & (s\models\Phi) \text{ and }(s\models\Psi) \\
s&\models \exists\varphi &iff&& & \pi\models\varphi \text{ for some } \pi\in Pahts_{div}(s) \\
s&\models \forall\varphi &iff&& & \pi\models\varphi \text{ for all } \pi\in Pahts_{div}(s) \\\\
\end{align*}
\mdfsubtitle{Delay Equivalence Relation $\Longrightarrow$}
For infinite path fragments in $TS(TA)$ performing $\infty$ many actions, let
\[s_0\overset{d_0}{\Longrightarrow}s_1\overset{d_1}{\Longrightarrow}s_2\overset{d_2}{\Longrightarrow}\dots \text{ with } d_0,d_1,d_2\dots \geq0\]
denote the equivalence class such that the same time passes during the path. $ExecTime(\pi)=\sum_{i\geq0}d_i$
\mdfsubtitle{Satisfaction Set}
\[Sat(\Phi) = \{s\in Loc\times Eval(C) | s\models_{TCTL}\Phi\}\]
\[TA\models\Phi \text{ iff } \forall\ell_0\in Loc_0.\langle\ell_0,\eta_0\rangle\models\Phi\]
where $\eta_0(x)=0$ for all $x\in C$
\mdfsubtitle{TCTL and CTL}
TCTL only uses time-divergent paths, therefore:
\[ \underset{\text{TCTL semantics}}{\underbrace{TS(TA)\models_{TCTL} \forall\varphi}} \text{ but } \underset{\text{CTL semantics}}{\underbrace{TS(TA)\not\models_{CTL} \forall\varphi}} \]
\mdfsubtitle{Timelock}
A state is \emph{timelock-free} iff $\exists\square true$. I.e., there is a time-divergent path starting in this state.\\
$TA$ is timelock-free, iff $\forall s \in Reach(TS(TA)):\,s\models\exists\square true$\\
\follows Timelock-checking with a timed CTL formula.
\mdfsubtitle{TCTL Model Checking}
\[ \underset{\text{timed automaton}}{\underbrace{TA}}\models\Phi \iff \underset{\text{infinite transition system}}{\underbrace{TS(TA)}}\models\Phi \]
consider finite quotient of $TS(TA)$ \follows Region Transition System $RTS(TA)$ \\
transform TCTL formula $\Phi$ into ``equivalent'' CTL formula $\hat{\Phi}$
\[ TA\models_{TCTL}\Phi \iff \underset{finite transition system}{\underbrace{RTS(TA)}}\models_{CTL}\hat{\Phi} \]
\begin{enumerate}
    \item elimintation of timing parameters
    \begin{itemize}
        \item eliminate all intervalls $J\not=[0\infty)$ from TCTL formulas
        \item introduce fresh clock $z$ not formerly in $TA$
        \item $s\models\exists\diamond^J\Phi$ iff $reset\,z\in\,s\models z\in J\wedge\Phi$
        \item process $\exists\square^J\Phi, \forall\diamond^J\Phi, \forall\square^J\Phi$ similarly
    \end{itemize}
    Formally: for any state $s$ of $TS(TA)$ it holds:
    \[ s\models\exists\diamond^J\Phi\,\iff\,\underset{\text{state in } TS(TA\oplus z)}{\underbrace{s\{z:=0\}}}\models\exists\diamond((z\in J)\wedge\Phi) \] where $TA\oplus z$ it $TA$ over $C$ extended with $z\not\in C$
    \\
    For any state $s$ of $TS(TA) it holds. that:$
    \begin{enumerate}
        \item $s\models\exists(\Phi\until^J\Psi)$ iff $\underset{\text{state in } TS(TA\oplus z)}{\underbrace{s\{z:=0\}}}\models\exists((\Phi\vee\Psi)\until((z\in J)\wedge\Psi))$
        \item $s\models\forall(\Phi\until^J\Psi)$ iff $\underset{\text{state in } TS(TA\oplus z)}{\underbrace{s\{z:=0\}}}\models\forall((\Phi\vee\Psi)\until((z\in J)\wedge\Psi))$
    \end{enumerate}
    \item Clock Equivalence $\cong$ is an equivalence realtion on clock valuations:
    \begin{itemize}
        \item Equivalent clock valuations satisfy the same clock constraint $g$:
        \[ \eta\cong\eta'\Rightarrow(\eta\models g \iff \eta'\models g) \]
        \item Time-divergent paths of equivalent paths are ``equivalent'' \follows equivalent paths satisfy the same path formulas.
        \item The number of equivalence classes under $\cong$ is finite.
    \end{itemize}
    (a) and (b) are ensured, if equivalent states:
    \begin{itemize}
        \item agree on the integer part of all clock values
        \item agree on the ordering of the fractional parts of all clocks.
    \end{itemize}
    if clocks exceed the \emph{maximal constant} with which they are compared, their precise value is not of interest.
    \item Construct Region Transition System $TS=RTA(TA)$
    \item apply CTL model-checking algorithm to check $TS\models\Phi$
\end{enumerate}
\mdfsubtitle{Clock Equivalence}
$\eta$ and $\eta'$ are equivalent, $\eta\cong\eta'$ if: \\
{\tiny $c_x$ is the largest constant which $x$ is compared to
 }
\begin{itemize}
    \item for any $x\in C:\,\eta(x)>c_x \iff \eta'(x)>c_x$
    % \\ $\lfloor\eta(x)\rfloor=\lfloor\eta'(x)\rfloor$
    \item for any $x\in C:$ if $\,\eta(x),\eta'\leq c_x$ then: \\
    % $frac(\eta(x))=0 \iff frac(\eta'(x))=0$
    $\lfloor\eta(x)\rfloor = \lfloor\eta'(x)\rfloor$ and $frac(\eta(x))=0 \iff frac(\eta'(x))=0$
    \item for any $x,y\in C:$ if $\eta(x),\eta'(x)\leq c_x$ and $\eta(y),\eta'(y)\leq c_y$, then: \\
    $frac(\eta(x))\leq frac(\eta(y)) \iff frac(\eta'(x))\leq frac(\eta'(y))$
\end{itemize}
\begin{center}
\scalebox{1}{\input{images/clockRegions.tikz}}
\end{center}
furthermore: $s\cong s'$ iff $\ell=\ell'$ and $\eta\cong\eta'$
\mdfsubtitle{Regions}
\begin{description}
    \item[clock region:] $[\eta]=\{\eta'\in Eval(C) | \eta\cong\eta'\}$
    \item[state region:] $[s]=\langle\ell,[\eta]\rangle = \{\langle s,\eta'\rangle | \eta'\in[\eta]\}$ e
\end{description}
\mdfsubtitle{Bounds on number of regions}
$|C|!\cdot\prod_{x\in C} c_x\leq | \underset{\text{number of regions}}{\underbrace{Eval(C)\setminus\cong}} | \leq |C|!\cdot 2^{|C|-1} \cdot \prod_{x\in C} (2c_x+2)$ \\
The number of state regions is $|Loc|$ times larger. \\
\emph{Exponential} in number of Clocks.
\mdfsubtitle{Preservation of Atomic Properties}
\begin{enumerate}
    \item For $\eta,\eta'\in Eval(C)$ such that $\eta\cong\eta'$:
    \[ (\eta\models g \text{ if and only if } \eta'\models g) \text{ for any } g \in ACC(TA\cup\Phi) \]
    \item For $s,s'\in TS(TA)$ such that $s\cong s'$:
    \[ s\models a \text{ if and only iff } s'\models a \text{ for any } a\in AP' \]
\end{enumerate}
\end{mdframed}

\subsection{Region Automaton}
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Unbounded Regions}
]
Clock reagion is \emph{unbounded}: $r_\infty=\{\eta\in Eval(C) | \forall x\in C.\eta(x)>c_x\}$
\mdfsubtitle{Successor Regions}
$r'$ is the \emph{successor} (clock) region of $r$, $r'=succ(r)$ if either:
\begin{enumerate}
    \item $r=r_\infty$ and $r=r'$
    \item $r\not=r_\infty,r\not=r'$ and $\forall\eta\in r$:
    \[ \exists d\in\mathds{R}_{>0}.(\eta+d\in r' \text{ and } \forall0\leq d'\leq d.\eta+d'\in r\cup r) \]
\end{enumerate}
The \emph{successor region}: $succ(\langle\ell,r\rangle) = \langle\ell,succ(r)\rangle$
\mdfsubtitle{Time Convergence}
Time convergent paths that only perform \emph{delay transitions}. \\
For non-zeno $TA$ and $\pi=s_0s_1s_2\dots$ a path in $TS(TA)$:
\begin{enumerate}
    \item $\pi$ is \emph{time convergent} \follows $\exists$ state region $\langle\ell,r\rangle$ such that for some $j$:
    \[ s_i\in\langle\ell,r\rangle \text{ for all } i\geq j \]
    \item If $\exists$ state region with $r\not=r_\infty$ and an index $j$ such that:
    \[ s_i\in\langle\ell,r\rangle \text{ for all } i\geq j \]
    then $\pi$ is \emph{time-convergent}.
\end{enumerate}
\mdfsubtitle{Region Automaton}
For non-zeno $TS$ with $TS(TA)=(S,Act,\to,I,AP,L)$ let:
\[ RTS(TA,\Phi)=(S',Act\cup\{\tau\},\to',I',AP',L') \text{ with} \]
\begin{align*}
S' = S\setminus\cong &= \{[s]|s\in S\} &\text{the state regions} \\
I'&=\{[s]|s\in I\} &\text{the initial states} \\
L'(\langle\ell,r\rangle) &= L(\ell)\cup \{g\in AP'\setminus AP |r\models g\} \\
\to' :& \frac{\ell \overset{g:\alpha,D}{\scalebox{5}[1]{$\hookrightarrow$}} \ell'\;r\models g\; reset\;D\;in\;r\models Inv(\ell')}{\langle\ell,r\rangle\overset{\alpha}{\longrightarrow}'\langle\ell',reset\;D\;in\;r\rangle} &\text{and} \\
&\frac{r\models Inv(\ell)\quad succ(r)\models Inv(\ell)}{\langle\ell,r\rangle\overset{\tau}{\longrightarrow'}\langle\ell,succ(r)\rangle}
\end{align*}
\mdfsubtitle{Correctness}
For non-Zeno timed automaton $TA$ and $TCTL_\diamond$ formula $\Phi$:
\[ \underset{\text{TCTL semantics}}{\underbrace{TA\models\Phi}} \text{ iff } \underset{\text{CTL semantics}}{\underbrace{RTS(TA,\Phi)\models\Phi}} \]
\mdfsubtitle{Timelock Freedom}
Non-zeno $TA$ is \emph{timelock-free} iff no reachable state in $RTS(TA)$ is terminal. \\
\follows timelock freedom checking can be reduced to reachability analysis on $RTS(TA)$
\end{mdframed}

\subsection{TCTL Model Checking Algorithm}
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={TCTL Model Checking Algorithm}
]
\begin{algorithm}[H]
R:=$RTS(TA\oplus z,\Phi)$; \tcc*{with state space $S_{rts}$ and labelling $L{rts}$}
\For{all $i\leq|\Phi|$}{
    \For{all $\Psi\in Sub(\Phi)$ with $|\Psi|=i$}{
    \Switch{$\Psi$}{
        \begin{align*}
        true &&:&& Sat_R(\Psi)&:= S_{rts};\\
        a &&:&& Sat_R(\Psi)&:= \{s\in S_{rts}| a\in L_{rts}(s)\};\\
        \Psi_1\wedge\Psi_2 &&:&& Sat_R(\Psi)&:= \{s\in S_{rts}| \{a_{\Psi_1},a_{\Psi_2}\}\subseteq L_{rts}(s)\};\\
        \neg\Psi' &&:&& Sat_R(\Psi)&:= \{s\in S_{rts}| a_{\Psi'}\not\in L_{rts}(s)\};\\
        \exists(\Psi_1\until^J\Psi_2) &&:&& Sat_R(\Psi)&:= Sat_{CTL}\left(\exists((a_{\Psi_1}\vee a_{\Psi_2})\until(z\in J)\wedge a_{\Psi_2})\right);\\
        \forall(\Psi_1\until^J\Psi_2) &&:&& Sat_R(\Psi)&:= Sat_{CTL}\left(\forall((a_{\Psi_1}\vee a_{\Psi_2})\until(z\in J)\wedge a_{\Psi_2})\right);
        \end{align*}
    }
    \For{all $s\in S_{rts}$ with $s\{z:=0\}\in Sat_R(\Psi)$}{
    $L_{rts}(s):=L_{rts}(s)\cup\{a_\Psi\}$
    \tcc*{add $a_\Psi$ to labelling of state regions where $\Psi$ holds}
    }
    }
}
\Return $I_{rts}\subseteq Sat_R(\Phi)$
\end{algorithm}
\mdfsubtitle{Time Complexity}
timed automaton $TA$, TCTL $\Phi$, $N$ is number of states, $K$ is number of transitions in $RTS(TA,\Phi)$:
\[ TA\models\Phi: \quad \O((N+K)\cdot|\Phi|) \]
\end{mdframed}

\subsection{Clock Zones}
Number of clock regions too large, need coarser abstraction: \emph{clock zones}, efficient representation in \emph{difference bound matrices}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Forward Analysis}
]
\begin{itemize}
    \item start from initial configuration
    \item determine configurations that are reachable within $1,2,\dots,n$ steps
    \item termination: goal configuration reached or no new successors (\follows fixpoint)
\end{itemize}
\mdfsubtitle{Backward Analysis}
\begin{itemize}
    \item start from goal configuration
    \item determine configurations that can reach the goal within $1,2,\dots,n$ steps
    \item termination: initial configuration reached or no new predecessors (\follows fixpoint)
\end{itemize}
\mdfsubtitle{Clock Zones}
Symbolic representation of timed automata configurations.\\
For set $z$ of clock valuations and edge $e=\ell\overset{g:\alpha, D}{\scalebox{5}[1]{$\hookrightarrow$}}\ell'$ let:
\begin{align*}
Pre_e(z) &= \{ \eta\in\mathds{R}^n_{\geq0} | \exists\eta'\in z,d\in\mathds{R}_{\geq0}.(\eta+d\models g)\wedge\eta' = reset\,D\,in\, (\eta+d)\} \\
Post_e(z) &= \{ \eta'\in\mathds{R}^n_{\geq0} | \exists\eta\in z,d\in\mathds{R}_{\geq0}.(\eta+d\models g)\wedge\eta' = reset\,D\,in\, (\eta+d)\}
\end{align*}
Intuition:
\begin{itemize}
    \item $\eta\in Pre_e(z)$ if for some $\eta'\in z$ and delay $d$ holds: $(\ell,\eta)\overset{d}{\Longrightarrow}\dots\overset{e}{\longrightarrow}(\ell',\eta')$
    \item $\eta'\in Post_e(z)$ if for some $\eta\in z$ and delay $d$ holds: $(\ell,\eta)\overset{d}{\Longrightarrow}\dots\overset{e}{\longrightarrow}(\ell',\eta')$
\end{itemize}
\mdfsubtitle{Zones}
Clock Constraints are conjunctions of constraints of the form
\begin{itemize}
    \item $x\prec c$ and $x-y\prec c$ for $\prec\in\{<,\leq,=,\geq,>\}$ and $c\in\mathds{Z}$
\end{itemize}
A \emph{Zone} is a (maximal) set of clock valuations satisfying a clock constraint. \\
Clock zone of $g:\llbracket g\rrbracket=\{\eta\in Eval(C)|\eta\models g\}$ \\
A \emph{state zone} of $s=\langle\ell,\eta\rangle$ is $\langle\ell,z\rangle$ with $\eta\in z$ \\
For zone $z$ and edge $e$, $Post_e(z)$ and $Pre_e(z)$ are zones. \\
\mdfsubtitle{Operations on Zones}
\begin{tabular}{ll}
Future of $z$: & $\overset{\rightarrow}{z} = \{\eta+d | \eta\in z\wedge d\in\mathds{R}_{\geq0}\}$ \\
Past of $z$: & $\overset{\leftarrow}{z} = \{\eta-d | \eta\in z\wedge d\in\mathds{R}_{\geq0}\}$ \\
Intersection of two zones: & $z\cap z' = \{\eta|\eta\in z \wedge\eta\in z'\}$ \\
Clock Reset in a zone: & reset $D$ in $z$ = $\{$ reset $D$ in $\eta | \eta\in z\}$ \\
Inverse Clock Reset of a zone: & reset$^-1\,D$ in $z=\{\eta|$ reset $D$ in $\eta\in z\}$
\end{tabular}
\\
zones are closed under these operations
\mdfsubtitle{Clock Zones Examples}
\begin{multicols}{2}
$\red{(2<x\leq5)}\wedge\green{(1<y\leq5)}\wedge\blue{(y-x\leq0)}$
\begin{center}
\scalebox{.7}{\input{images/clock-zones.tikz}}
\end{center}
Future of $z$:
\begin{center}
\scalebox{.7}{\input{images/clock-zones-future.tikz}}
\end{center}
Past of $z$:
\begin{center}
\scalebox{.7}{\input{images/clock-zones-past.tikz}}
\end{center}
\columnbreak
Intersection of two zones: {\tiny $z'=1\leq y\leq3$}
\begin{center}
\scalebox{.7}{\input{images/clock-zones-intersect.tikz}}
\end{center}
Clock reset in a zone:
\begin{center}
\scalebox{.7}{\input{images/clock-zones-reset.tikz}}
\end{center}
Inverse Clock reset:
\begin{center}
\scalebox{.7}{\input{images/clock-zones-inverse-reset.tikz}}
\end{center}
\end{multicols}
\mdfsubtitle{Symbolic Representation of Successor and Predecessors}
For edge $e=\ell\overset{g:\alpha, D}{\scalebox{5}[1]{$\hookrightarrow$}}\ell'$ we have:
\begin{align*}
Pre_e(z) &= \{ \eta\in\mathds{R}^n_{\geq0} | \exists\eta'\in z,d\in\mathds{R}_{\geq0}.(\eta+d\models g)\wedge\eta' = reset\,D\,in\, (\eta+d)\} \\
Post_e(z) &= \{ \eta'\in\mathds{R}^n_{\geq0} | \exists\eta\in z,d\in\mathds{R}_{\geq0}.(\eta+d\models g)\wedge\eta' = reset\,D\,in\, (\eta+d)\}
\end{align*}
Express this symbolically with operations on zones:
\begin{align*}
Pre_e(z)  &= \overleftarrow{reset^{-1}\,D\,in\,(z\cap\llbracket D=0\rrbracket)\cap\llbracket g\rrbracket} \\
Post_e(z) &= reset\,D\,in\,(\overrightarrow{z}\cap\llbracket g\rrbracket)
\end{align*}
\mdfsubtitle{Successor (Forward Analysis)}
\begin{multicols}{2}
zone: $Z$
\begin{center}
\scalebox{.7}{\input{images/symb-zone.tikz}}
\end{center}
advance time: $\overrightarrow{Z}$
\begin{center}
\scalebox{.7}{\input{images/symb-zone-advance.tikz}}
\end{center}
\columnbreak
satisfy guard: $\overrightarrow{Z}\cap g$
\begin{center}
\scalebox{.7}{\input{images/symb-zone-guard.tikz}}
\end{center}
reset clock: $[y\leftarrow0](\overrightarrow{Z}\cap g)$
\begin{center}
\scalebox{.7}{\input{images/symb-zone-reset.tikz}}
\end{center}
\end{multicols}
\mdfsubtitle{Predecessor (Backward Analysis)}
\begin{multicols}{2}
zone: $Z$
\begin{center}
\scalebox{.7}{\input{images/symb-zone-b.tikz}}
\end{center}
undo clock reset: $[C\leftarrow]^{\overset{y}{\overbrace{-1}}}(Z\cap(\overset{x}{\overbrace{C=0}}))$
\begin{center}
\scalebox{.7}{\input{images/symb-zone-b-undo.tikz}}
\end{center}
consider guard: $([C\leftarrow]^{-1}(Z\cap(C=0)))\cap g$
\begin{center}
\scalebox{.7}{\input{images/symb-zone-b-guard.tikz}}
\end{center}
go back in time: $\overleftarrow{([C\leftarrow]^{-1}(Z\cap(C=0)))\cap g}$
\begin{center}
\scalebox{.7}{\input{images/symb-zone-b-goback.tikz}}
\end{center}
\end{multicols}
\mdfsubtitle{Backward Symbolic Reachability Analysis}
\emph{Backward Symbolic Transition System} of $TA$ is inductively defined by:
\[ \frac{
    e=\ell \overset{g:\alpha, D}{\scalebox{5}[1]{$\hookrightarrow$}} \ell',\; z=Pre(z')
}{
    (\ell',z')\Leftarrow (\ell,z)
} \]
Computation Schema:
\begin{align*}
T_0 &&&= &&\{(\ell,\mathds{R}_{\geq0}^n) | \ell \text{ is a goal location}\} \\
T_1 &&&= &T0\cup &\{(\ell,z) | \exists(\ell',z')\in,T_0.(\ell',z')\leftarrow(\ell,z) \text{ and } \ell'=\ell \text{ implies } z\not\subseteq z'\} \\
\dots &&& &\dots \\
T_{k+1} &&&= &T0\cup &\{(\ell,z) | \exists(\ell',z')\in,T_0.(\ell',z')\leftarrow(\ell,z) \text{ and } \ell'=\ell \text{ implies } z\not\subseteq z'\} \\
\dots &&& &\dots
\end{align*}
until
\begin{itemize}
    \item computation stabilizes (fixpoint)
    \item initial configuration reached (property violated)
\end{itemize}
\mdfsubtitle{Forward Symbolic Reachability Analysis}
\emph{Forward Symbolic Transition System} of $TA$ is inductively defined by:
\[ \frac{
    e=\ell \overset{g:\alpha, D}{\scalebox{5}[1]{$\hookrightarrow$}} \ell',\; z'=Post(z)
}{
    (\ell,z)\Rightarrow (\ell',z')
} \]
Computation Schema:
\begin{align*}
T_0 &&&= &&\{(\ell_0,z_0) | \forall x\in C.z_o(x)=0\} \\
T_1 &&&= &T0\cup &\{(\ell',z') | \exists(\ell,z)\in,T_0.(\ell,z)\rightarrow(\ell',z') \text{ and } \ell=\ell' \text{ implies } z\not\subseteq z'\} \\
\dots &&& &\dots \\
T_{k+1} &&&= &T0\cup &\{(\ell',z') | \exists(\ell,z)\in,T_k.(\ell,z)\rightarrow(\ell',z') \text{ and } \ell=\ell' \text{ implies } z\not\subseteq z'\} \\
\dots &&& &\dots
\end{align*}
until
\begin{itemize}
    \item computation stabilizes (fixpoint)
    \item goal configuration reached (property violated)
\end{itemize}
Forward Symbolic Reachability Analysis is correct but may not terminate.
\mdfsubtitle{Abstract Forward Reachabilty (only proposed)}
Let $\gamma$ associate sets of valuations to sets of valuations. \\
\emph{Forward Symbolic Transition System} of $TA$ is inductively defined by:
\[ \frac{
    e=\ell \overset{g:\alpha, D}{\scalebox{5}[1]{$\hookrightarrow$}} \ell',\; z'=\gamma(z)
}{
    (\ell,z)\Rightarrow \gamma(\ell',\gamma(z')
} \]
Computation Schema:
\begin{align*}
T_0 &&&= &&\{(\ell_0,\gamma(z_0) | \forall x\in C.z_o(x)=0\} \\
T_1 &&&= &T0\cup &\{(\ell',z') | \exists(\ell,z)\in,T_0.(\ell,z)\rightarrow\gamma(\ell',z') \} \\
\dots &&& &\dots \\
T_{k+1} &&&= &T0\cup &\{(\ell',z') | \exists(\ell,z)\in,T_k.(\ell,z)\rightarrow\gamma(\ell',z')\} \\
\dots &&& &\dots
\end{align*}
inclusion check and termination as before.
\begin{itemize}
    \item Soundness: (anything found in abstract system is also in actual system)
    \[
    \underbraceset{\text{reachability in } TS(TA)}{\langle\ell_0,\eta_0\rangle\to^*\langle\ell,\eta\rangle}
    \implies
    \exists\underbraceset{\text{ reachability in } TS(TA)}{\langle\ell_0,\eta_0\rangle\to^*\langle\ell,\eta\rangle} \text{ with } \eta\in z
     \]
    \item Completeness: (anything from the actual system can also be found in abstract system)
    \[
    \underbraceset{\text{ reachability in } TS(TA)}{\langle_0,\eta_0\to^*\langle\ell,\eta\rangle}
    \implies
     \exists\underbraceset{\text{abstract symbolic reachability}}{\langle\ell_0,\gamma(\{\eta_0\})\rangle\implies^*_\gamma\langle\ell,z\rangle} \text{ for some $z$ with } \eta\in z \]
\end{itemize}
for any $\gamma$ soundness and completeness are desirable
\begin{itemize}
    \item Finiteness: $\{\gamma(z)|\gamma \text{ defined on } z\}$ is finite
    \item Correctness: $\gamma$ is sound wrt. reachability
    \item Completeness: $\gamma$ is complete wrt. reachability
    \item Effectiveness: $\gamma$ is defined on zones and $\gamma(z)$ is a zone
\end{itemize}
\mdfsubtitle{$k$-Normalization}
A \emph{$k$ bounded zone} is described by a $k$-bounded clock constraint (consisting of $k$ atomic clock constraints). The \emph{$norm_k(Z)$} is the smallest $k$-bounded zone containing zone z
\begin{center}
\scalebox{.7}{\input{images/k-bounded-zone.tikz}}
\end{center}
\begin{itemize}
    \item Finiteness: $norm_k(\bullet)$ is a finite abstraction operator
    \item Correctness: $norm_k(\bullet)$ is sound wrt. reachability (provided $k$ is the maximal constant appearing in the constraints of $TS$)
    \item Completeness: $norm_k(\bullet)$ is complete wrt. reachability, since $z\subseteq norm_k(\bullet)$ so $norm_k(\bullet)$ is an over-approximation
    \item Effectiveness $norm_k(\bullet)$ is a zone
\end{itemize}
\end{mdframed}

\subsection{Difference Bound Matrices}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Difference Bound Matrices}
]
Zone $z$ over $C$ is represented by DBM $Z$ of cardinality $|C+1|\cdot|C+1|$. For $C=\{x_1,\dots,x_n\}$, let $C_0=\{x_0\}\cup C$ with $x_0=0$ and:
\[ Z(i,j) = (c,\prec) \iff x_i-x_j\prec c \]
Further:
\begin{align*}
Z(i,j) &:= (c,\prec) \text{ for each bound } x_i-x_j\prec c \text{ in } z \\
Z(i,j) &:= \infty \text{ (no bound) if clock difference } x_i-x_j \text{is unbounded in } z \\
Z(0,j) &:= (0,\leq)\, 0-x\leq 0 \text{ \tiny all clocks are positive} \\
Z(i,i) &:= (0,\leq) \text{ each clock is at most itself}
\end{align*}
rows are for lower bounds, columns for higher bounds, always: $x_0=0$
\begin{center}
\hspace{-2em}
\raisebox{-.5\height}{\scalebox{.7}{\input{images/DBM.tikz}}}
\follows $\begin{pmatrix}
0 & -3 & 0 \\ 9 & 0 & 4 \\ 5 & 2 & 0
\end{pmatrix}$
\end{center}
\mdfsubtitle{Canonical Form}
A zone $z$ is in \emph{canonical form} iff no constraint can be strengthened without reducing $\llbracket z\rrbracket = |\{\eta|\eta\in z\}|$ {\tiny the size of the zone}. \\
For each zone $z$ there eixts a \emph{unique} zone $z'$ such that $\llbracket z\rrbracket = \llbracket z'\rrbracket$ and $z'$ is in canonical form.\\
Zone $z$ is in its \emph{canonical form} iff DBM $Z$ satisfies:
\[ Z(i,j) \leq Z(i,k)+Z(k,j) \text{ for any } x_i,x_j,x_k\in C_0 \]
\mdfsubtitle{Operations on DBM entries}
Let $\preceq\in\{<,\leq\}$
\begin{itemize}
    \item Comparison of DBM entries: $(c,\preceq)<(c',\preceq')$ if $c<c'$
    \item Addition of DBM entries:
    \begin{align*}
    c+\infty &= \infty \\
    (c,\leq) + (c',\leq) &= (c+c',\leq) \\
    (c,<) + (c',\leq) &= (c+c',<)
    \end{align*}
\end{itemize}

\mdfsubtitle{Transform DBM into its canonical form}
Deriving the \emph{tightest constraint} on a pair of clocks in a zone is equivalent to finding the shortest weighted path between their vertices.\\
For Example Floyd-Warshall's All-Pairs Shortest-Path Algorithm \\
\begin{algorithm}[H]
\For{all $k:=1\,to\,n$}{
     \For{$i:=1$ to $n$}{
        \For{$j:=1$ to $n$}{
            $\underbraceset{\text{i to j}}{path[i][j]} = min(\underbraceset{curMin}{path[i][j]}, \underbraceset{candidateMin}{path[i][k]+path[k][j]});$
        }
     }
}
Worst Case time complexity in $\O(|C_0|^3)$\\
A canonical zone may contain redundant constraints: $x_i\overset{(n,\preceq)}{\longrightarrow}x_j$ is \emph{redundant} if a path if a path from $x_i$ to $x_j$ has weight of at most $(n,\preceq)$
\end{algorithm}
\mdfsubtitle{DBM Operations for Property Checking}
\begin{itemize}
    \item Nonemptiness: $\llbracket Z\rrbracket\not=\varnothing$?
    \begin{itemize}
        \item $Z=\varnothing$ if $x_i-x_j\preceq c$ and $x_j-x_i\preceq'c'$ and $(c,\preceq)<(c',\preceq')$
        \item[\follows] search for negative cycles in the graph representation
        \item mark $Z$ when upper bound is set to value $<$ its corresponding lower bound
    \end{itemize}
    \item Inclusion test: is $\llbracket Z\rrbracket\subseteq\llbracket Z'\rrbracket$?\\
    for DBMs in canonical form, test whether $Z(i,j)\leq Z'(i,j)$ for all $i,j\in C_0$ \marginnote{might be $|Z(\dots)|$ if canonicalization does not remove negative values.}
    \item Satisfaction: does $Z\models g$? \\
    check whether $\llbracket Z\wedge g\rrbracket = \varnothing$ (if yes, it does not)
\end{itemize}
\mdfsubtitle{DBM Operations Delays}
\begin{itemize}
    \item Future: determine $\overrightarrow{Z}$
    \begin{itemize}
        \item remove upper bounds on any clock:
        \[ \overrightarrow{Z}(i,0)=\infty \text{ and } \overrightarrow{Z}(i.j)=Z(i,j) \text{ for } j\not=0 \]
        \item $Z$ is canonical $\implies$ $\overrightarrow{Z}$ is canonical
    \end{itemize}
    \item Past: determine $\overleftarrow{Z}$
    \begin{itemize}
        \item set the lower bounds on all individual clocks to $(0,\preceq)$:
        \[ \overleftarrow{Z}(i,0)=\infty \text{ and } \overleftarrow{Z}(i,j)=Z(i,j) \text{ for } j\not=0 \] \marginnote{this formula may be wrong in the slides: slide 3-164}
    \end{itemize}
    \item Conjunction: $\llbracket Z\rrbracket \wedge (x_i-x_j\preceq n)$
    \begin{itemize}
        \item if $(n,\preceq)<Z(i,j)$ then $Z(i,j):=(n,\preceq)$ else do nothing
        \item put $Z$ into canonical form (in time $\O(|C_0|^2$) using that only $Z(i,j)$ changed.
    \end{itemize}
    \item Clock Reset: $x_j:=d$ in $Z$
    \[ Z(i,j):=(d,\leq)+Z(0,j) \text{ and } Z(j,i):= Z(j,0)+(-d,\leq) \]
    \item $k$-Normalization: $norm_k(Z)$
    \begin{itemize}
        \item remove all bounds $x-y\preceq m$ for which $(m,\preceq)>(k,\leq)$ {\tiny $\to \infty$}
        \item set all bounds $x-y\preceq m$ with $(m,\preceq)<(-k,<)$ to $(-k,<)$
        \item put the DBM back into canonical form (Floyd-Warshall)
    \end{itemize}
\end{itemize}
\end{mdframed}

\section{Probabilistic Model Checking}

\begin{itemize}
    \item Functional Requirements
    \begin{itemize}
        \item Functions or Services that the system has to provide.
    \end{itemize}
    \item Nonfunctional Requirements
    \begin{itemize}
        \item properties not directly related to functional correctness (often quantitative)
        \item response time, reliability, dependability, performance, quality of service
    \end{itemize}

    \begin{mdframed}[roundcorner=5pt,
    subtitlebelowline=false,subtitleaboveline=false,
    subtitlebackgroundcolor=blue!30,
    % backgroundcolor=blue!20,
    frametitlerule=true,
    frametitlebackgroundcolor=blue!30,
    frametitle={System Correctness}
    ]
    A system is correct if it is capable of doing what it is expected to do over a certain period of time with a certain probability.
    \end{mdframed}
    Probabilistic Approaches:
    \begin{itemize}
        \item Termination of probabilistic programs \\
        does a probabilistic program terminate with probability one?
        \item Markov decision processes\\
        stochastic and nondeterministic behaviour, does a certain (linear) temporal logic formula hold with probability $p$?
        \item Discrete-time Markov Chains \\
        can we reach a goal state via a given trajectory with probability $p$?
        \item Discrete Markov Decision Process\\
        What is maximal (or minimal) probability of doing something?
        \item Continuous-time Markov Chains \\
        Can we do so within a given time interval $I$?
    \end{itemize}
\end{itemize}

\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Probabilistic Model Checking}
]
{\tiny not probabilistic approaches to model checking like Monte-Carlo Model Checking or Random Walks, which perform incomplete sampling of state space} \\
Checking of Reachability and Probabilistic temporal logic formulae
\begin{itemize}
    \item time-bounded reachability
    \item long-run averages, steady state
\end{itemize}
\mdfsubtitle{Measurable Space}
\begin{itemize}
    \item A \emph{sample space} $\Omega$ of a chance experiment is a set of values representing the possible outcomes of the experiment.
    \item A \emph{$\sigma$-algebra} is a pair $(\Omega,\mathcal{F})$ with $\Omega\not=\varnothing$ and $\mathcal{F}\subseteq2^\Omega$ a collection of subsets of sample space $\Omega$ such that:
    \begin{enumerate}
        \item $\Omega\in\mathcal{F}$ ("all events are possible")
        \item $A\in \mathcal{F}\implies (\Omega-A)\in\mathcal{F}$ ($A$ is a set of events, so the complement of events is also possible)
        \item $(\forall i\geq0.A_i\in\mathcal{F})\implies(\bigcup_{i\geq0} A_i)\in\mathcal{F}$ (the countable union of all sets of possible events are also possible)
    \end{enumerate}
    \item elements of $\mathcal{F}$ are called \emph{events}
    \item the pair $(\Omega,\mathcal{F})$ is called a \emph{measurable space}
\end{itemize}
\mdfsubtitle{Probability Space}
A \emph{probability space} $\mathcal{P}$ is a structure $(\Omega,\mathcal{F},Pr)$ with:
\begin{itemize}
    \item $(\Omega,\mathcal{F}$ is a $\sigma$-algebra
    \item $Pr:\mathcal{f}\to[0,1]$ is a \emph{probability measure}, i.e.
    \begin{enumerate}
        \item $Pr(\Omega)=1$, i.e. $\Omega$ is the certain event
        \item $Pr\left( \bigcup_{i\in I}A_i \right)=\sum_{i\in I} Pr(A_i)$ for any $A_i\in\mathcal{F}$ with $\underbraceset{\text{independent events}}{A_i\cap A_j=\varnothing}$ for $i\not= j$ where $\{A_i\}_{i\in I}$ is finite or countably infinite
    \end{enumerate}
\end{itemize}
The elements in $\mathcal{F}$ of a probability space $(\Omega,\mathcal{F},Pr)$ are called \emph{measurable events}.
\begin{itemize}
    \item No possible outcome of chance experiments is missed when considering $\Omega$.
    \item Probabilities for different $A_i$s add up if the $A_i$s are pairwise disjoint.
\end{itemize}
\mdfsubtitle{Properties of Probabilities}
For measurable events $A,B$ and $A_i$ and probability measure $Pr$:
\begin{align*}
Pr(A) &= 1-Pr(\Omega-A) \\
Pr(A\cup B) &= Pr(A)+Pr(B)-Pr(A\cap B) \\
Pr(A\cap B) &= \underbraceset{\text{$A$ happens if $B$ happens}}{Pr(A|B)}\cdot Pr(B) \\
A\subseteq B &\implies Pr(A)\leq Pr(B) \\
Pr(\bigcup_{n\geq 1} A_n) &= \sum_{n\geq1}Pr(A_n) & \text{provided $A_n$ are pairwise disjoint}
\end{align*}
\mdfsubtitle{Discrete Probability Space}
$Pr$ is a \emph{discrete probability} measure on $(\Omega,\mathcal{F})$ if
\begin{itemize}
    \item there is a countable set $A\in\Omega$ such that for $a\in A$:
    \[
    \{a\}\in\mathcal{F} \text{ and } \sum_{a\in A}Pr(\{a\})=1
    \]
\end{itemize}
$(\Omega\mathcal{F},Pr)$ is then called a \emph{discrete probability space}, otherwise it is a \emph{continuous probability space}.
\mdfsubtitle{Measurable Function}
Let $(\omega,\mathcal{F}$ and $(\Omega',\mathcal{F}'$ be measurable spaces. Function $f:\Omega\to\Omega'$ is a \emph{measurable function} if
\[
f^{-1}(A) = \{a|f(a)\in A\}\in\mathcal{F} \text{ for all } A\in\mathcal{F}''
\]
\mdfsubtitle{Random Variable}
Measurable function $X:\Omega\to\mathds{R}$. $\mathds{R}$ is a \emph{random variable}. \\
The \emph{probability distribution} of $X$ is $Pr_X=Pr\circ X^{-1}$ where $Pr$ is a probability measure on $(\Omega,\mathcal{F})$.
\mdfsubtitle{Distribution Function}
The \emph{Distribution Function} $F_X$ of random variable $X$ is defined by:
\[
F_X(d) = \underset{X}{Pr}((-\infty,d]) = Pr(\underbraceset{\{X\leq d\}}{\{a\in\Omega|X(a)\leq d\}}) \text{ for real }d
\]
properties:
\begin{itemize}
    \item $F_X$ is monotonic and right-continuous (increases with greater $d$)
    \item $0\leq F_X(d)\leq1$
    \item $lim_{d\to-\infty}F_X(d)=0$
    \item $lim_{d\to\infty}F_X(d)=1$
\end{itemize}
\mdfsubtitle{Distribution Function for Continuous Random Variable}
The \emph{distribution function} $F_X$ of random variable $X$ is defined for $d\in\mathds{R}$ by:
\[
F_X(d)=\underset{X}{Pr}(X\in(-\infty,d]) = Pr(\{a\in\Omega|X(a)\leq d\})
\]
In the continuous case, $F_X$ is called the \emph{cumulative density function}.
\mdfsubtitle{Distribution Function as Sums/Integrals}
\begin{itemize}
    \item For discrete random variable $X$, $F_X$ can be written as
    \[
    F_X(d)=\sum_{d_i\leq d}\underset{X}{Pr}(X=d_i)
    \]
    \item For continuous random variable $X$, $F_X$ can be written as:
    \[
    F_X(d)=\int_{-\infty}^d f_X(i) du \text{ with $f$ the density function}
    \]
\end{itemize}
\mdfsubtitle{Discrete-Time Markov Chains}
State-transition systems augmented with probabilities:
\begin{description}
    \item[States:] set of states representing possible configurations of the system being modeled.
    \item[Transitions:] transitions between states model evolution of systems states; occur in discrete time-steps
    \item[Probabilities:] probabilities of making transitions between states are given by discrete probability distributions
\end{description}
A \emph{DTMC} $\mathcal{M}$ is a tuple $(S,P,\iota_{init},AP,L)$ with
\begin{itemize}
    \item $S$ is a countable nonempty set of states (preferably finite)
    \item $P:S\times S\to[0,1]$ transition probability function, s.t. $\sum_{s'}P(s,s')=1$ \\
    $P(s,s')$ is the probability to jump from $s$ to $s'$ in one step
    \item $\iota_{init}:S\to[0,1]$ the initial distribution with $\sum_{s\in S}\iota_{init}(s)=1$
    \begin{itemize}
        \item $\iota_{init}(s)$ is the probability that system starts in state $s$
        \item state $s$ for which $\iota_{init}(s)>0 \text{ is an initial state}$
    \end{itemize}
    \item $L:S\to 2^{AP}$, the labeling function
\end{itemize}
next state is always chosen probabilistically, no non-determinism to model concurrency \follows Markov Decision Processes (MDPs)
\mdfsubtitle{Properties in DTMC}
\begin{itemize}
    \item State graph of DTMC $\mathcal{M}$ is a digraph $G=(V,E)$ with
    \begin{itemize}
        \item vertices $V$ are states of $\mathcal{M}$ and $(s,s')\in E \iff P(s,s')>0$
    \end{itemize}
    \item Paths in $\mathcal{M}$ are maximal (i.e. infinite) paths in its state graph
    \item Notations: $Paths(\mathcal{M})$ and $Paths_{fin}(\mathcal{M}$ denote the set of finite paths in $\mathcal{M}$
    \item Direct successors and predecessors
    \begin{itemize}
        \item $Post(s)=\{s'\in S|P(s,s')>0\}$ and $Pre(s)=\{s'\in S|P(s',s)>0\}$
        \item $Post^*(s)$ and $Pre^*(s)$ are reflexive and transitive closures
    \end{itemize}
    \item Absorbing States:
    \begin{itemize}
        \item state of MC $\mathcal{M}$ is called absorbing iff $Post^*(s)=\{s\}$ {\tiny (state cannot be left)}
        \item then $P(s,s)=1$ and $\forall t\not=s:P(s,t)=0$
    \end{itemize}
\end{itemize}
\mdfsubtitle{Example for Discrete-Time Markov Chain}
\begin{multicols}{2}
\begin{center}
\scalebox{1}{\input{images/dtmc-ex-graph.tikz}}
\end{center}
\begin{align*}
P&=
\begin{pmatrix}
0 & 1 & 0 & 0 \\
0 & 0 & \frac{1}{10} & \frac{9}{10} \\
0 & 1 & 0 & 0 \\
1 & 0 & 0 & 0
\end{pmatrix},
&\iota_{init}&=\begin{pmatrix}1\\0\\0\\0\end{pmatrix}
\end{align*}
probability to be in states after one step: $\begin{pmatrix}
0 \\ 1 \\ 0 \\ 0
\end{pmatrix}$
\end{multicols}
\mdfsubtitle{Paths and Probabilites}
need to define probability space over paths
\begin{itemize}
    \item sample space $Path(s)=$ set of all infinite paths from a state $s$.
    \item events: sets of inifinite paths from $s$
    \item basic events: \emph{cylinder sets}
    \item cylinder set $Cyl(\omega)$ for finite path $\omega=$ set of infinite paths with the common finite prefix $\omega$
\end{itemize}
reasoning about quantitative properties of DTMCs (e.g. probabilistic reachability) means reasoning about cylinder sets, i.e., set of paths\\
sound stochastic basis \follows relate them to measurable spaces and $\sigma$-algebras
\mdfsubtitle{$\sigma$-Algebra}
Let $\Omega$ be an arbitrary non-empty set\\
$(\Omega,\mathcal{F})$ with $\mathcal{F}\subseteq2^\Omega$ is a \emph{$\sigma$-algebra} on $\Omega$ if:
\begin{itemize}
    \item $\varnothing\in\mathcal{F}$
    \item $E\in\mathcal{F}\implies\Omega\setminus E\in\mathcal{F}$
    \item $(\forall i\in\mathds{N}.E_i\in\mathcal{F} \implies \bigcup_{i\in\mathds{N}} E_i\in\mathcal{F}$
\end{itemize}
Elements of $\mathcal{F}$ are called \emph{measurable sets} or \emph{events}. \\
For any family $\mathcal{F}$ of subsets of $\Omega$:
\begin{itemize}
    \item there exists a unique smallest $\sigma$-algebra on $\Omega$ containing $\mathcal{F}$
\end{itemize}
\mdfsubtitle{Probability Space}
A \emph{probability space} is a structure $(\Omega,\mathcal{F},Pr)$ with:
\begin{itemize}
    \item $\sigma$-algebra $(\Omega,\mathcal{F})$
    \item $Pr:\mathcal{F}\to[0,1]$ is a \emph{probability measure}, i.e.
    \begin{enumerate}
        \item $Pr(\Omega)=1$
        \item $Pr(\bigcup^\infty_{i=1} E_i) = \sum^\infty_{i=1}Pr(E_i)$ for $E_i\in\mathcal{F}$ and $E_i\cap E_j=\varnothing$ for $i\not= j$
    \end{enumerate}
    \item $Pr(E)$ is the probability of $E$, i.e., $E$ is \emph{measurable}
\end{itemize}
\mdfsubtitle{Properties of Probability Measures}
\begin{itemize}
    \item An event $E$ with $Pr(E)=1$ is called \emph{almost sure} \\
    $Pr(D)=Pr(E\cap D)+\underbraceset{=0}{Pr(D\setminus E}=Pr(E\cap D)$
    \item $E_1,\dots E_n$ are almost sure implies $\bigcap_{1\leq i\leq n}E_i$ is almost sure
\item For any $\Omega$ and $\mathcal{F}\subseteq2^\Omega$ there exists a smallest $\sigma$-algebra containing $\mathcal{f}$
\\ it is obtained by taking the intersection over all $\sigma$-algebras on $\Omega$ that contain $\mathcal{F}$
\end{itemize}
\mdfsubtitle{Probability Space on DTMC Paths}
\begin{itemize}
    \item Events are \emph{infinite paths} in the DTMC $\mathcal{M}$, i.e., $\Omega=Paths(\mathcal{M})$
    \item $\sigma$-algebra on $\mathcal{M}$ is generated by \emph{cylinder sets} of finite paths $\hat{\pi}$:
    \[ Cyl(\hat{\pi})=\{ \pi\in Paths(\mathcal{M}) | \hat{\pi} \text{ is a prefix of } \pi \} \]
    cylinder sets serve as events of the smallest $\sigma$-algebra on $Paths(\mathcal{M})$
    \item $Pr$ is the \emph{probability measure} on the $\sigma$-algebra on $Paths(\mathcal{M}$:
    \[ Pr(Cyl(s_0\dots s_n)) = \iota_{init}(s_0)\cdot P(s_0\dots s_n) \]
    where
    \begin{itemize}
        \item $P(s_0s_1\dots s_n) = \prod_{0\leq i\leq n} P(s_i,s_{i+1}$ if $n>0$
        \item $P(s_0)=1$ for all paths containing a single state
    \end{itemize}
\end{itemize}
\mdfsubtitle{Reachability Probabilities}
What is the probability to reach a set of states $B\subseteq S$ in DTMC $\mathcal{M}$?
\\ Which event does $\diamond B$ mean formally?
\\ the union of all cylinders $Cyl(s_0\dots s_n)$ where $s_0\dots s_n$ is an initial path fragment $\mathcal{M}$ with $s_0,\dots,s_{n-1}\not\in B$ and $s_n\in B$
\begin{align*}
Pr(\diamond B) &= \sum_{s_0\dots s_n\in Paths_{fin}(\mathcal{M})\cap (S\setminus B)^* B} Pr(Cyl(s_0\dots s_n)) \\
 &= \sum_{s_0\dots s_n\in Paths_{fin}(\mathcal{M})\cap (S\setminus B)^* B} \iota_{init}\cdot P(s_0\dots s_n)
\end{align*}
{\tiny notice: infinite sum}
\mdfsubtitle{Computing Reachability Properties in finite DTMCs}
\begin{itemize}
    \item Let $Pr(s\models\diamond B) = Pr_s(\diamond B) = Pr_s\{\pi\in Paths(s) | \models \diamond B\}$ where $Pr_s$ is the probability measure in $\mathcal{M}$ with only initial state $s$
    \item Let variable $x_s=Pr(s\models\diamond B)$ for any state $s$
    \begin{itemize}
        \item if $B$ is not reachable from $s$ then $x_s=0$
        \item if $s\in B$ then $x_s=1$
    \end{itemize}
    \item For any state $s\in Pre^*(B)\setminus B:$
    \[
    x_s = \underbraceset{\text{reach B via t}}{\sum_{t\in S\setminus B} P(s,t)\cdot x_t} + \underbraceset{\text{reach B in one step}}{\sum_{u\in B}P(s,u)}
    \]
    \item Rewrite equations: \[ x= Ax+b \]
    \begin{itemize}
        \item vector $x=(x_s)_{s\in\tilde{S}}$ with $\tilde{S}=Pre^*(B)\setminus B$, $x_s=1$ if reachable, $x_s=0$ if not
        \item $A=(P(s,t))_{s,t\in\tilde{S}}$  the transition probabilities in $\tilde{S}$
        \item $b=(b_s)_{s\in\tilde{S}}$ contains the probabilities to reach $B$ within one step
    \end{itemize}
    \item Linear equation system: $(I-A)x=b$
    \begin{itemize}
        \item More than one solution may exist, if $I-A$ has no inverse (i.e. is singular) \follows characterize the desired probability as least fixed point
    \end{itemize}
\end{itemize}
\mdfsubtitle{Algorithm Scheme}
\begin{itemize}
    \item two phase algorithm
    \begin{enumerate}
        \item using graph search, determine the set of $\tilde{S}$ of all states that can reach $B$
        \item generate $A$ and $b$ and solve equation system $(I-A)x=b$
    \end{enumerate}
    \item if $I-A$ singular, i.e., it does not have an inverse, then $(I-A)x=b$ has more than one solution
    \begin{itemize}
        \item characterize the solution as the least solution in $[0,1]^{\tilde{S}}$
    \end{itemize}
    \item calculate probability vector with iterative approximation
    \item consider \emph{constrained reachability} $\underbraceset{\text{constraint}}{c}\until^{\leq n}\underbraceset{\text{reach set } B}{B}$
    \begin{itemize}
        \item $C\until\leq n B$ is the union of the basic cylinders of fragments
        \[
        s_0s_1\dots s_k \text{ with } k\leq n \text{ and } s_i\in C \text{ for all } 0\leq i<k \text{ and } s_k\in B
        \]
        \item Let $S_{=0},S_{=1}, S_?$ be a patition of $S$ such that:
        \begin{itemize}
            \item $B\subseteq S_{=1}\subseteq \{s\in S|Pr(s\models C\until B)=1\}$ {\tiny certain satisfaction}
            \item $S\setminus (C\until B)\subseteq S_{=0} \subseteq \{s\in S|Pr(s\models C\until B)=0\}$ {\tiny will certainly not satisfy}
            \item all states in $S_?$ belong to $S\setminus B$ {\tiny don't know yet}
        \end{itemize}
        \item Let $A=\underbraceset{\text{Probability to transit inside } S_?}{(P(s,t))_{s,t\in S_?}}$ and $(b_s)_{s\in S_?}$ where $\underbraceset{\text{one step proabbility to reach } S_{=1}}{b_s=P(s,S_{=1}}$
    \end{itemize}
    \item Define: $y\leq y'$ iff $y_s\leq y_s'$ for all $s\in S$
    \begin{itemize}
        \item $y$ is a \emph{fixed point} of $F:[0,1]^S\to[0,1]^S$ if $F(y)=y$
        \item x is a \emph{least fixed point} of $F$ if $x\leq y$ for any other fixed point $y$ of $F$
    \end{itemize}
    \item The vector $x=\left(Pr(s\models C\until B)\right)_{s\in S_?}$ is the least fixed point of $F:[0,1]^{S_?}\to [0,1]^{S_?}$ given by $F(y)=A\cdot y+b$
    \begin{itemize}
        \item $x^{(n)}=\left( x_s^{(n)} \right)_{s\in S_?}$ where for any $s: x_s^{(n)}=Pr\left(s\models C\until^{\leq n}S_{=1}\right)$
        \item $x^{(0)}\leq x^{(1)}\leq x^{(2)}\leq\dots\leq x$ {\tiny increasing monotonically}
        \item $\displaystyle x=\lim_{n\to\infty} x^{(n)}$
        \\ \follows $x$ is the least solution of $Ax+b=x$ in $[0,1]^{S_?}$
        \\ \follows Approximation: $x^{(0)}=0$ and $x^{(n+1)}=Ax^{(n)}+b$ for $n\geq0$
        \item Power Method: compute vectors $x^{(n)}$ iteratively, abort on:
        \[
        \max_{s\in S_?} |x_s^(n+1)-x_s^{(n)}| < \epsilon \text{ for some small tolerance } \epsilon
        \]
        convergence is guaranteed, alternate ways: eg Jacobi, Gauss-Seidel, successive overrelaxation
    \end{itemize}
\end{itemize}
\mdfsubtitle{Unique Solution}
For $B,C\subseteq S$ the vector \[ \left(PR(s\models C\until B)\right)_{s\in S_?} \]
is the \emph{unique solution} of the linear equation system:
\[ x=Ax+b \text{ where } A=\left(P(s,t)\right)_{s,t\in S_?} \text{ and } b=(P(s,S_{=1}))_{s\in S_?} \]
Example how matrix works \follows exercises
\mdfsubtitle{Transient Probabilities}
A \emph{transient probability} is the probability to reside in some state $t$ after exactly $n$ steps.
\begin{align*}
\Theta^\mathcal{M}_n(t) &= \sum_{s\in S} \iota_{init}(s)\cdot P^n(s,t) \\
\Theta^\mathcal{M}_n &= \underbraceset{n \text{ times}}{P\cdot P\cdot\dots\cdot P}\cdot\iota_{init} = P^n\cdot\iota_{init}
\end{align*}
\follows Compute $\Theta_n^\mathcal{M}$ by successive vector-matrix multiplications (reduces numerical instability)
\begin{align*}
\Theta^\mathcal{M}_0 &= \iota_{init} \\
\Theta_n^\mathcal{M} &= P\cdot\Theta^\mathcal{M}_{n-1} & \text{ for } n\geq 1
\end{align*}
\mdfsubtitle{Reachability in DTMC}
Can be computed via transient probability \follows adapt $\mathcal{M}$ by making all states in $B$ absorbing, then:
\[
\underbraceset{\text{Reachability in } \mathcal{M}}{Pr^\mathcal{M}}\left(\diamond^{\leq n}B\right) = \underbraceset{\text{transient probability in }\mathcal{M}_B}{\sum_{s'\in B}\Theta_n^{\mathcal{M}_B}(s')}
\]
\mdfsubtitle{Constrained Reachability in DTMC}
Can also be computed via transient probability \follows adapt $\mathcal{M}$ by making all states in $B$ and $S\setminus(C\until B)$ absorbing, then:
\[
\underbraceset{\text{Reachability in } \mathcal{M}}{Pr^\mathcal{M}}\left(C\until^{\leq n}B\right) = \underbraceset{\text{transient probability in }\mathcal{M}_{C,B}}{\sum_{s'\in B}\Theta_n^{\mathcal{M}_{C,B}}(s')}
\]
\end{mdframed}

\subsection{Probabilistic CTL (PCTL)}
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Probabilistic CTL (PCTL)}
]
\begin{itemize}
    \item Temporal Logic for describing properties of DTMC
    \item Extension to temporal logic CTL
    \item probabilistic operator $\mathbb{P}$ replaces universal and existential path quantification: $\mathbb{P}_J(\Phi)$
\end{itemize}
\mdfsubtitle{Syntax of PCTL}
For $a\in AP, J\subseteq [0,1]$ an interval with rational bounds and natural $n$:
\begin{align*}
\Phi &:= true | a | \Phi\wedge\Phi | \neg\Phi | \mathbb{P}_J(\varphi) \\
\varphi &:= \circ\Phi | \Phi_1\until\Phi_2 | \Phi_1\until^{\leq n}\Phi_2
\end{align*}
\begin{itemize}
    \item $s_0s_1s_2\dots\models\Phi\until^{\leq n}\Psi$ if $\Phi$ holds until $\Psi$ holds within $n$ steps
    \item $s\models\mathbb{P}_J(\varphi)$ if probability that paths starting in $s$ fulfill $\varphi$ lies in $J$
\end{itemize}
\mdfsubtitle{Derived Operators in PCTL}
\begin{align*}
\diamond\Phi &= true\until\Phi \\
\diamond^{\leq n}\Phi &= true\until^{\leq n}\Phi \\
\mathbb{P}_{\leq p}(\square\Phi) &= \mathbb{P}_{\geq 1-p}(\diamond\neg\Phi) \\
\mathbb{P}_{]p,q]}(\square^{\leq n}\Phi) &= \mathbb{P}_{[1-q,1-p[}(\diamond^{\leq n}\neg\Phi)
\end{align*}
\mdfsubtitle{PCTL Semantics}
$\mathcal{M},s\models\Phi$ iff formula $\Phi$ holds in s tate $s$ of DTMC $\mathcal{M}$
\begin{align*}
s&\models a && iff & a&\in L(s)\\
s&\models \neg \Phi && iff & not(s&\models\Phi)\\
s&\models \Phi\wedge\Psi && iff & (s&\models\Phi) \text{ and } (s\models\Psi)\\
s&\models \mathbb{P}_J(\varphi) && iff & Pr(s&\models\varphi)\in J\\
\end{align*}
where $Pr(s\models\varphi)=Pr_s\{\pi\in Paths(s)|\pi\models\varphi\}$ \\
Semantics of path-formulas defined as in CTL
\mdfsubtitle{Measurability}
For any PCTL path formula $\varphi$ and state $s$ of DTMC $\mathcal{M}$ the set $\{\pi\in Paths(s) | \pi\models\varphi\}$ is measurable. Three cases:
\begin{itemize}
    \item $\circ\Phi:$ cylinder sets constructed form paths of length one
    \item $\Phi\until^{\leq n}\Psi:$ (finite number of) cylinder sets from paths of lenght at most $n$
    \item $\Phi\until\Psi:$ countable union of paths satisfying $\Phi\until^{\leq n}\Psi$ for all $n\geq0$
\end{itemize}
\mdfsubtitle{PCTL Model Checking}
Check whether a state $s$ in a DTMC satisfies a PCTL formula:
\begin{itemize}
    \item compure recursively the set $Sat(\Phi)$ of states that satisfy $\Phi$
    \item check whether state $s$ belongs to $Sat(\Phi)$
    \item[\follows] bottom-up traversal of the parse tree of $\Phi$ (like for CTL)
    \item for probabilistic operators:
    \begin{enumerate}
        \item compute $Sat(\Phi)$
        \item compute probabilities
    \end{enumerate}
\end{itemize}
\mdfsubtitle{Probability and Next-Operator}
\begin{itemize}
    \item $s\models\mathbb{P}_J(\circ\Phi)$ iff $Prob(s,\circ\Phi)\in J$
    \item $Prob(s,\circ\Phi)\equiv\displaystyle\sum_{s'\in Sat(\Phi)}P(s,s')$ {\tiny sum up probabilities to get into $Sat(\Phi)$}
    \item Matrix-Vector Multiplication: $(Probs(s,\circ\Phi))_{s\in S}=P\cdot\iota_\Phi$ {\tiny one step from init of $\Phi$}
\end{itemize}
\mdfsubtitle{Probability and Bounded Until Operator}
$s\models\mathbb{P}_J(\Phi\until^{\leq h}\Psi)$ iff $Prob(s,\Phi\until^{\leq h})\in J$ is the least solution of:
\begin{itemize}
    \item $1$ if $s\models\Psi$ {\tiny 0 steps}
    \item for $h>0$ and $s\models\Phi\vee\neg\Psi:$
    \[\sum_{s'\in S}P(s,s')\cdot Prob(s',\Phi\until^{\leq h-1}\Psi) \] {\tiny iterate number of steps}
    \item $0$ otherwise {\tiny fail}
\end{itemize}
\mdfsubtitle{PCTL Model Checking}
\begin{itemize}
    \item Computation of probabilities $Prob(s,\Phi_1\until\Phi_2)$ for all $s\in S$
    \item identify all states where probability is $1$ or $0$: (``Precomputation'')
    \begin{itemize}
        \item $S^{yes}=Sat(P_{\geq1}[\Phi_1\until\Phi_2])$
        \item $S^{no}=Sat(P_{\leq0}[\Phi_1\until\Phi_2])$
    \end{itemize}
    \item solve linear equation system for remaining states
    \[ Prob(s,\Phi_1\until\Phi_2)=
    \begin{cases}
        1 & \text{ if } s\in S^{yes} \\
        0 & \text{ if } s\in S^{no} \\
        \sum_{s'\in S}P(s,s')\cdot Prob(s',\Phi_1\until\Phi_2) & \text{otherwise}
    \end{cases}
     \]
     \follows reduction of linear equation system in $|S^?|$ unknowns instead of $|S|$, where $S^?=S\setminus(S^{yes}\cup S^{no})$
     \item Make all $\Psi$ and all $\neg(\Phi\wedge\Psi)$-states absorbing in $\mathcal{M}$
     \\ \follows: Check $\diamond^{=h}\Psi$ in obtained DTMC
     \\ \follows Matrix-vector multiplication
\end{itemize}
\mdfsubtitle{Time Complexity}
For finite DTMC $\mathcal{M}$ and PCTL formula $\Phi$, $\mathcal{M}\models\Phi$ can be solved in time:
\[
\O(poly(size(\mathcal{M}))\cdot n_{\max}\cdot|\Phi|)
\]
\begin{itemize}
    \item $n_{\max}=\max\{n|\Psi_1\until^{\leq n}\Psi_2 \text{ occurs in }\Phi\}$
    \item $n_{\max}=1$ if $\Phi$ does not contain the bounded until-operator
    \item $size(\mathcal{M}$ probably exponential
    \item $\Phi$ can be exponentially larger than LTL
\end{itemize}
\end{mdframed}

\subsection{Outlook}
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Continuous Time Markov Chain (CTMC)}
]
\begin{itemize}
    \item transitions are labelled with rates which are parameters of negative exponential distributions
    \item Continuous Stochastic Logic (CSL)
    \item Model Checking: reduce to DTMC via uniformization
\end{itemize}
\mdfsubtitle{Discrete Time Markov Decision Process (DTMDP)}
\begin{itemize}
    \item alternating non-deterministic and probabilistic choices
    \item Model Checking involves computing a scheduler that resolves nondeterminism
\end{itemize}
\mdfsubtitle{Counterexamples}
\begin{itemize}
    \item A set of offending paths with probability equal or greater than $p$.
    \item An informative counterexample is one which is small and has a high probability.
\end{itemize}
\end{mdframed}

\section{Binary Decision Diagrams and Symbolic Model Checking}
Explicit Representation of $TS$ might be to large, need something smaller.
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Boolean Functions}
]
boolean variable $x_1,x_2,\dots,x,y,z$ ranging over values $0$ and $1$
\mdfsubtitle{Boolean Function}
\begin{itemize}
    \item function $f:\{0,1\}^n\to\{0,1\}$
    \begin{itemize}
        \item $\overline{0}:=1$ and $\overline{1}:=0$
        \item $x\cdot y:=1$ if $x$ and $y$ have value $1$, otherwise $x\cdot y:=0$ {\tiny and}
        \item $x+y:=0$ if $x$ and $y$ have value $0$, otherwise $x+y:=1$ {\tiny or}
        \item $x\oplus y:=1$ if exactly one of $x$ and $y$ equals $1$
    \end{itemize}
\end{itemize}
\mdfsubtitle{Alternative Representations}
\begin{itemize}
    \item function: $f(x,y):=\overline{x+y}$
    \item truth tables
    \begin{tabular}{cc|c}
    $x$ & $y$ & $f(x,y)$ \\
    \hline
    1 & 1 & 0 \\
    0 & 1 & 0 \\
    1 & 0 & 0 \\
    0 & 0 & 1
    \end{tabular}\\
    Seemingly easy comparison (for identical variable ordering), satisfiability, validity, but exponential number of lines (variable combinations)
    \item boolean formula $\neg(p\vee q)$
    \\ compact, but deciding, e.g., satisfiability is NP-complete
\end{itemize}
\end{mdframed}

\subsection{Binary Decision Tree}
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Binary Decision Tree}
]
\begin{itemize}
    \item non-terminal nodes labelled with boolea variables
    \item terminal nodes labelled with $0$ or $1$
    unique boolean functions on variables in terminal nodes
    \begin{itemize}
        \item dashed outgoing edge of node: $variable=0$
        \item solid outgoing edge of node $variable=1$
        \item function value: value of terminal node along path
    \end{itemize}
\end{itemize}
\follows not a compact representation \follows build something that is no longer a tree
\end{mdframed}

\subsection{Binary Decision Diagram (BDD)}
\begin{mdframed}[roundcorner=5pt,
subtitlebelowline=false,subtitleaboveline=false,
subtitlebackgroundcolor=blue!30,
% backgroundcolor=blue!20,
frametitlerule=true,
frametitlebackgroundcolor=blue!30,
frametitle={Binary Decision Diagram (BDD)}
]
\begin{multicols}{2}
\begin{itemize}
    \item a BDD is a finite Directed Acyclic Graph, such that: {\tiny (all binary decision trees are BDDs)}
    \begin{itemize}
        \item it has a unique initial node
        \item all terminal nodes are labelled with $0$ or $1$
        \item all non-terminal nodes are labelled with boolean variables
        \item each non-terminal node has exactly two outgoing edges labelled $0$ (dashed line) or $1$ (solid line)
    \end{itemize}
\end{itemize}
\begin{center}
\scalebox{1}{\input{images/BDD.tikz}}
\end{center}
\end{multicols}
\mdfsubtitle{From Binary Decision Tree to BDD}
\begin{multicols}{2}
\begin{description}
    \item[C1:] removal of duplicate terminals
    \begin{center}
    \scalebox{1}{\input{images/BDD1.tikz}}
    \end{center}
    \item[C2:] removal of redundant tests
    \begin{center}
    \scalebox{1}{\input{images/BDD2.tikz}}
    \end{center}
    \columnbreak
    \item[C3:] removal of duplicate non-terminals: If two non-terminal nodes $n$ and $m$ are the roots of structurally identical sub-trees, then eliminate one of them and redirect all its incoming edges to the other node.
    \begin{center}
    \scalebox{1}{\input{images/BDD3.tikz}}
    \scalebox{1}{\input{images/BDD4.tikz}}
    \end{center}
\end{description}
\end{multicols}
The boolean function is not very recognizable after reduction.
\mdfsubtitle{Reduced BDD}
A BDD is reduced, when no further reduction $C1-C3$ is possible:
\begin{center}
\scalebox{1}{\input{images/BDD5.tikz}}
\end{center}
\mdfsubtitle{Special BDDs}
\begin{multicols}{3}
\begin{center}
\scalebox{1}{\input{images/B1.tikz}}
\end{center}
\begin{center}
\scalebox{1}{\input{images/B0.tikz}}
\end{center}
\begin{center}
\scalebox{1}{\input{images/Bx.tikz}}
\end{center}
\end{multicols}
\mdfsubtitle{Consistent Path}
A Path through a BDD is \emph{consistent} if every value for a variable is decided no more than once. {\tiny When a variable is decided upon one value, it cannot be changed.}
\\ \follows prevent multiple variable occurrences \follows impose and order on variables along every path \follows Ordered BDDs
\mdfsubtitle{Conjunction and Disjunction}
\begin{multicols}{2}
Conjunction
\begin{center}
\scalebox{1}{\input{images/BDD-conjunction.tikz}}
\end{center}
\columnbreak
Disjunction
\begin{center}
\scalebox{1}{\input{images/BDD-disjunction.tikz}}
\end{center}
\end{multicols}
\begin{center}
This works only for consistent paths!
\end{center}
\mdfsubtitle{Ordered BDD (OBDD)}
\begin{itemize}
    \item let $[x_1,\dots,x_n]$ a list of variable names \emph{without duplicates}
    \item let $B$ BDD so that all its non-terminal nodes are members of this list
    \item $B$ has the ordering $[x_1,\dots,x_n]$ if for any path, the occurrence of $x_i$ preceding the occurrence of $x_j$ implies $i<j$
    \item $B$ is then called an \emph{ordered BDD} (OBBD)
\end{itemize}
\mdfsubtitle{Compatible Variable Ordering}
\begin{itemize}
    \item For OBDDs $B_1$ and $B_2$, if it does not happen that there is a variable $x$ occurring before $y$ in $B_1$ and after $y$ in $B_2$, then we say that the variable orderings of $B_1$ and $B_2$ are \emph{compatible}. \\
    \item If reduced OBDDs $B_1$ and $B_2$ describe the same boolean function, then they have identical structure.
    \begin{itemize}
        \item equivalence checking: check for identical structure
        \item applying $C1-C3$ to an OBDD until no further reduction \follows leads to the same reduced OBDD, irrespective of the order they are applied \\
        \follows \emph{canonical form}
    \end{itemize}
    \item OBDDs offer \emph{canonical representation} for boolean functions
    \item OBDDs have worst case exponential size, computing optimal order is expensive, good heuristics usable
\end{itemize}
\mdfsubtitle{Benefits of Canonical Representation}
\begin{itemize}
    \item absence of redundant variables: if the value does not depend on some $x$ it will not appear in reduced OBDD
    \item test for semantic equivalence of functions $f$ and $g$
    \begin{enumerate}
        \item determine compatible ordering of variables (with heuristics to make them good)
        \item reduce $B_f$ and $B_g$
        \item check $B_f$ and $B_g$ for identical structure
    \end{enumerate}
    \item test for validity: reduced OBDD is $B_1$
    \item test for implication $f\implies g$:compute reduced OBDD for $f.g^{-1}$ and check whether it is $B_0$
    \item test for satisfiability: reduced OBDD is not $B_0$
\end{itemize}
\mdfsubtitle{reduce}
\begin{itemize}
    \item idea:
    \begin{itemize}
        \item implements $C1-C3$ in efficient fashion {\tiny $C1$ is just a special case of $C3$}
        \item traverse BDD bottom-up, start with terminal nodes
        \item for $B$ with $[x_1,\dots,x_l]$, $B$ has at most $l+1$ layers
        \item during traversal: assign integer labels $id(n)$ to each node $n$
    \end{itemize}
    \item algorithm
    \begin{itemize}
        \item node $n$ and $m$ have the same label, is sub-BDD computes same boolean function
        \item keep only one node per $id$
    \end{itemize}
    \begin{center}
    \scalebox{1}{\input{images/OBDD.tikz}}
    \end{center}
    \item if $id(lo(n)) = id(hi(n))$, then $id(n):=id(lo(n))$ \\
    boolean test represented by $n$ is redundant
    \item if another node $m$ labeled with same variable $x_i$ and if $id(lo(n))=id(lo(m))$ and $id(hi(n))=id(hi(m))$, then $id(n):=id(m)$ \follows they compute the same boolean function
    \item if nothing of above applies, assign next unused integer
\end{itemize}
\mdfsubtitle{apply}
\begin{itemize}
    \item idea: implement the application of operations to boolean functions
    \begin{itemize}
        \item examples: $+,.,\oplus,$ complement $(f\oplus 1)$
        \item $apply(op,B_f,B_g)$ computes reduced OBDD of $f \, op \, g$
        \item algorithm operates recursively on structure of two OBDDs
        \begin{itemize}
            \item let $v$ be the variable highest in the variable order that occurs in $B_f$ or $B_g$
            \item solve problem separately for $v=0$ and $v=1$
            \item at the leaves apply $op$ directly
            \item reduce result
        \end{itemize}
    \end{itemize}
    \item Restriction:
    \begin{itemize}
        \item $f[0/x]$: boolean formula obtained by replacing all occurrences of $x$ in $f$ by $0$
        \item $f[1/x]$: boolean formula obtained by replacing all occurrences of $x$ in $f$ by $1$
    \end{itemize}
    \item perform recursion on boolean formulas by decomposing them into simpler ones: $f$ on $x$ is equivalent to $\overline{x}\cdot f[0/x]+x\cdot f[1/x]$ {\tiny ($\equiv$ Shannon Expansion)}
    \item use in $apply$
    $f\,op\,g = \overline{x_i}\cdot(f[0/x_i]\,op\,g[0/x_i])+x_i\cdot(f[1/x_i]\,op\,g[1/x_i])$
\end{itemize}
Algorithm of apply:
\begin{itemize}
    \item proceed from roots of $B_f$ and $B_g$ to construct the nodes of OBDD $B_{f\,op\,g}$
    \item let $r_f$ and $r_g$ the root nodes of $B_f$ and $B_g$, respectively
    \item case:
    \begin{itemize}
        \item both nodes are terminal nodes: compute $l_f\,op\,l_g$, if $0\Rightarrow B_0$, if $1\Rightarrow B_1$
        \item both root nodes are $x_i$ nodes: create $x_i$ node $n$ with
        \begin{itemize}
            \item dashed line to $apply(op,lo(r_f),lo(r_g))$
            \item solid line to $apply(op,hi(r_f),hi(r_g))$
        \end{itemize}
        \item $r_f$ is an $x_i$ node, but $r_g$ is a terminal node or an $x_j$ node with $j>i$
        \begin{itemize}
            \item we know there is no $x_i$ node in $B_g$ because the two OBDDs have a compatible ordering \\
            \follows $g$ is indepenednt of $x_i$ since $g\equiv g[0/x_i]\equiv g[1/x_i]$ \\
            \follows create $x_i$ node $n$ with
            \begin{itemize}
                \item dashed line to $apply(op,lo(r_f),r_g$
                \item solid line to $apply(op,hi(r_f),r_g$
            \end{itemize}
        \end{itemize}
        \item $r_g$ is a non-terminal node, but $r_f$ is a terminal node or an $x_j$ node with $j>i$
        \\ \follows symmetrically to above case
    \end{itemize}
    \item call reduce on the result
\end{itemize}
Memoisation
\begin{itemize}
    \item remember results of apply for future calls with identical arguments
    \begin{itemize}
        \item more efficient
        \item less reduction needed
    \end{itemize}
    \item without memoization: apply is exponential in size of arguments
    \item with memoization: number of calls bounded by $2\cdot|B_f|\cdot|B_g|$
    \item in praxis often even better
\end{itemize}
\mdfsubtitle{restrict}
Purpose
\begin{itemize}
    \item compute $f[0/x]$ and $f[1/x]$
    \item calls: $restrict(0,x,B_f)$ and $restrict(1,x,B_f)$
    \item[\follows] yields same variable ordering in result as in $B_f$
\end{itemize}
Procedure
\begin{itemize}
    \item $restrict(0,x,B_f)$: for each node $n$ labeled $x$
    \begin{itemize}
        \item redirect incoming edges to $lo(n)$
        \item remove $n$
        \item call $reduce$ on the result (iteratively)
    \end{itemize}
    \item $restrict(1,x,B_f)$: same, but redirect to $hi(n)$
\end{itemize}
\mdfsubtitle{exists}
useful to express relaxations on constraints for subset of variables:
\begin{itemize}
    \item $\exists x.f := f[0/x]+f[1/x]$ {\tiny ($\exists x.f$ can be true by x being $1$ or $0$)}
    \begin{itemize}
        \item $exists:\quad apply(+,restrict(0,x,B_f),restrict(1,x,B_f))$
    \end{itemize}
\end{itemize}
Implementation Improvements:
\begin{itemize}
    \item restricted nodes have same structure until $x$-nodes, compute application of $+$ to these sub-BDDs
\end{itemize}
\mdfsubtitle{OBDD Operations}
\begin{center}\begin{tabular}{c|c}
Boolean formula $f$ & OBDD $B_f$ \\
\hline
$0$            & $B_0$ \\
$1$            & $B_1$ \\
$x$            & $B_x$ \\
$\overline{f}$ & swap $0$ and $1$ nodes in $B_f$ \\
$f+g$          & \texttt{apply}($+,B_f,B_g$) \\
$f\cdot g$     & \texttt{apply}($\cdot,B_f,B_g$) \\
$f\oplus g$    & \texttt{apply}($\oplus,B_f,B_g$) \\
$f[1/x]$       & \texttt{restrict}($1,x,b_f$) \\
$f[0/x]$       & \texttt{restrict}($0,x,b_f$) \\
$\exists x.f$  & \texttt{apply}($+,B_{f_{f[0/x]}},B_{f_{g[1/x]}}$) \\
$\forall x.f$  & \texttt{apply}($\cdot,B_{f_{f[0/x]}},B_{f_{g[1/x]}}$) \\
\end{tabular} \\[.5cm]
\begin{tabular}{l|l|l|l}
Algorithm & Input OBDD(s) & Output OBDD & Time Complexity \\
\hline
\texttt{reduce}    & $B$                 & reduced $B$                                                  & $\O(|B|\cdot\log|B|)$ \\
\texttt{apply}     & $B_f,B_g$ (reduced) & $B_{f\,op\,g}$ (reduced)                                     & $\O(|B_f|\cdot|B_g|)$ \\
\texttt{restrict}  & $B_f$ (reduced)     & $B_{f[0/x]}$ or $B_{f[1/x]}$ (reduced)                       & $\O(|B_f|\cdot\log|B_f|)$ \\
\texttt{$\exists$} & $B_f$ (reduced)     & $B_{\exists x_1.\exists x_2.\dots .\exists x_n.f}$ (reduced) & NP-complete
\end{tabular}
\end{center}
Domain specific OBDDs exists, which may improve some operations, but they mostly use the canonicity property.
\mdfsubtitle{Symbolic Model Checking Algorithm}
    \begin{align*}
    \phi \text{ is } & \top                        &&: \Return \, S \\
    \phi \text{ is } & \perp                       &&: \Return \, \varnothing \\
    \phi \text{ is } & \text{atomic}               &&: \Return \, \{s\in S|\phi\in L(s)\} \\
    \phi \text{ is } & \neg\phi_1                  &&: \Return \, S-SAT(\phi_1) \\
    \phi \text{ is } & \phi_1\wedge\phi_2          &&: \Return \, SAT(\phi_1)\cap SAT(\phi_2) \\
    \phi \text{ is } & \phi_1\vee\phi_2            &&: \Return \, SAT(\phi_1)\cup SAT(\phi_2) \\
    \phi \text{ is } & \phi_1\to\phi_2             &&: \Return \, SAT(\neg\phi_1\vee\phi_2) \\
    \phi \text{ is } & \forall\circ\phi_1          &&: \Return \, SAT(\neg\exists\circ\neg\phi_1) \\
    \phi \text{ is } & \exists\circ\phi_1          &&: \Return \, SAT_{\exists\circ}(\phi_1) \\
    \phi \text{ is } & \forall(\phi_1\until\phi_2) &&: \Return \, SAT(\neg(\exists[\neg\phi_2\until(\neg\phi_1\wedge\neg\phi_2)]\vee \exists\square\neg\phi_2)) \\
    \phi \text{ is } & \exists(\phi_1\until\phi_2) &&: \Return \, SAT(\exists\until(\phi_1,\phi_2)) \\
    \phi \text{ is } & \exists\diamond\phi_1       &&: \Return \, SAT(\exists(\top\until\phi_1)) \\
    \phi \text{ is } & \exists\square\phi_1        &&: \Return \, SAT(\neg\forall\diamond\neg\phi_1) \\
    \phi \text{ is } & \forall\diamond\phi_1       &&: \Return \, SAT_{\forall\diamond(\phi_1)} \\
    \phi \text{ is } & \forall\square\phi_1        &&: \Return \, SAT(\neg\exists\diamond\neg\phi_1)
    \end{align*}
\mdfsubtitle{Representing OBDDs}
Transition System: $(S,Act,\to,I,AP,L)$
\begin{itemize}
    \item characteristic function $f_s$ for $L:S\to 2^{AP}$, ordering of OBDD is characteristic vector
    \item transition relation: two copies of characteristic vector: $s\to s' \Longrightarrow ((v_1,\dots,v_n),(v'_1,\dots,v'_n))$
\end{itemize}
\mdfsubtitle{Operations on OBDDs used in Model Checking Algorithm}
\begin{itemize}
    \item intersection: $.$
    \item union: $+$
    \item complementation: $\neg$
    \item $pre_\exists(Y)=\{s\in S|\exists s', (s\to s' \text{ and } s'\in Y)$
    \item $pre_\forall(Y)=\{s\in S|\forall s', (s\to s' \text{ implies } s'\in Y)$ \\
    $pre_\forall(Y)=S-pre_\exists(S-Y)$
\end{itemize}
\mdfsubtitle{Algorithm}
\begin{algorithm}[H]
    \Switch{$\Phi$}{
    \begin{align*}
    a & & : && return &\{ s\in S|a\in L(s) \} \\
    \dots& & && \dots \\
    \exists&\circ\Psi & : && return &\{ s\in S|Post(s)\cap Sat(\Phi)\not=\varnothing \} \\
    \exists&(\Phi_1\until\Phi_2) &:&& & \text{compute smallest fixpoint} \\
    \exists&(\Phi) &:&& & \text{compute greatest fixpoint }
    \end{align*}
    }
\end{algorithm}
\mdfsubtitle{$Sat_{EX}$}
\begin{algorithm}[H]
local var $X,Y$ \\
$X:=SAT(\Phi);$ \\
$Y:=pre_{\exists}(X);$ \\
\Return $Y$
\end{algorithm}

\mdfsubtitle{$SAT_{AF}(\Phi)$}
\begin{algorithm}[H]
local var $X,Y$ \\
$X:=S;$ \\
$Y:=SAT(\Phi);$ \\
\While{$X\not=Y$}{
    $X:= Y;$ \\
    $Y:= Y\cup pre_{\forall}(Y);$
}
\Return Y
\end{algorithm}

\mdfsubtitle{$SAT_{EU}(\Phi,\Psi)$}
\begin{algorithm}[H]
$W:=SAT(\Phi);$ \\
$X:=S;$ \\
$Y:=SAT(\Psi)$
\While{$X\not=Y$}{
    $X:=Y;$ \\
    $Y:=Y\cup(W\cap pre_{\exists}(Y)$
}
\Return Y
\end{algorithm}

\mdfsubtitle{OBDD synthesis}
\begin{itemize}
    \item so far: $(model)\to TS \to truth\,table\to OBDD\to\texttt{reduce}$
    \item better: $(model)\to OBDD$ (reduced)
\end{itemize}
\end{mdframed}

\end{document}